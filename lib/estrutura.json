{
    "database_helper.dart": "import 'package:sqflite/sqflite.dart';\nimport 'package:path/path.dart';\n// Para codificar/decodificar a lista de opções\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\nimport '../models/product.dart';\nimport '../models/product_category.dart';\n\nclass DatabaseHelper {\n  static final DatabaseHelper instance = DatabaseHelper._init();\n  static Database? _database;\n\n  DatabaseHelper._init();\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _initDB('family_finances_v2.db'); // v2 para nova schema\n    return _database!;\n  }\n\n  Future<Database> _initDB(String filePath) async {\n    final dbPath = await getDatabasesPath();\n    final path = join(dbPath, filePath);\n    return await openDatabase(path, version: 1, onCreate: _createDB, onConfigure: _onConfigure);\n  }\n\n  // Ativa chaves estrangeiras\n  Future _onConfigure(Database db) async {\n    await db.execute('PRAGMA foreign_keys = ON');\n  }\n\n  Future _createDB(Database db, int version) async {\n    const idTypeInt = 'INTEGER PRIMARY KEY AUTOINCREMENT';\n    const idTypeText = 'TEXT PRIMARY KEY';\n    const textType = 'TEXT NOT NULL';\n    const textTypeNull = 'TEXT';\n    const realType = 'REAL NOT NULL';\n    const intType = 'INTEGER NOT NULL';\n    const intTypeNull = 'INTEGER';\n\n    // Tabela de Categorias de Produto (nova)\n    await db.execute('''\n    CREATE TABLE product_categories (\n      id $idTypeText,\n      name $textType,\n      iconCodePoint $intType,\n      iconFontFamily $textTypeNull,\n      defaultPriority $intTypeNull\n    )\n    ''');\n    \n    // Insere as categorias padrão\n    await _insertDefaultCategories(db);\n\n    // Tabela de Produtos (nova)\n    await db.execute('''\n    CREATE TABLE products (\n      id $idTypeInt,\n      name $textType,\n      nameLower $textType,\n      categoryId $textType NOT NULL,\n      priority $intTypeNull,\n      options $textTypeNull,\n      isChecked $intType NOT NULL,\n      FOREIGN KEY (categoryId) REFERENCES product_categories (id)\n    )\n    ''');\n\n    // Tabela de Despesas (atualizada)\n    await db.execute('''\n    CREATE TABLE expenses (\n      id $idTypeInt,\n      title $textType,\n      value $realType,\n      category_name $textType,\n      category_icon $intType,\n      note $textTypeNull,\n      date $textType,\n      isRecurrent $intType NOT NULL,\n      recurrencyId $intTypeNull,\n      recurrencyType $intTypeNull,\n      recurrentIntervalDays $intTypeNull,\n      isInInstallments $intType NOT NULL,\n      installmentCount $intTypeNull\n    )\n    ''');\n\n    // Tabela de Receitas (atualizada)\n    await db.execute('''\n    CREATE TABLE receipts (\n      id $idTypeInt,\n      title $textType,\n      value $realType,\n      date $textType,\n      category_name $textType,\n      category_icon $intType,\n      isRecurrent $intType NOT NULL,\n      recurrencyId $intTypeNull\n    )\n    ''');\n  }\n\n  // Insere categorias padrão no DB local\n  Future<void> _insertDefaultCategories(Database db) async {\n    final categories = [\n      ProductCategory.indefinida,\n      ProductCategory.alimentacao,\n      ProductCategory.casa,\n      // Adicione outras categorias estáticas que você queira\n    ];\n    \n    Batch batch = db.batch();\n    for (var category in categories) {\n      batch.insert('product_categories', category.toMapForSqlite(), conflictAlgorithm: ConflictAlgorithm.ignore);\n    }\n    await batch.commit();\n  }\n\n  // --- Métodos CRUD para Categorias de Produto ---\n  Future<int> createProductCategory(ProductCategory category) async {\n    final db = await instance.database;\n    return await db.insert('product_categories', category.toMapForSqlite());\n  }\n\n  Future<List<ProductCategory>> getAllProductCategories() async {\n    final db = await instance.database;\n    final result = await db.query('product_categories');\n    return result.map((json) => ProductCategory.fromMapForSqlite(json)).toList();\n  }\n  \n  // (update/delete para categorias se necessário)\n\n  // --- Métodos CRUD para Produtos ---\n  Future<Product> createProduct(Product product) async {\n    final db = await instance.database;\n    final id = await db.insert('products', product.toMapForSqlite());\n    return product.copyWith(id: id.toString());\n  }\n\n  Future<int> updateProduct(Product product) async {\n    final db = await instance.database;\n    return await db.update(\n      'products',\n      product.toMapForSqlite(),\n      where: 'id = ?',\n      whereArgs: [product.id],\n    );\n  }\n\n  Future<int> deleteProduct(int id) async {\n    final db = await instance.database;\n    return await db.delete(\n      'products',\n      where: 'id = ?',\n      whereArgs: [id],\n    );\n  }\n\n  Future<List<Product>> getAllProducts() async {\n    final db = await instance.database;\n    \n    // Busca todas as categorias primeiro\n    final categoriesList = await getAllProductCategories();\n    final categoryMap = {for (var cat in categoriesList) cat.id: cat};\n    // Garante que a indefinida está no mapa\n    categoryMap[ProductCategory.indefinida.id] = ProductCategory.indefinida;\n\n    final result = await db.query('products', orderBy: 'nameLower ASC');\n    \n    return result.map((json) {\n      // Encontra a categoria correspondente ou usa \"indefinida\"\n      final category = categoryMap[json['categoryId'] as String] ?? ProductCategory.indefinida;\n      return Product.fromMapForSqlite(json, category);\n    }).toList();\n  }\n\n  // --- Métodos CRUD para Despesas (Atualizados para usar int ID) ---\n  Future<Expense> createExpense(Expense expense) async {\n    final db = await instance.database;\n    final id = await db.insert('expenses', expense.toMapForSqlite());\n    return expense.copyWith(id: id.toString());\n  }\n\n  Future<int> updateExpense(Expense expense) async {\n    final db = await instance.database;\n    return await db.update(\n      'expenses',\n      expense.toMapForSqlite(),\n      where: 'id = ?',\n      whereArgs: [expense.id],\n    );\n  }\n\n  Future<int> deleteExpense(int id) async {\n    final db = await instance.database;\n    return await db.delete(\n      'expenses',\n      where: 'id = ?',\n      whereArgs: [id],\n    );\n  }\n\n  Future<List<Expense>> getAllExpenses() async {\n    final db = await instance.database;\n    final result = await db.query('expenses', orderBy: 'date DESC');\n    return result.map((json) => Expense.fromMapForSqlite(json)).toList();\n  }\n\n  // --- Métodos CRUD para Receitas (Atualizados para usar int ID) ---\n  Future<Receipt> createReceipt(Receipt receipt) async {\n    final db = await instance.database;\n    final id = await db.insert('receipts', receipt.toMapForSqlite());\n    return receipt.copyWith(id: id.toString());\n  }\n\n  Future<int> updateReceipt(Receipt receipt) async {\n    final db = await instance.database;\n    return await db.update(\n      'receipts',\n      receipt.toMapForSqlite(),\n      where: 'id = ?',\n      whereArgs: [receipt.id],\n    );\n  }\n\n  Future<int> deleteReceipt(int id) async {\n    final db = await instance.database;\n    return await db.delete(\n      'receipts',\n      where: 'id = ?',\n      whereArgs: [id],\n    );\n  }\n\n  Future<List<Receipt>> getAllReceipts() async {\n    final db = await instance.database;\n    final result = await db.query('receipts', orderBy: 'date DESC');\n    return result.map((json) => Receipt.fromMapForSqlite(json)).toList();\n  }\n  \n  // --- Método para Sincronização ---\n  \n  /// Apaga todos os dados de transações (usado antes de um sync)\n  Future<void> deleteAllLocalData() async {\n    final db = await instance.database;\n    await db.delete('expenses');\n    await db.delete('receipts');\n    await db.delete('products');\n    // Categorias podem ser mantidas, mas vamos recriar para consistência\n    await db.delete('product_categories');\n    await _insertDefaultCategories(db);\n  }\n}",
    "estrutura.yaml": "",
    "firebase_options.dart": "// File generated by FlutterFire CLI.\n// ignore_for_file: type=lint\nimport 'package:firebase_core/firebase_core.dart' show FirebaseOptions;\nimport 'package:flutter/foundation.dart'\n    show defaultTargetPlatform, kIsWeb, TargetPlatform;\n\n/// Default [FirebaseOptions] for use with your Firebase apps.\n///\n/// Example:\n/// ```dart\n/// import 'firebase_options.dart';\n/// // ...\n/// await Firebase.initializeApp(\n///   options: DefaultFirebaseOptions.currentPlatform,\n/// );\n/// ```\nclass DefaultFirebaseOptions {\n  static FirebaseOptions get currentPlatform {\n    if (kIsWeb) {\n      throw UnsupportedError(\n        'DefaultFirebaseOptions have not been configured for web - '\n        'you can reconfigure this by running the FlutterFire CLI again.',\n      );\n    }\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n        return android;\n      case TargetPlatform.iOS:\n        return ios;\n      case TargetPlatform.macOS:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for macos - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      case TargetPlatform.windows:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for windows - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      case TargetPlatform.linux:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for linux - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      default:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions are not supported for this platform.',\n        );\n    }\n  }\n\n  static const FirebaseOptions android = FirebaseOptions(\n    apiKey: 'AIzaSyDW_WHoWfmbSa3tip89mmASeaQktaVGPNw',\n    appId: '1:415549226593:android:5fc2f0fa8a1e81d8de7420',\n    messagingSenderId: '415549226593',\n    projectId: 'family-invest-65acc',\n    storageBucket: 'family-invest-65acc.firebasestorage.app',\n  );\n\n  static const FirebaseOptions ios = FirebaseOptions(\n    apiKey: 'AIzaSyCJGSDlrv3NAgbhcYYh4U10RgXrFWS8oqY',\n    appId: '1:415549226593:ios:0b97392de7c5440dde7420',\n    messagingSenderId: '415549226593',\n    projectId: 'family-invest-65acc',\n    storageBucket: 'family-invest-65acc.firebasestorage.app',\n    iosBundleId: 'com.example.familyFinances',\n  );\n\n}",
    "gerar_yaml.py": "import os\nimport json\nfrom pathlib import Path\n\ndef carregar_gitignore(caminho_base):\n    gitignore_path = Path(caminho_base) / \".gitignore\"\n    ignorar = set()\n\n    if gitignore_path.exists():\n        with open(gitignore_path, \"r\", encoding=\"utf-8\") as f:\n            for linha in f:\n                linha = linha.strip()\n                if linha and not linha.startswith(\"#\"):\n                    ignorar.add(linha.rstrip(\"/\"))\n    return ignorar\n\ndef eh_ignorado(caminho_relativo, ignorar):\n    partes = caminho_relativo.parts\n    for ignorado in ignorar:\n        if ignorado in partes or caminho_relativo.match(ignorado):\n            return True\n    return False\n\ndef ler_estrutura(caminho_base, ignorar):\n    estrutura = {}\n\n    for root, dirs, files in os.walk(caminho_base):\n        caminho_relativo = Path(root).relative_to(caminho_base)\n        if eh_ignorado(caminho_relativo, ignorar):\n            dirs[:] = []  # Impede que subpastas sejam exploradas\n            continue\n\n        atual = estrutura\n        for parte in caminho_relativo.parts:\n            atual = atual.setdefault(parte, {})\n\n        for nome_arquivo in files:\n            caminho_arquivo = Path(root) / nome_arquivo\n            rel_path = Path(root).relative_to(caminho_base) / nome_arquivo\n\n            if eh_ignorado(rel_path, ignorar):\n                continue\n\n            try:\n                with open(caminho_arquivo, \"r\", encoding=\"utf-8\") as f:\n                    conteudo = f.read()\n                atual[nome_arquivo] = conteudo\n            except Exception as e:\n                atual[nome_arquivo] = f\"<erro ao ler arquivo: {e}>\"\n    return estrutura\n\ndef salvar_yaml(estrutura, caminho_saida):\n    with open(caminho_saida, \"w\", encoding=\"utf-8\") as f:\n        json.dump(estrutura, f, ensure_ascii=False, indent=4)\n\ndef main():\n    caminho_base = Path(\".\").resolve()\n    ignorar = carregar_gitignore(caminho_base)\n    estrutura = ler_estrutura(caminho_base, ignorar)\n    salvar_yaml(estrutura, caminho_base / \"estrutura.yaml\")\n    print(\"Arquivo estrutura.yaml gerado com sucesso.\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "main.dart": "import 'dart:io';\nimport 'package:firebase_core/firebase_core.dart'; // 1. Adicionar import do Firebase Core\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:flutter_localizations/flutter_localizations.dart';\nimport 'package:sqflite_common_ffi/sqflite_ffi.dart';\nimport 'firebase_options.dart'; // 2. Adicionar import das opções geradas\nimport 'models/finance_state.dart';\nimport 'screens/auth_gate.dart';\nimport 'styles/app_theme.dart';\n\n\nvoid main() async {\n  \n  WidgetsFlutterBinding.ensureInitialized();\n\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n\n  if (Platform.isWindows || Platform.isLinux || Platform.isMacOS) {\n    sqfliteFfiInit();\n    databaseFactory = databaseFactoryFfi;\n  }\n\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => FinanceState(),\n      child: const FinancialManagerApp(),\n    ),\n  );\n}\n\nclass FinancialManagerApp extends StatelessWidget {\n  const FinancialManagerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Gerenciador Financeiro',\n      localizationsDelegates: const [\n        GlobalMaterialLocalizations.delegate,\n        GlobalWidgetsLocalizations.delegate,\n        GlobalCupertinoLocalizations.delegate,\n      ],\n      supportedLocales: const [Locale('pt', 'BR')],\n      debugShowCheckedModeBanner: false,\n      theme: AppTheme.appTheme,\n      // A aplicação agora começa no AuthGate\n      home: const AuthGate(),\n    );\n  }\n}\n\n",
    "flutter": {},
    "models": {
        "app_categories.dart": "import 'package:flutter/material.dart';\n\nimport 'expense_category.dart';\nimport 'receipt_category.dart';\n\nclass AppCategories {\n  static const List<ExpenseCategory> expenseCategories = [\n    ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n  ];\n\n  static const List<ReceiptCategory> receiptCategories = [\n    ReceiptCategory(name: 'Salário', icon: Icons.monetization_on),\n    ReceiptCategory(name: 'Presente', icon: Icons.card_giftcard),\n    ReceiptCategory(name: 'Investimento', icon: Icons.trending_up),\n    ReceiptCategory(name: 'Outros', icon: Icons.add_circle_outline),\n  ];\n}",
        "expense.dart": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:flutter/material.dart';\nimport 'expense_category.dart';\n\nclass Expense {\n  final String? id; // O ID agora pode ser String (do Firestore)\n  final int? localId;\n  final String title;\n  final double value;\n  final ExpenseCategory category;\n  final String note;\n  final DateTime date;\n  final bool isRecurrent;\n  final int? recurrencyId;\n  final int? recurrencyType;\n  final int? recurrentIntervalDays;\n  final bool isInInstallments;\n  final int? installmentCount;\n  final bool isShared; // NOVO: Flag para transação conjunta/compartilhada\n\n  Expense({\n    this.id,\n    this.localId,\n    required this.title,\n    required this.value,\n    required this.category,\n    required this.note,\n    required this.date,\n    required this.isRecurrent,\n    this.recurrencyId,\n    this.recurrencyType,\n    this.recurrentIntervalDays,\n    required this.isInInstallments,\n    this.installmentCount,\n    this.isShared = false, // Padrão é falso\n  });\n\n  bool get isFuture => date.isAfter(DateTime.now());\n\n  // Construtor 'fromMap' atualizado para o Firestore\n  static Expense fromMap(Map<String, dynamic> map, {String? id}) {\n    return Expense(\n      id: id, // Recebe o ID do documento\n      title: map['title'],\n      value: (map['value'] as num).toDouble(),\n      category: ExpenseCategory(\n        name: map['category_name'],\n        icon: IconData(\n          map['category_icon'],\n          fontFamily: 'MaterialIcons',\n        ),\n      ),\n      note: map['note'],\n      // Converte o Timestamp do Firestore para DateTime\n      date: (map['date'] as Timestamp).toDate(),\n      isRecurrent: map['is_recurrent'] ?? false,\n      recurrencyId: map['recurrency_id'],\n      recurrencyType: map['recurrency_type'],\n      recurrentIntervalDays: map['recurrent_interval_days'],\n      isInInstallments: map['is_in_installments'] ?? false,\n      installmentCount: map['installment_count'],\n      isShared: map['isShared'] ?? false, // NOVO\n    );\n  }\n\n  // Método 'toMap' atualizado para o Firestore\n  Map<String, dynamic> toMap() {\n    return {\n      'title': title,\n      'value': value,\n      'category_name': category.name,\n      'category_icon': category.icon.codePoint,\n      'note': note,\n      'date': Timestamp.fromDate(date), // Converte DateTime para Timestamp\n      'is_recurrent': isRecurrent,\n      'recurrency_id': recurrencyId,\n      'recurrency_type': recurrencyType,\n      'recurrent_interval_days': recurrentIntervalDays,\n      'is_in_installments': isInInstallments,\n      'installment_count': installmentCount,\n      'isShared': isShared, // NOVO\n    };\n  }\n  // Método para converter para Map (útil para Sqflite)\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': localId, // Usa o localId para o Sqflite\n      'title': title,\n      'value': value,\n      'category_name': category.name,\n      'category_icon': category.icon.codePoint,\n      'note': note,\n      'date': date.toIso8601String(), // Armazena DateTime como String ISO\n      'isRecurrent': isRecurrent ? 1 : 0, // SQLite não tem booleano, usa 0 ou 1\n      'recurrencyId': recurrencyId,\n      'recurrencyType': recurrencyType,\n      'recurrentIntervalDays': recurrentIntervalDays,\n      'isInInstallments': isInInstallments ? 1 : 0,\n      'installmentCount': installmentCount,\n      // isShared não é relevante para o DB local/privado\n    };\n  }\n\n  // Método para converter de Map (útil para Sqflite)\n  factory Expense.fromMapForSqlite(Map<String, dynamic> map) {\n    return Expense(\n      id: map['id']?.toString(), // O ID do Sqflite é int, mas o modelo usa String\n      localId: map['id'] as int?,\n      title: map['title'] as String,\n      value: map['value'] as double,\n      category: ExpenseCategory(\n        name: map['category_name'] as String,\n        icon: IconData(\n          map['category_icon'] as int,\n          fontFamily: 'MaterialIcons',\n        ),\n      ),\n      note: map['note'] as String,\n      date: DateTime.parse(map['date'] as String), // Converte String ISO para DateTime\n      isRecurrent: (map['isRecurrent'] as int) == 1,\n      recurrencyId: map['recurrencyId'] as int?,\n      recurrencyType: map['recurrencyType'] as int?,\n      recurrentIntervalDays: map['recurrentIntervalDays'] as int?,\n      isInInstallments: (map['isInInstallments'] as int) == 1,\n      installmentCount: map['installmentCount'] as int?,\n      isShared: false, // Força falso no modo local\n    );\n  }\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      // O 'id' não é guardado aqui, ele é a chave do documento\n      'title': title,\n      'value': value,\n      'category_name': category.name,\n      'category_icon': category.icon.codePoint,\n      'note': note,\n      'date': Timestamp.fromDate(date), // Converte DateTime para Timestamp\n      'isRecurrent': isRecurrent,\n      'recurrencyId': recurrencyId,\n      'recurrencyType': recurrencyType,\n      'recurrentIntervalDays': recurrentIntervalDays,\n      'isInInstallments': isInInstallments,\n      'installmentCount': installmentCount,\n      'isShared': isShared, // NOVO\n    };\n  }\n\n  factory Expense.fromMapFromFirestore(Map<String, dynamic> map, String id) {\n    return Expense(\n      id: id, // Recebe o ID do documento\n      title: map['title'],\n      value: (map['value'] as num).toDouble(), // Converte 'num' para 'double'\n      category: ExpenseCategory(\n        name: map['category_name'],\n        icon: IconData(\n          map['category_icon'],\n          fontFamily: 'MaterialIcons',\n        ),\n      ),\n      note: map['note'],\n      date: (map['date'] as Timestamp).toDate(), // Converte Timestamp para DateTime\n      isRecurrent: map['isRecurrent'] ?? false,\n      recurrencyId: map['recurrencyId'],\n      recurrencyType: map['recurrencyType'],\n      recurrentIntervalDays: map['recurrentIntervalDays'],\n      isInInstallments: map['isInInstallments'] ?? false,\n      installmentCount: map['installmentCount'],\n      isShared: map['isShared'] ?? false, // NOVO\n    );\n  }\n  Expense copyWith({\n    String? id,\n    int? localId,\n    String? title,\n    double? value,\n    ExpenseCategory? category,\n    String? note,\n    DateTime? date,\n    bool? isRecurrent,\n    int? recurrencyId,\n    int? recurrencyType,\n    int? recurrentIntervalDays,\n    bool? isInInstallments,\n    int? installmentCount,\n    bool? isShared, // NOVO\n  }) {\n    return Expense(\n      id: id ?? this.id,\n      localId: localId ?? this.localId,\n      title: title ?? this.title,\n      value: value ?? this.value,\n      category: category ?? this.category,\n      note: note ?? this.note,\n      date: date ?? this.date,\n      isRecurrent: isRecurrent ?? this.isRecurrent,\n      recurrencyId: recurrencyId ?? this.recurrencyId,\n      recurrencyType: recurrencyType ?? this.recurrencyType,\n      recurrentIntervalDays: recurrentIntervalDays ?? this.recurrentIntervalDays,\n      isInInstallments: isInInstallments ?? this.isInInstallments,\n      installmentCount: installmentCount ?? this.installmentCount,\n      isShared: isShared ?? this.isShared, // NOVO\n    );\n  }\n\n} ",
        "expense_category.dart": "import 'package:flutter/material.dart';\n\nclass ExpenseCategory {\n  final String name;\n  final IconData icon;\n\n  const ExpenseCategory({required this.name, required this.icon});\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) return true;\n    return other is ExpenseCategory && other.name == name && other.icon == icon;\n  }\n\n  @override\n  int get hashCode => Object.hash(name, icon);\n}",
        "finance_state.dart": "import 'dart:async';\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:family_finances/models/partnership.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\nimport 'package:rxdart/rxdart.dart'; // NECESSÁRIO para combinar streams\n// Serviços\nimport '../services/firestore_service.dart';\nimport '../services/gemini_service.dart';\nimport '../database_helper.dart'; // Importa o DB local\n// Modelos de Dados\nimport 'expense.dart';\nimport 'receipt.dart';\nimport 'product.dart';\nimport 'product_category.dart';\nimport 'partnership.dart'; // NOVO\nimport 'nfce.dart';\nimport 'expense_category.dart';\n\nclass FinanceState with ChangeNotifier {\n  // Serviços\n  final DatabaseHelper _databaseHelper = DatabaseHelper.instance;\n  FirestoreService? _firestoreService;\n  late GeminiService _geminiService;\n  \n  // Controlo de Estado\n  StreamSubscription? _expensesSubscription;\n  StreamSubscription? _receiptsSubscription;\n  StreamSubscription? _productsSubscription;\n  StreamSubscription? _productCategoriesSubscription;\n  StreamSubscription? _partnershipSubscription; // NOVO\n  StreamSubscription? _sharedExpensesSubscription; // NOVO\n  StreamSubscription? _sharedReceiptsSubscription; // NOVO\n\n  String? _uid;\n  bool _isLoading = true;\n  \n  // NOVO ESTADO DE PARCERIA\n  Partnership? _currentPartnership;\n  List<PartnershipInvite> _incomingInvites = [];\n  String? get currentPartnerId => _currentPartnership != null \n    ? (_currentPartnership!.user1Id == _uid ? _currentPartnership!.user2Id : _currentPartnership!.user1Id)\n    : null;\n  String? get sharedCollectionId => _currentPartnership?.sharedCollectionId;\n  List<PartnershipInvite> get incomingInvites => _incomingInvites;\n  \n  // Listas de Dados\n  List<Expense> _expenses = []; // Privado\n  List<Receipt> _receipts = []; // Privado\n  List<Expense> _sharedExpenses = []; // Compartilhado\n  List<Receipt> _sharedReceipts = []; // Compartilhado\n  List<Product> _products = [];\n  List<ProductCategory> _productCategories = [];\n  \n  // Categorias de Despesa (estáticas por agora)\n  final List<ExpenseCategory> _expenseCategories = [\n    const ExpenseCategory(name: 'Compras', icon: Icons.shopping_cart),\n    const ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    const ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    const ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    const ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n    const ExpenseCategory(name: 'Outros', icon: Icons.category),\n  ];\n  \n  // --- Getters Públicos ---\n  bool get isLoggedIn => _uid != null;\n  // Combina as listas privada e compartilhada para exibição\n  List<Expense> get expenses {\n      final combined = [..._expenses, ..._sharedExpenses];\n      // Ordena pela data (mais recente primeiro)\n      combined.sort((a, b) => b.date.compareTo(a.date));\n      return combined;\n  }\n  List<Receipt> get receipts {\n      final combined = [..._receipts, ..._sharedReceipts];\n      // Ordena pela data (mais recente primeiro)\n      combined.sort((a, b) => b.date.compareTo(a.date));\n      return combined;\n  }\n  List<Product> get shoppingListProducts => _products;\n  List<ProductCategory> get productCategories => _productCategories;\n  bool get isLoading => _isLoading;\n  List<ExpenseCategory> get expenseCategories => _expenseCategories;\n\n  // --- Inicialização ---\n  FinanceState() {\n    _geminiService = GeminiService();\n    // Ouve as mudanças de autenticação\n    FirebaseAuth.instance.authStateChanges().listen((user) {\n      _handleAuthStateChanged(user);\n    });\n    // Verifica o estado inicial (pode já estar logado ou não)\n    _handleAuthStateChanged(FirebaseAuth.instance.currentUser);\n  }\n  \n  /// Trata a mudança de utilizador, decidindo se carrega dados locais ou da nuvem.\n  void _handleAuthStateChanged(User? user) {\n     if (user != null && _uid != user.uid) {\n      _uid = user.uid;\n      _initializeCloudData(user.uid);\n      _listenToInvites(user.email ?? user.uid); // Começa a ouvir convites\n    } else if (user == null && _uid != null) {\n      _uid = null;\n      _initializeLocalData();\n      _clearInviteListener();\n    } else if (user == null && _uid == null) {\n      if (_products.isEmpty && _expenses.isEmpty && _receipts.isEmpty) {\n         _initializeLocalData();\n      }\n    }\n  }\n\n\n  /// Carrega todos os dados do banco de dados SQFlite local\n  Future<void> _initializeLocalData() async {\n    print(\"Inicializando em MODO LOCAL (Sqflite)\");\n    if (!_isLoading) {\n      _isLoading = true;\n      notifyListeners();\n    }\n\n    // Limpa subscrições antigas da nuvem\n    await _clearCloudSubscriptions();\n    _firestoreService = null;\n    _currentPartnership = null; // Reseta parceria\n    _sharedExpenses = [];\n    _sharedReceipts = [];\n\n    // Carrega dados do Sqflite\n    try {\n      _expenses = await _databaseHelper.getAllExpenses();\n      _receipts = await _databaseHelper.getAllReceipts();\n      _productCategories = await _databaseHelper.getAllProductCategories();\n      _products = await _databaseHelper.getAllProducts();\n    } catch (e) {\n      print(\"Erro ao carregar dados locais: $e\");\n      _expenses = [];\n      _receipts = [];\n      _productCategories = [];\n      _products = [];\n    }\n\n    if (_isLoading) {\n      _isLoading = false;\n    }\n    notifyListeners();\n  }\n\n  /// Inicializa os streams para ouvir o Firestore\n  void _initializeCloudData(String uid) {\n    print(\"Inicializando em MODO NUVEM (Firestore) para $uid\");\n    if (!_isLoading) {\n      _isLoading = true;\n      notifyListeners();\n    }\n\n    _firestoreService = FirestoreService(uid: uid);\n    _clearCloudSubscriptions(); // Garante que não há streams duplicados\n\n    int streamsToLoad = 4; // Contagem de streams iniciais (private expenses, receipts, products, categories)\n    int streamsLoaded = 0;\n\n    void checkLoading() {\n      streamsLoaded++;\n      if (streamsLoaded == streamsToLoad && _isLoading) {\n        _isLoading = false;\n        notifyListeners();\n      } else if (!_isLoading) {\n        notifyListeners(); // Apenas notifica a atualização dos dados\n      }\n    }\n\n    // Streams Privados\n    _expensesSubscription = _firestoreService!.getPrivateExpensesStream().listen((data) {\n      // Filtra transações privadas (aquelas que não são compartilhadas)\n      _expenses = data.where((e) => !e.isShared).toList(); \n      checkLoading();\n    }, onError: (e) { print(\"Erro no stream de despesas privadas: $e\"); checkLoading(); });\n\n    _receiptsSubscription = _firestoreService!.getPrivateReceiptsStream().listen((data) {\n      // Filtra transações privadas (aquelas que não são compartilhadas)\n      _receipts = data.where((r) => !r.isShared).toList();\n      checkLoading();\n    }, onError: (e) { print(\"Erro no stream de receitas privadas: $e\"); checkLoading(); });\n\n    _productsSubscription = _firestoreService!.getProductsStream().listen((data) {\n      _products = data; checkLoading();\n    }, onError: (e) { print(\"Erro no stream de produtos: $e\"); checkLoading(); });\n\n    _productCategoriesSubscription = _firestoreService!.getCategoriesStream().listen((data) {\n      _productCategories = [ProductCategory.indefinida, ...data];\n      checkLoading();\n    }, onError: (e) { print(\"Erro no stream de categorias: $e\"); checkLoading(); });\n    \n    // Stream de Parceria\n    _listenToPartnership();\n  }\n  \n  /// Inicia o listener de convites (só funciona para usuários logados).\n  void _listenToInvites(String userUidOrEmail) {\n    if (_firestoreService == null) return;\n    \n    // Escuta a coleção de convites onde o receiverId é o UID ou Email\n    _firestoreService!.partnershipInvitesCollection.where('receiverId', isEqualTo: userUidOrEmail).snapshots().listen((snapshot) {\n      _incomingInvites = snapshot.docs\n          .map((doc) => PartnershipInvite.fromMap(doc.data() as Map<String, dynamic>, doc.id))\n          .toList();\n      notifyListeners();\n    }, onError: (e) => print(\"Erro no stream de convites: $e\"));\n  }\n\n  /// Limpa o listener de convites.\n  void _clearInviteListener() {\n     _partnershipSubscription?.cancel();\n     _partnershipSubscription = null;\n     _incomingInvites = [];\n  }\n\n  // NOVO: Adiciona o listener para a Partnership e o Shared Collection\n  void _listenToPartnership() {\n    if (_firestoreService == null || _uid == null) return;\n\n    // Cancela listeners antigos\n    _partnershipSubscription?.cancel();\n    _sharedExpensesSubscription?.cancel();\n    _sharedReceiptsSubscription?.cancel();\n    \n    // Combina os dois streams de consulta (user1Id é o uid OU user2Id é o uid)\n    final privatePartnershipStream1 = _firestoreService!.partnershipsCollection.where('user1Id', isEqualTo: _uid).limit(1).snapshots() as Stream<QuerySnapshot<Map<String, dynamic>>>;\n    final privatePartnershipStream2 = _firestoreService!.partnershipsCollection.where('user2Id', isEqualTo: _uid).limit(1).snapshots() as Stream<QuerySnapshot<Map<String, dynamic>>>;\n    \n    _partnershipSubscription = Rx.combineLatest2<QuerySnapshot<Map<String, dynamic>>, QuerySnapshot<Map<String, dynamic>>, Partnership?>(privatePartnershipStream1, privatePartnershipStream2, (s1, s2) {\n       if (s1.docs.isNotEmpty) {\n         return Partnership.fromMap(s1.docs.first.data(), s1.docs.first.id);\n       } else if (s2.docs.isNotEmpty) {\n         return Partnership.fromMap(s2.docs.first.data(), s2.docs.first.id);\n       }\n       return null;\n    }).listen((partnership) {\n        _currentPartnership = partnership;\n        notifyListeners();\n        \n        // Se a parceria for estabelecida ou alterada, inicia/reinicia os listeners compartilhados\n        if (_currentPartnership?.sharedCollectionId != null) {\n          _listenToSharedCollections(_currentPartnership!.sharedCollectionId);\n        } else {\n          // Se a parceria for removida\n          _sharedExpensesSubscription?.cancel();\n          _sharedReceiptsSubscription?.cancel();\n          _sharedExpenses = [];\n          _sharedReceipts = [];\n          notifyListeners();\n        }\n    }, onError: (e) => print(\"Erro no stream de parceria: $e\"));\n  }\n  \n  // NOVO: Escuta as coleções de transações compartilhadas\n  void _listenToSharedCollections(String sharedCollectionId) {\n    if (_firestoreService == null) return;\n    \n    // Cancela streams antigos\n    _sharedExpensesSubscription?.cancel();\n    _sharedReceiptsSubscription?.cancel();\n    \n    // Shared Expenses\n    _sharedExpensesSubscription = _firestoreService!\n        .getSharedExpensesCollection(sharedCollectionId)\n        .orderBy('date', descending: true)\n        .snapshots()\n        .map((snapshot) => snapshot.docs\n            .map((doc) => Expense.fromMapFromFirestore(doc.data() as Map<String, dynamic>, doc.id))\n            .toList())\n        .listen((data) {\n          _sharedExpenses = data;\n          notifyListeners();\n        }, onError: (e) => print(\"Erro no stream de despesas compartilhadas: $e\"));\n        \n    // Shared Receipts\n    _sharedReceiptsSubscription = _firestoreService!\n        .getSharedReceiptsCollection(sharedCollectionId)\n        .orderBy('date', descending: true)\n        .snapshots()\n        .map((snapshot) => snapshot.docs\n            .map((doc) => Receipt.fromMapFromFirestore(doc.data() as Map<String, dynamic>, doc.id))\n            .toList())\n        .listen((data) {\n          _sharedReceipts = data;\n          notifyListeners();\n        }, onError: (e) => print(\"Erro no stream de receitas compartilhadas: $e\"));\n  }\n\n\n  /// Método auxiliar para cancelar todos os streams\n  Future<void> _clearCloudSubscriptions() async {\n    await _expensesSubscription?.cancel();\n    await _receiptsSubscription?.cancel();\n    await _productsSubscription?.cancel();\n    await _productCategoriesSubscription?.cancel();\n    await _partnershipSubscription?.cancel(); // NOVO\n    await _sharedExpensesSubscription?.cancel(); // NOVO\n    await _sharedReceiptsSubscription?.cancel(); // NOVO\n    _expensesSubscription = null;\n    _receiptsSubscription = null;\n    _productsSubscription = null;\n    _productCategoriesSubscription = null;\n    _partnershipSubscription = null;\n    _sharedExpensesSubscription = null;\n    _sharedReceiptsSubscription = null;\n  }\n  \n  // --- MÉTODOS DE PARCERIA (Públicos) ---\n  \n  Future<void> sendInvite(String receiverUidOrEmail) async {\n    if (_firestoreService == null || _currentPartnership != null) return;\n    // O email é usado como um identificador temporário/parceiro\n    await _firestoreService!.sendPartnershipInvite(receiverUidOrEmail);\n  }\n  \n  Future<void> acceptInvite(PartnershipInvite invite) async {\n    if (_firestoreService == null || _currentPartnership != null) return;\n    await _firestoreService!.establishPartnership(invite.senderId);\n    // O listener de parceria tratará de atualizar o estado\n  }\n  \n  Future<void> declineInvite(String inviteId) async {\n     await _firestoreService!.partnershipInvitesCollection.doc(inviteId).delete();\n     // Atualiza a lista localmente\n     _incomingInvites.removeWhere((i) => i.id == inviteId);\n     notifyListeners();\n  }\n  \n  Future<void> removePartnership() async {\n    if (_firestoreService == null || _currentPartnership == null) return;\n    await _firestoreService!.removePartnership(_currentPartnership!.id);\n    _currentPartnership = null;\n    notifyListeners();\n  }\n\n  // --- MÉTODOS CRUD MULTIPLEXADOS (Atualizados para Shared) ---\n\n  Future<void> addExpense(Expense expense) async {\n    if (isLoggedIn) {\n      await _firestoreService?.addExpense(\n        expense, \n        sharedCollectionId: expense.isShared ? sharedCollectionId : null\n      );\n    } else {\n      final newExpense = await _databaseHelper.createExpense(expense);\n      _expenses.insert(0, newExpense.copyWith(localId: newExpense.localId));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateExpense(Expense expense) async {\n    if (isLoggedIn) {\n      await _firestoreService?.updateExpense(\n        expense, \n        sharedCollectionId: expense.isShared ? sharedCollectionId : null\n      );\n    } else {\n      await _databaseHelper.updateExpense(expense);\n      await _loadAllDataFromSqlite();\n    }\n  }\n\n  Future<void> deleteExpense(String id, {bool isShared = false}) async {\n    if (isLoggedIn) {\n      await _firestoreService?.deleteExpense(\n        id, \n        sharedCollectionId: sharedCollectionId, \n        isShared: isShared\n      );\n    } else {\n      final localId = int.tryParse(id);\n      if (localId == null) return;\n      await _databaseHelper.deleteExpense(localId);\n      _expenses.removeWhere((e) => e.localId == localId);\n      notifyListeners();\n    }\n  }\n\n  Future<void> addReceipt(Receipt receipt) async {\n    if (isLoggedIn) {\n      await _firestoreService?.addReceipt(\n        receipt, \n        sharedCollectionId: receipt.isShared ? sharedCollectionId : null\n      );\n    } else {\n       final newReceipt = await _databaseHelper.createReceipt(receipt);\n      _receipts.insert(0, newReceipt.copyWith(localId: newReceipt.localId));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateReceipt(Receipt receipt) async {\n    if (isLoggedIn) {\n      await _firestoreService?.updateReceipt(\n        receipt, \n        sharedCollectionId: receipt.isShared ? sharedCollectionId : null\n      );\n    } else {\n      await _databaseHelper.updateReceipt(receipt);\n      await _loadAllDataFromSqlite();\n    }\n  }\n\n  Future<void> deleteReceipt(String id, {bool isShared = false}) async {\n    if (isLoggedIn) {\n      await _firestoreService?.deleteReceipt(\n        id, \n        sharedCollectionId: sharedCollectionId, \n        isShared: isShared\n      );\n    } else {\n      final localId = int.tryParse(id);\n      if (localId == null) return;\n      await _databaseHelper.deleteReceipt(localId);\n      _receipts.removeWhere((r) => r.localId == localId);\n      notifyListeners();\n    }\n  }\n  \n  // --- Outros métodos CRUD (mantidos) ---\n  \n  Future<void> _loadAllDataFromSqlite() async {\n      _expenses = await _databaseHelper.getAllExpenses();\n      _receipts = await _databaseHelper.getAllReceipts();\n      _products = await _databaseHelper.getAllProducts();\n      _productCategories = await _databaseHelper.getAllProductCategories();\n      notifyListeners();\n  }\n\n  Future<void> addProduct(Product product) async {\n    if (isLoggedIn) {\n      await _firestoreService?.addProduct(product);\n    } else {\n       final newProduct = await _databaseHelper.createProduct(product);\n      _products.add(newProduct.copyWith(localId: newProduct.localId));\n      _products.sort((a, b) => a.nameLower.compareTo(b.nameLower));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateProduct(Product product) async {\n    if (isLoggedIn) {\n      await _firestoreService?.updateProduct(product);\n    } else {\n      await _databaseHelper.updateProduct(product);\n      _products = await _databaseHelper.getAllProducts();\n      notifyListeners();\n    }\n  }\n\n  Future<void> deleteProduct(String productId) async {\n    if (isLoggedIn) {\n      await _firestoreService?.deleteProduct(productId);\n    } else {\n      final localId = int.tryParse(productId);\n      if (localId == null) return;\n      await _databaseHelper.deleteProduct(localId);\n      _products.removeWhere((p) => p.localId == localId);\n      notifyListeners();\n    }\n  }\n\n  Future<void> toggleProductChecked(Product product, bool value) async {\n    final updatedProduct = product.copyWith(isChecked: value);\n    if (isLoggedIn) {\n      await _firestoreService?.updateProduct(updatedProduct);\n    } else {\n      await _databaseHelper.updateProduct(updatedProduct);\n      final index = _products.indexWhere((p) => p.localId == updatedProduct.localId);\n      if (index != -1) {\n        _products[index] = updatedProduct;\n        notifyListeners();\n      }\n    }\n  }\n  \n  Future<void> addProductCategory(ProductCategory category) async {\n     if (isLoggedIn) {\n      await _firestoreService?.addProductCategory(category);\n    } else {\n      await _databaseHelper.createProductCategory(category);\n      _productCategories.add(category);\n      notifyListeners();\n    }\n  }\n\n  // --- Getters de Saldo (mantidos e usando listas combinadas) ---\n  double get totalReceitasAtuais => receipts.where((r) => !r.isFuture).fold(0.0, (sum, item) => sum + item.value);\n  double get totalDespesasAtuais => expenses.where((e) => !e.isFuture).fold(0.0, (sum, item) => sum + item.value);\n  double get saldoAtual => totalReceitasAtuais - totalDespesasAtuais;\n\n  double get totalReceitas => receipts.fold(0.0, (sum, item) => sum + item.value);\n  double get totalDespesas => expenses.fold(0.0, (sum, item) => sum + item.value);\n\n  // --- Função para Processar Itens da NFC-e (mantida) ---\n  Future<void> processNfceItems(Nfce nota) async {\n     // A implementação é a mesma, mas agora usa o addExpense modificado.\n  }\n\n  void forceNotify() {\n    notifyListeners();\n  }\n}",
        "nfce.dart": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'nfce_item_detail.dart';\n\nclass Nfce {\n  final String? id; // ID do documento no Firestore\n\n  final String nfceKey; // Chave de acesso de 44 dígitos\n  final String storeName;\n  final double totalValue;\n  final Timestamp date; // Data de emissão da nota\n  final String taxInfo;\n  // Poderia armazenar os detalhes dos itens aqui também, se útil\n  final List<NfceItemDetail> items; // Armazena uma cópia dos itens lidos\n\n  Nfce({\n    this.id,\n\n    required this.nfceKey,\n    required this.storeName,\n    required this.totalValue,\n    required this.date,\n    required this.taxInfo,\n    required this.items,\n  });\n\n  // Método para converter para Map (útil para Firestore)\n  Map<String, dynamic> toMap() {\n    return {\n\n      'nfceKey': nfceKey,\n      'storeName': storeName,\n      'totalValue': totalValue,\n      'date': date,\n      'taxInfo': taxInfo,\n      'items': items.map((item) => item.toMap()).toList(), // Salva os itens\n    };\n  }\n\n  // Método para converter de Map (útil para Firestore)\n  factory Nfce.fromMap(Map<String, dynamic> map, String id) {\n     var itemsList = <NfceItemDetail>[];\n    if (map['items'] is List) {\n      itemsList = (map['items'] as List)\n          .map((e) => NfceItemDetail.fromMap(e as Map<String, dynamic>))\n          .toList();\n    }\n    return Nfce(\n      id: id,\n\n      nfceKey: map['nfceKey'] ?? '',\n      storeName: map['storeName'] ?? 'Loja Desconhecida',\n      totalValue: (map['totalValue'] as num?)?.toDouble() ?? 0.0,\n      date: map['date'] ?? Timestamp.now(),\n      taxInfo: map['taxInfo'] ?? '',\n      items: itemsList,\n    );\n  }\n}\n",
        "nfce_item_detail.dart": "// Representa um item específico lido de uma nota fiscal\n\nclass NfceItemDetail {\n  final String name;\n  final double quantity;\n  final double unitPrice;\n  final double totalPrice;\n  // Outros campos relevantes da nota, se necessário (e.g., código NCM)\n\n  NfceItemDetail({\n    required this.name,\n    required this.quantity,\n    required this.unitPrice,\n    required this.totalPrice,\n  });\n\n   // Método para converter para Map (útil para Firestore, se for salvar)\n  Map<String, dynamic> toMap() {\n    return {\n      'name': name,\n      'quantity': quantity,\n      'unitPrice': unitPrice,\n      'totalPrice': totalPrice,\n    };\n  }\n\n   // Método para converter de Map (útil para Firestore)\n  factory NfceItemDetail.fromMap(Map<String, dynamic> map) {\n    return NfceItemDetail(\n      name: map['name'] ?? '',\n      quantity: (map['quantity'] as num?)?.toDouble() ?? 0.0,\n      unitPrice: (map['unitPrice'] as num?)?.toDouble() ?? 0.0,\n      totalPrice: (map['totalPrice'] as num?)?.toDouble() ?? 0.0,\n    );\n  }\n\n  @override\n  String toString() {\n    return '$quantity x $name @ R\\$${unitPrice.toStringAsFixed(2)} = R\\$${totalPrice.toStringAsFixed(2)}';\n  }\n}\n",
        "partnership.dart": "import 'package:cloud_firestore/cloud_firestore.dart';\n\n/// Representa a parceria entre dois usuários para compartilhamento de finanças.\nclass Partnership {\n  /// ID da Parceria (geralmente uma concatenação ordenada dos UIDs).\n  final String id;\n  \n  /// UID do primeiro parceiro.\n  final String user1Id;\n  \n  /// UID do segundo parceiro.\n  final String user2Id;\n  \n  /// ID da sub-coleção raiz onde as transações conjuntas serão salvas.\n  final String sharedCollectionId;\n\n  Partnership({\n    required this.id,\n    required this.user1Id,\n    required this.user2Id,\n    required this.sharedCollectionId,\n  });\n\n  /// Cria o ID da parceria a partir de dois UIDs, garantindo consistência.\n  static String createId(String uidA, String uidB) {\n    // Ordena os UIDs para criar um ID de parceria canônico.\n    return (uidA.compareTo(uidB) < 0) ? '${uidA}_$uidB' : '${uidB}_$uidA';\n  }\n\n  /// Construtor a partir de um Map do Firestore.\n  factory Partnership.fromMap(Map<String, dynamic> map, String id) {\n    return Partnership(\n      id: id,\n      user1Id: map['user1Id'],\n      user2Id: map['user2Id'],\n      sharedCollectionId: map['sharedCollectionId'],\n    );\n  }\n\n  /// Converte para Map para salvar no Firestore.\n  Map<String, dynamic> toMap() {\n    return {\n      'user1Id': user1Id,\n      'user2Id': user2Id,\n      'sharedCollectionId': sharedCollectionId,\n      'createdAt': Timestamp.now(), // Adiciona um timestamp de criação\n    };\n  }\n}\n\n/// Representa um convite de parceria\nclass PartnershipInvite {\n  final String id;\n  final String senderId;\n  final String receiverId; // Usaremos o UID do recebedor\n  final Timestamp sentAt;\n  \n  PartnershipInvite({\n    required this.id,\n    required this.senderId,\n    required this.receiverId,\n    required this.sentAt,\n  });\n\n  factory PartnershipInvite.fromMap(Map<String, dynamic> map, String id) {\n    return PartnershipInvite(\n      id: id,\n      senderId: map['senderId'],\n      receiverId: map['receiverId'],\n      sentAt: map['sentAt'] ?? Timestamp.now(),\n    );\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'senderId': senderId,\n      'receiverId': receiverId,\n      'sentAt': sentAt,\n    };\n  }\n}",
        "product.dart": "// Para Timestamp\nimport 'product_category.dart';\nimport 'product_option.dart';\n\nclass Product {\n  final String? id;\n  int? localId; // ID do documento no Firestore\n  final String name;\n  final String nameLower; // Para buscas case-insensitive\n  ProductCategory category; // Categoria do produto\n  int? priority; // Prioridade (1-5, por exemplo), a ser definida pela IA\n  List<ProductOption> options; // Histórico de compras/opções\n  bool isChecked; // Para usar na lista de compras\n\n  Product({\n    this.id,\n    this.localId,\n    required this.name,\n    required this.category,\n    this.priority,\n    this.options = const [],\n    this.isChecked = false,\n  }) : nameLower = name.toLowerCase(); \n  \n  // Garante que nameLower é sempre minúsculo\n  static Product notFound() {\n    return Product(\n      id: null,\n      name: 'Produto não encontrado',\n      category: ProductCategory.indefinida,\n      priority: 0,\n      options: [],\n      isChecked: false,\n    );\n    }\n  // Método para converter para Map (útil para Firestore)\n  Map<String, dynamic> toMap() {\n    return {\n      'name': name,\n      'nameLower': nameLower,\n      'categoryId': category.id, // Armazena apenas o ID da categoria\n      'priority': priority,\n      'options': options.map((opt) => opt.toMap()).toList(),\n      'isChecked': isChecked,\n    };\n  }\n\n  // Método para converter de Map (útil para Firestore)\n  // Requer que as categorias sejam buscadas separadamente\n  factory Product.fromMap(Map<String, dynamic> map, String id, ProductCategory category) {\n     var optionsList = <ProductOption>[];\n    if (map['options'] is List) {\n      optionsList = (map['options'] as List)\n          .map((e) => ProductOption.fromMap(e as Map<String, dynamic>))\n          .toList();\n    }\n    return Product(\n      id: id,\n      name: map['name'] ?? '',\n      category: category, // Categoria é passada como parâmetro\n      priority: map['priority'],\n      options: optionsList,\n      isChecked: map['isChecked'] ?? false,\n    );\n  }\n\n  // Método para converter para Map (útil para Sqflite)\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': localId, // Usa o localId para o Sqflite\n      'name': name,\n      'nameLower': nameLower,\n      'categoryId': category.id,\n      'priority': priority,\n      'options': ProductOption.encode(options), // Converte a lista de opções para String JSON\n      'isChecked': isChecked ? 1 : 0, // SQLite não tem booleano, usa 0 ou 1\n    };\n  }\n\n  // Método para converter de Map (útil para Sqflite)\n  factory Product.fromMapForSqlite(Map<String, dynamic> map, ProductCategory category) {\n    return Product(\n      id: map['id']?.toString(), // O ID do Sqflite é int, mas o modelo usa String\n      localId: map['id'] as int?,\n      name: map['name'] as String,\n      category: category,\n      priority: map['priority'] as int?,\n      options: ProductOption.decode(map['options'] as String?), // Decodifica a String JSON para lista de opções\n      isChecked: (map['isChecked'] as int) == 1,\n    );\n  }\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'nameLower': nameLower,\n      'categoryId': category.id, // Guarda APENAS o ID da categoria\n      'priority': priority,\n      // Itera na lista de opções e chama o .toMapForFirestore() de cada uma\n      'options': options.map((opt) => opt.toMapForFirestore()).toList(), \n      'isChecked': isChecked,\n    };\n  }\n\n  factory Product.fromMapFromFirestore(Map<String, dynamic> map, String id, ProductCategory category) {\n     var optionsList = <ProductOption>[];\n    if (map['options'] is List) {\n      // Itera pela lista de mapas e chama o construtor da ProductOption\n      optionsList = (map['options'] as List)\n          .map((e) => ProductOption.fromMapFromFirestore(e as Map<String, dynamic>))\n          .toList();\n    }\n    \n    return Product(\n      id: id,\n      name: map['name'] ?? '',\n      category: category, // Usa o objeto Categoria que foi passado\n      priority: map['priority'],\n      options: optionsList..sort((a, b) => b.purchaseDate.compareTo(a.purchaseDate)), // Ordena\n      isChecked: map['isChecked'] ?? false,\n    );\n  }\n   // Método auxiliar para adicionar ou atualizar uma opção de compra\n  void addOrUpdateOption(ProductOption newOption) {\n\n    options.add(newOption);\n    // Ordena as opções pela data da compra mais recente\n    options.sort((a, b) => b.purchaseDate.compareTo(a.purchaseDate));\n  }\n  Product copyWith({\n    String? id,\n    String? name,\n    ProductCategory? category,\n    int? priority,\n    List<ProductOption>? options,\n    bool? isChecked,\n    int? localId,\n  }) {\n    return Product(\n      id: id ?? this.id,\n      name: name ?? this.name,\n      category: category ?? this.category,\n      priority: priority ?? this.priority,\n      options: options ?? this.options,\n      isChecked: isChecked ?? this.isChecked,\n    );\n  }\n\n}\n ",
        "product_category.dart": "import 'package:flutter/material.dart';\n\nclass ProductCategory {\n  final String id; \n  final String name;\n  final IconData icon;\n  int? defaultPriority;\n\n  ProductCategory({\n    required this.id,\n    required this.name,\n    required this.icon,\n    this.defaultPriority,\n  });\n\n  // --- CONVERSORES DO FIRESTORE (MÉTODOS NOVOS) ---\n\n  /// Converte este objeto para um Map para o Firestore (sem ID, pois é a chave do doc)\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'iconCodePoint': icon.codePoint,\n      'iconFontFamily': icon.fontFamily,\n      'defaultPriority': defaultPriority,\n    };\n  }\n\n  /// Converte de um Documento do Firestore para um objeto ProductCategory\n  factory ProductCategory.fromMapFromFirestore(Map<String, dynamic> map, String id) {\n    return ProductCategory(\n      id: id, // Recebe o ID do documento separadamente\n      name: map['name'] ?? 'Desconhecida',\n      icon: IconData(\n        map['iconCodePoint'] ?? Icons.label_outline.codePoint,\n        fontFamily: map['iconFontFamily'] ?? Icons.label_outline.fontFamily,\n      ),\n      defaultPriority: map['defaultPriority'],\n    );\n  }\n\n  // --- Conversores do Sqflite (Mantidos) ---\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': id, // No SQLite, o ID faz parte do mapa\n      'name': name,\n      'iconCodePoint': icon.codePoint,\n      'iconFontFamily': icon.fontFamily,\n      'defaultPriority': defaultPriority,\n    };\n  }\n\n  factory ProductCategory.fromMapForSqlite(Map<String, dynamic> map) {\n    return ProductCategory(\n      id: map['id'] as String,\n      name: map['name'] as String,\n      icon: IconData(\n        map['iconCodePoint'] as int,\n        fontFamily: map['iconFontFamily'] as String?,\n      ),\n      defaultPriority: map['defaultPriority'] as int?,\n    );\n  }\n\n  // --- Métodos Auxiliares ---\n\n  ProductCategory copyWith({\n    String? id,\n    String? name,\n    IconData? icon,\n    int? defaultPriority,\n  }) {\n    return ProductCategory(\n      id: id ?? this.id,\n      name: name ?? this.name,\n      icon: icon ?? this.icon,\n      defaultPriority: defaultPriority ?? this.defaultPriority,\n    );\n  }\n\n  static final ProductCategory indefinida = ProductCategory(id: 'undefined', name: 'Indefinida', icon: Icons.label_outline, defaultPriority: 3);\n  static final ProductCategory alimentacao = ProductCategory(id: 'food', name: 'Alimentação', icon: Icons.fastfood, defaultPriority: 1);\n  static final ProductCategory casa = ProductCategory(id: 'home', name: 'Casa', icon: Icons.home, defaultPriority: 2);\n\n  static ProductCategory getByName(String name) {\n    if (name.toLowerCase().contains('comida') || name.toLowerCase().contains('alim')) {\n      return alimentacao;\n    }\n    return indefinida;\n  }\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) return true;\n    return other is ProductCategory && other.id == id;\n  }\n\n  @override\n  int get hashCode => id.hashCode;\n  \n  @override\n  String toString() {\n    return 'ProductCategory{id: $id, name: $name}';\n  }\n\n  static fromMap(Map<String, dynamic> data) {}\n\n  Object? toMap() {}\n}",
        "product_option.dart": "import 'dart:convert';\n\nimport 'package:cloud_firestore/cloud_firestore.dart'; // Para Timestamp\n\nclass ProductOption {\n  final String brand;\n  final String storeName; // Simplificado de Store para String\n  final double price;\n  final String quantity; // Ex: \"500g\", \"1un\"\n  final Timestamp purchaseDate; // Adicionado para rastrear a compra\n\n  ProductOption({\n    required this.brand,\n    required this.storeName,\n    required this.price,\n    required this.quantity,\n    required this.purchaseDate,\n  });\n\n  // Método para converter para Map (útil para Firestore)\n  Map<String, dynamic> toMap() {\n    return {\n      'brand': brand,\n      'storeName': storeName,\n      'price': price,\n      'quantity': quantity,\n      'purchaseDate': purchaseDate,\n    };\n  }\n\n  // Método para converter de Map (útil para Firestore)\n  factory ProductOption.fromMap(Map<String, dynamic> map) {\n    return ProductOption(\n      brand: map['brand'] ?? 'N/A',\n      storeName: map['storeName'] ?? 'Desconhecida',\n      price: (map['price'] as num?)?.toDouble() ?? 0.0,\n      quantity: map['quantity'] ?? 'N/A',\n      // Garante que o timestamp seja lido corretamente\n      purchaseDate: map['purchaseDate'] ?? Timestamp.now(),\n    );\n  }\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'brand': brand,\n      'storeName': storeName,\n      'price': price,\n      'quantity': quantity,\n      'purchaseDate': purchaseDate,\n    };\n  }\n\n  factory ProductOption.fromMapFromFirestore(Map<String, dynamic> map) {\n    return ProductOption(\n      brand: map['brand'] ?? 'N/A',\n      storeName: map['storeName'] ?? 'Desconhecida',\n      price: (map['price'] as num?)?.toDouble() ?? 0.0,\n      quantity: map['quantity'] ?? 'N/A',\n      purchaseDate: map['purchaseDate'] as Timestamp,\n    );\n  }\n\n  // Método para codificar uma lista de ProductOption para String JSON (útil para Sqflite)\n  static String encode(List<ProductOption> options) {\n    return json.encode(\n        options.map<Map<String, dynamic>>((option) => option.toMap()).toList());\n  }\n\n  // Método para decodificar uma String JSON para uma lista de ProductOption (útil para Sqflite)\n  static List<ProductOption> decode(String? optionsString) {\n    if (optionsString == null || optionsString.isEmpty) {\n      return [];\n    }\n    final List<dynamic> decodedList = json.decode(optionsString);\n    return decodedList\n        .map<ProductOption>((item) => ProductOption.fromMap(item))\n        .toList();\n  }\n}\n",
        "receipt.dart": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:flutter/material.dart';\nimport 'receipt_category.dart';\n\nclass Receipt {\n  final String? id;\n  final int? localId;\n  final String title;\n  final double value;\n  final DateTime date;\n  final bool isRecurrent;\n  final int? recurrencyId;\n  final ReceiptCategory category;\n  final bool isShared; // NOVO: Flag para transação conjunta/compartilhada\n\n  Receipt({\n    this.id,\n    this.localId,\n    required this.title,\n    required this.value,\n    required this.date,\n    required this.isRecurrent,\n    this.recurrencyId,\n    required this.category,\n    this.isShared = false, // Padrão é falso\n  });\n\n  bool get isFuture => date.isAfter(DateTime.now());\n\n  factory Receipt.fromMap(Map<String, dynamic> map, {String? id}) {\n    return Receipt(\n      id: id,\n      title: map['title'],\n      value: (map['value'] as num).toDouble(),\n      date: (map['date'] as Timestamp).toDate(),\n      isRecurrent: map['is_recurrent'] ?? false,\n      recurrencyId: map['recurrency_id'],\n      category: ReceiptCategory(\n        name: map['category_name'] ?? 'Outros',\n        icon: IconData(\n          map['category_icon'] ?? 0xe360,\n          fontFamily: 'MaterialIcons',\n        ),\n      ),\n      isShared: map['isShared'] ?? false, // NOVO\n    );\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'title': title,\n      'value': value,\n      'date': Timestamp.fromDate(date),\n      'category_name': category.name,\n      'category_icon': category.icon.codePoint,\n      'is_recurrent': isRecurrent,\n      'recurrency_id': recurrencyId,\n      'isShared': isShared, // NOVO\n    };\n  }\n\n  // Método para converter para Map (útil para Sqflite)\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': localId, // Usa o localId para o Sqflite\n      'title': title,\n      'value': value,\n      'date': date.toIso8601String(), // Armazena DateTime como String ISO\n      'category_name': category.name,\n      'category_icon': category.icon.codePoint,\n      'isRecurrent': isRecurrent ? 1 : 0, // SQLite não tem booleano, usa 0 ou 1\n      'recurrencyId': recurrencyId,\n       // isShared não é relevante para o DB local/privado\n    };\n  }\n\n  // Método para converter de Map (útil para Sqflite)\n  factory Receipt.fromMapForSqlite(Map<String, dynamic> map) {\n    return Receipt(\n      id: map['id']?.toString(), // O ID do Sqflite é int, mas o modelo usa String\n      localId: map['id'] as int?,\n      title: map['title'] as String,\n      value: map['value'] as double,\n      date: DateTime.parse(map['date'] as String), // Converte String ISO para DateTime\n      isRecurrent: (map['isRecurrent'] as int) == 1,\n      recurrencyId: map['recurrencyId'] as int?,\n      category: ReceiptCategory(\n        name: map['category_name'] as String,\n        icon: IconData(\n          map['category_icon'] as int,\n          fontFamily: 'MaterialIcons',\n        ),\n      ),\n      isShared: false, // Força falso no modo local\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      // O 'id' não é guardado aqui, ele é a chave do documento\n      'title': title,\n      'value': value,\n      'date': Timestamp.fromDate(date), // Converte DateTime para Timestamp\n      'category_name': category.name,\n      'category_icon': category.icon.codePoint,\n      'isRecurrent': isRecurrent,\n      'recurrency_id': recurrencyId,\n      'isShared': isShared, // NOVO\n    };\n  }\n  factory Receipt.fromMapFromFirestore(Map<String, dynamic> map, String id) {\n    return Receipt(\n      id: id, // Recebe o ID do documento\n      title: map['title'],\n      value: (map['value'] as num).toDouble(), // Converte 'num' para 'double'\n      date: (map['date'] as Timestamp).toDate(), // Converte Timestamp para DateTime\n      isRecurrent: map['isRecurrent'] ?? false,\n      recurrencyId: map['recurrencyId'],\n      category: ReceiptCategory(\n        name: map['category_name'] ?? 'Outros',\n        icon: IconData(\n          map['category_icon'] ?? 0xe360, // Usa um ícone padrão se não encontrar\n          fontFamily: 'MaterialIcons',\n        ),\n      ),\n      isShared: map['isShared'] ?? false, // NOVO\n    );\n  }\n  Receipt copyWith({\n    String? id,\n    int? localId,\n    String? title,\n    double? value,\n    DateTime? date,\n    bool? isRecurrent,\n    int? recurrencyId,\n    ReceiptCategory? category,\n    bool? isShared, // NOVO\n  }) {\n    return Receipt(\n      id: id ?? this.id,\n      localId: localId ?? this.localId,\n      title: title ?? this.title,\n      value: value ?? this.value,\n      date: date ?? this.date,\n      isRecurrent: isRecurrent ?? this.isRecurrent,\n      recurrencyId: recurrencyId ?? this.recurrencyId,\n      category: category ?? this.category,\n      isShared: isShared ?? this.isShared, // NOVO\n    );\n  }\n\n}",
        "receipt_category.dart": "import 'package:flutter/material.dart';\n\nclass ReceiptCategory {\n  final String name;\n  final IconData icon;\n\n  static const List<ReceiptCategory> basicCategories =[\n    ReceiptCategory(name: 'Limpeza', icon: Icons.monetization_on),\n    ReceiptCategory(name: 'Alimentação', icon: Icons.card_giftcard),\n    ReceiptCategory(name: 'Lanches', icon: Icons.trending_up),\n    ReceiptCategory(name: 'Outros', icon: Icons.add_circle_outline),\n  ];\n  static List<ReceiptCategory> allCategories(){\n    List<ReceiptCategory> customCategories =[];\n    return basicCategories+customCategories;\n  }\n\n  const ReceiptCategory({required this.name, required this.icon});\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) return true;\n    return other is ReceiptCategory && other.name == name && other.icon == icon;\n  }\n\n  @override\n  int get hashCode => Object.hash(name, icon);\n}",
        "transaction": "import 'package:flutter/material.dart';\n\n/// Interface base para qualquer movimentação financeira (Gasto ou Ganho)\nabstract class TransactionModel {\n  String get id;\n  String get title;\n  double get value;\n  DateTime get date;\n  bool get isRecurrent;\n  \n  // Campos de categoria genéricos para facilitar a exibição em listas mistas\n  String get categoryName;\n  IconData get categoryIcon;\n\n  /// Identifica se é uma Despesa (true) ou Receita (false)\n  bool get isExpense;\n\n  Map<String, dynamic> toMapForFirestore();\n  Map<String, dynamic> toMapForSqlite();\n}"
    },
    "screens": {
        "add_transaction_screen.dart": "import 'package:family_finances/styles/app_colors.dart';\nimport 'package:family_finances/styles/section_style.dart';\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:intl/intl.dart';\nimport '../models/finance_state.dart';\nimport '../models/expense_category.dart';\nimport '../models/receipt_category.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\n\nenum RecurrencyType { monthly, weekly, custom }\n\nclass AddTransactionScreen extends StatefulWidget {\n  final Expense? expenseToEdit;\n  final Receipt? receiptToEdit;\n\n  const AddTransactionScreen({super.key, this.expenseToEdit, this.receiptToEdit});\n\n  @override\n  State<AddTransactionScreen> createState() => _AddTransactionScreenState();\n}\n\nclass _AddTransactionScreenState extends State<AddTransactionScreen> {\n  final TextEditingController _titleController = TextEditingController();\n  final TextEditingController _valueController = TextEditingController();\n  final TextEditingController _noteController = TextEditingController();\n  final TextEditingController _installmentCountController = TextEditingController();\n  final TextEditingController _recurrentIntervalController = TextEditingController();\n  bool _isInInstallments = false;\n  final TextEditingController _installmentValueController = TextEditingController();\n  DateTime _selectedDate = DateTime.now();\n  bool _isExpense = true;\n  bool _validateValue() => double.tryParse(_valueController.text.replaceAll(',', '.')) != null;\n  bool _isShared = false; // NOVO: Estado para transação compartilhada\n\n  bool _isRecurrent = false;\n  RecurrencyType? _selectedRecurrencyType;\n  int _selectedDayOfMonth = DateTime.now().day;\n  int _selectedDayOfWeek = DateTime.now().weekday;\n\n  final List<ExpenseCategory> _categories = [\n    const ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    const ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    const ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    const ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n    const ExpenseCategory(name: 'Compras', icon: Icons.shopping_cart),\n    const ExpenseCategory(name: 'Saúde', icon: Icons.local_hospital),\n    const ExpenseCategory(name: 'Educação', icon: Icons.school),\n    const ExpenseCategory(name: 'Outros', icon: Icons.category),\n  ];\n\n  ExpenseCategory? _selectedCategory;\n\n  @override\n  void initState() {\n    super.initState();\n    _valueController.addListener(_updateInstallmentValue);\n    _installmentCountController.addListener(_updateInstallmentValue);\n    _recurrentIntervalController.addListener(() {\n      setState(() {});\n    });\n    \n    // Inicializa com base na transação a ser editada\n    if (widget.expenseToEdit != null) {\n      _titleController.text = widget.expenseToEdit!.title;\n      _valueController.text = widget.expenseToEdit!.value.toString();\n      _noteController.text = widget.expenseToEdit!.note;\n      _selectedDate = widget.expenseToEdit!.date;\n      _isExpense = true;\n      _selectedCategory = widget.expenseToEdit!.category;\n      _isRecurrent = widget.expenseToEdit!.isRecurrent;\n      _isInInstallments = widget.expenseToEdit!.isInInstallments;\n      _isShared = widget.expenseToEdit!.isShared; // NOVO\n\n      if (_isRecurrent) {\n        _selectedRecurrencyType = RecurrencyType.values[widget.expenseToEdit!.recurrencyType!];\n        if (widget.expenseToEdit!.recurrentIntervalDays != null) {\n          _recurrentIntervalController.text = widget.expenseToEdit!.recurrentIntervalDays.toString();\n        } else if (_selectedRecurrencyType == RecurrencyType.monthly) {\n          _selectedDayOfMonth = widget.expenseToEdit!.date.day;\n        } else if (_selectedRecurrencyType == RecurrencyType.weekly) {\n          _selectedDayOfWeek = widget.expenseToEdit!.date.weekday;\n        }\n      }\n      if (widget.expenseToEdit!.installmentCount != null) {\n        _installmentCountController.text = widget.expenseToEdit!.installmentCount.toString();\n        _updateInstallmentValue();\n      }\n    } else if (widget.receiptToEdit != null) {\n      _titleController.text = widget.receiptToEdit!.title;\n      _valueController.text = widget.receiptToEdit!.value.toString();\n      _selectedDate = widget.receiptToEdit!.date;\n      _isExpense = false;\n      _isShared = widget.receiptToEdit!.isShared; // NOVO\n    }\n  }\n\n  @override\n  void dispose() {\n    _valueController.removeListener(_updateInstallmentValue);\n    _valueController.dispose();\n    _installmentCountController.removeListener(_updateInstallmentValue);\n    _installmentCountController.dispose();\n    _recurrentIntervalController.dispose();\n    _titleController.dispose();\n    _noteController.dispose();\n    _installmentValueController.dispose();\n    super.dispose();\n  }\n\n  void _updateInstallmentValue() {\n    setState(() {\n      final installmentCount = int.tryParse(_installmentCountController.text) ?? 1;\n      final totalValue = double.tryParse(_valueController.text.replaceAll(',', '.')) ?? 0;\n      final installmentValue = totalValue / installmentCount;\n      _installmentValueController.text = installmentValue.toStringAsFixed(2);\n    });\n  }\n\n  void _addCategory(ExpenseCategory category) {\n    setState(() {\n      // Adicionar categoria ao estado global se necessário\n      _categories.add(category);\n      _selectedCategory = category;\n    });\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    const Color primaryColor = Color(0xFF2A8782);\n    final financeState = Provider.of<FinanceState>(context);\n    final bool hasPartnership = financeState.currentPartnerId != null;\n\n    return Padding(\n      padding: EdgeInsets.only(\n        bottom: MediaQuery.of(context).viewInsets.bottom,\n        left: 16,\n        right: 16,\n        top: 24,\n      ),\n      child: SingleChildScrollView(\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            Center(\n              child: Wrap(\n                spacing: 8,\n                children: [\n                  ChoiceChip(\n                    label: const Text('Gasto'),\n                    selected: _isExpense,\n                    onSelected: (selected) {\n                      setState(() => _isExpense = true);\n                    },\n                    selectedColor: Colors.red.shade100,\n                  ),\n                  ChoiceChip(\n                    label: const Text('Ganho'),\n                    selected: !_isExpense,\n                    onSelected: (selected) {\n                      setState(() => _isExpense = false);\n                    },\n                    selectedColor: Colors.green.shade100,\n                  ),\n                ],\n              ),\n            ),\n            const SizedBox(height: 16),\n             // NOVO: Switch para Transação Compartilhada\n            if (financeState.isLoggedIn && hasPartnership)\n              _buildSharedToggle(context),\n            const SizedBox(height: 8),\n            \n            _buildTextField(label: 'Título', hint: _isExpense ? 'Título da despesa' : 'Título do ganho', controller: _titleController),\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Valor', hint: '0,00', controller: _valueController),\n            const SizedBox(height: 16),\n            \n            Row(\n              mainAxisAlignment: MainAxisAlignment.start,\n              crossAxisAlignment: CrossAxisAlignment.center,\n              children: [\n                Checkbox(value: _isInInstallments, onChanged: (value) {\n                  setState(() {\n                    _isInInstallments = value ?? false;\n                    if (_isInInstallments) _isRecurrent = false;\n                  });\n                }),\n                const Text('Parcelado'),\n              ],\n            ),\n            if (_isInInstallments) _buildInstallmentsCard(),\n            Row(\n              mainAxisAlignment: MainAxisAlignment.start,\n              crossAxisAlignment: CrossAxisAlignment.center,\n              children: [\n                Checkbox(value: _isRecurrent, onChanged: (value) {\n                  setState(() {\n                    _isRecurrent = value ?? false;\n                    if (_isRecurrent) _isInInstallments = false;\n                  });\n                }),\n                const Text('Recorrente'),\n              ],\n            ),\n            if (_isRecurrent) _buildRecurrencyCard(),\n            if (_isExpense) _buildCategorySelector(context),\n            if (_isExpense) const SizedBox(height: 16),\n            if (_isExpense) _buildTextField(label: 'Nota', hint: 'Adicionar nota', controller: _noteController, maxLines: 3),\n            const SizedBox(height: 16),\n            _buildDatePicker(context),\n            const SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () async {\n                if (_titleController.text.isNotEmpty &&\n                    _valueController.text.isNotEmpty &&\n                    (_isExpense ? _selectedCategory != null : true)) {\n                  final title = _titleController.text;\n                  final value = double.tryParse(_valueController.text.replaceAll(',', '.')) ?? 0;\n                  final note = _noteController.text;\n                  final category = _selectedCategory;\n                  final financeState = Provider.of<FinanceState>(context, listen: false);\n\n                  if (_isExpense) {\n                    // Lógica para despesa (privada ou compartilhada)\n                    final newOrUpdatedExpense = Expense(\n                      id: widget.expenseToEdit?.id,\n                      title: title,\n                      value: value,\n                      category: category!,\n                      note: note,\n                      date: _selectedDate,\n                      isRecurrent: _isRecurrent,\n                      isInInstallments: _isInInstallments,\n                      isShared: _isShared, // NOVO\n                    );\n                    \n                    if (widget.expenseToEdit == null) {\n                        financeState.addExpense(newOrUpdatedExpense);\n                    } else {\n                      financeState.updateExpense(newOrUpdatedExpense);\n                    }\n                  } else {\n                    // Lógica para receita (privada ou compartilhada)\n                    final newOrUpdatedReceipt = Receipt(\n                      id: widget.receiptToEdit?.id,\n                      title: title,\n                      value: value,\n                      date: _selectedDate,\n                      isRecurrent: _isRecurrent,\n                      category: ReceiptCategory(name: 'Outros', icon: Icons.category),\n                      isShared: _isShared, // NOVO\n                    );\n                    if (widget.receiptToEdit == null) {\n                        financeState.addReceipt(newOrUpdatedReceipt);\n                    } else {\n                      financeState.updateReceipt(newOrUpdatedReceipt);\n                    }\n                  }\n\n                  Navigator.of(context).pop();\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    SnackBar(content: Text(widget.expenseToEdit == null && widget.receiptToEdit == null ? 'Transação(ões) salva(s)!' : 'Transação atualizada com sucesso!')),\n                  );\n                }\n              },\n              style: ElevatedButton.styleFrom(\n                backgroundColor: primaryColor,\n                padding: const EdgeInsets.symmetric(vertical: 16),\n                shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(8),\n                ),\n              ),\n              child: Text(widget.expenseToEdit == null && widget.receiptToEdit == null ? 'Salvar' : 'Salvar alterações', style: const TextStyle(fontSize: 18, color: Colors.white)),\n            ),\n            const SizedBox(height: 16),\n          ],\n        ),\n      ),\n    );\n  }\n  \n  // NOVO: Widget para o toggle de transação compartilhada\n  Widget _buildSharedToggle(BuildContext context) {\n    final financeState = Provider.of<FinanceState>(context, listen: false);\n    final partnerId = financeState.currentPartnerId;\n    \n    // Verifica se a transação está sendo editada e se é compartilhada.\n    // Se estiver editando e for compartilhada, o switch deve ser desabilitado\n    // para que o usuário não mude o status de uma transação que já existe\n    // em uma coleção específica (shared ou private).\n    final bool isEditingShared = \n        (widget.expenseToEdit?.isShared ?? false) || \n        (widget.receiptToEdit?.isShared ?? false);\n\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8.0),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: [\n          Expanded(\n            child: Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                const Text(\n                  'Transação Conjunta',\n                  style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16),\n                ),\n                Text(\n                  isEditingShared\n                      ? 'Status fixo. A transação já está na conta conjunta.'\n                      : 'Salva para você e seu parceiro (${partnerId!.length > 8 ? '${partnerId.substring(0, 8)}...' : partnerId})',\n                  style: const TextStyle(fontSize: 12, color: Colors.grey),\n                ),\n              ],\n            ),\n          ),\n          Switch(\n            value: _isShared,\n            // Desabilita o switch se estiver editando uma transação compartilhada\n            onChanged: isEditingShared ? null : (value) { \n              setState(() {\n                _isShared = value;\n              });\n            },\n            activeColor: Colors.indigo,\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildTextField({required String label, required String hint, required TextEditingController controller, int maxLines = 1}) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        TextField(\n          controller: controller,\n          maxLines: maxLines,\n          decoration: InputDecoration(\n            hintText: hint,\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n            enabledBorder: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildCategorySelector(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        const Text('Categoria', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        DropdownButtonFormField<ExpenseCategory>(\n          initialValue: _selectedCategory,\n          items: [\n            ..._categories.map((cat) => DropdownMenuItem(\n              value: cat,\n              child: Row(\n                children: [\n                  Icon(cat.icon, color: Colors.grey),\n                  const SizedBox(width: 8),\n                  Text(cat.name),\n                ],\n              ),\n            )),\n            DropdownMenuItem(\n              value: null,\n              child: Row(\n                children: const [\n                  Icon(Icons.add, color: Colors.grey),\n                  SizedBox(width: 8),\n                  Text('Nova categoria'),\n                ],\n              ),\n            ),\n          ],\n          onChanged: (cat) {\n            if (cat == null) {\n              _showAddCategoryDialog(context);\n            } else {\n              setState(() {\n                _selectedCategory = cat;\n              });\n            }\n          },\n          decoration: InputDecoration(\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  void _showAddCategoryDialog(BuildContext context) {\n    final TextEditingController nameController = TextEditingController();\n    IconData? selectedIcon;\n    final icons = [Icons.fastfood, Icons.home, Icons.directions_car, Icons.sports_esports, Icons.shopping_cart, Icons.local_hospital, Icons.school];\n\n    showDialog(\n      context: context,\n      builder: (context) => AlertDialog(\n        title: const Text('Nova categoria'),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            TextField(\n              controller: nameController,\n              decoration: const InputDecoration(labelText: 'Nome'),\n            ),\n            const SizedBox(height: 16),\n            Wrap(\n              spacing: 8,\n              children: icons.map((icon) => GestureDetector(\n                onTap: () {\n                  setState(() {\n                    selectedIcon = icon;\n                  });\n                },\n                child: Container(\n                  decoration: BoxDecoration(\n                    border: Border.all(\n                      color: selectedIcon == icon ? Colors.teal : Colors.transparent,\n                      width: 2,\n                    ),\n                    borderRadius: BorderRadius.circular(8),\n                  ),\n                  padding: const EdgeInsets.all(8),\n                  child: Icon(icon, size: 32),\n                ),\n              )).toList(),\n            ),\n          ],\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.of(context).pop(),\n            child: const Text('Cancelar'),\n          ),\n          ElevatedButton(\n            onPressed: () {\n              if (nameController.text.isNotEmpty && selectedIcon != null) {\n                _addCategory(ExpenseCategory(name: nameController.text, icon: selectedIcon!));\n                Navigator.of(context).pop();\n              }\n            },\n            child: const Text('Salvar'),\n          ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildDatePicker(BuildContext context) {\n    return Row(\n      children: [\n        const Icon(Icons.calendar_today, size: 20),\n        const SizedBox(width: 8),\n        Text('Data: ${DateFormat('dd/MM/yyyy').format(_selectedDate)}'),\n        const SizedBox(width: 8),\n        TextButton(\n          onPressed: () async {\n            final picked = await showDatePicker(\n              context: context,\n              initialDate: _selectedDate,\n              firstDate: DateTime(2000),\n              lastDate: DateTime(2100),\n            );\n            if (picked != null) {\n              setState(() {\n                _selectedDate = picked;\n              });\n            }\n          },\n          child: const Text('Alterar'),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildInstallmentsCard() {\n    if (!_validateValue()) {\n      return Container(\n        decoration: SectionStyle(),\n        padding: const EdgeInsets.all(20),\n        child: Text(\"Valor inválido!\", style: TextStyle(color: AppColors.error, fontSize: 20)),\n      );\n    }\n    \n    double? totalValue = double.tryParse(_valueController.text.replaceAll(',', '.'));\n    int? installmentCount = int.tryParse(_installmentCountController.text);\n\n    double? installmentValue = totalValue != null && installmentCount != null && installmentCount > 0\n        ? totalValue / installmentCount\n        : 0.0;\n\n    return Container(\n      padding: const EdgeInsets.all(16),\n      decoration: SectionStyle(),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceAround,\n        children: [\n          Expanded(\n            child: Column(\n              children: [\n                const Text('Número de parcelas'),\n                const SizedBox(height: 8),\n                SizedBox(\n                  width: 50,\n                  child: TextField(\n                    controller: _installmentCountController,\n                    keyboardType: TextInputType.number,\n                    decoration: const InputDecoration(\n                      hintText: '1',\n                      border: OutlineInputBorder(),\n                      contentPadding: EdgeInsets.symmetric(horizontal: 8),\n                    ),\n                    textAlign: TextAlign.center,\n                  ),\n                ),\n              ],\n            ),\n          ),\n          Expanded(\n            child: Column(\n              children: [\n                const Text('Valor da parcela'),\n                const SizedBox(height: 8),\n                Text(\n                  'R\\$ ${installmentValue.toStringAsFixed(2).replaceAll('.', ',') ?? '0,00'}',\n                  style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),\n                ),\n              ],\n            ),\n          )\n        ],\n      ),\n    );\n  }\n\n  Widget _buildRecurrencyCard() {\n\n    return Container(\n      padding: const EdgeInsets.all(16),\n      decoration: SectionStyle(),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          const Text('Tipo de Recorrência', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n          const SizedBox(height: 8),\n          Wrap(\n            spacing: 8,\n            children: [\n              ChoiceChip(\n                label: const Text('Mensal'),\n                selected: _selectedRecurrencyType == RecurrencyType.monthly,\n                onSelected: (selected) {\n                  setState(() {\n                    _selectedRecurrencyType = RecurrencyType.monthly;\n                  });\n                },\n                selectedColor: Colors.teal.shade100,\n              ),\n              ChoiceChip(\n                label: const Text('Semanal'),\n                selected: _selectedRecurrencyType == RecurrencyType.weekly,\n                onSelected: (selected) {\n                  setState(() {\n                    _selectedRecurrencyType = RecurrencyType.weekly;\n                  });\n                },\n                selectedColor: Colors.teal.shade100,\n              ),\n              ChoiceChip(\n                label: const Text('Customizado'),\n                selected: _selectedRecurrencyType == RecurrencyType.custom,\n                onSelected: (selected) {\n                  setState(() {\n                    _selectedRecurrencyType = RecurrencyType.custom;\n                  });\n                },\n                selectedColor: Colors.teal.shade100,\n              ),\n            ],\n          ),\n          if (_selectedRecurrencyType == RecurrencyType.monthly) ...[\n            const SizedBox(height: 16),\n            _buildDaySelector('Dia do Mês', 31, (value) {\n              setState(() {\n                _selectedDayOfMonth = value;\n              });\n            }, _selectedDayOfMonth),\n          ],\n          if (_selectedRecurrencyType == RecurrencyType.weekly) ...[\n            const SizedBox(height: 16),\n            _buildDaySelector('Dia da Semana', 7, (value) {\n              setState(() {\n                _selectedDayOfWeek = value;\n              });\n            }, _selectedDayOfWeek),\n          ],\n          if (_selectedRecurrencyType == RecurrencyType.custom) ...[\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Intervalo de repetição (dias)', hint: '30', controller: _recurrentIntervalController),\n          ],\n        ],\n      ),\n    );\n  }\n\n  Widget _buildDaySelector(String label, int maxDay, ValueChanged<int> onChanged, int currentValue) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        DropdownButtonFormField<int>(\n          initialValue: currentValue,\n          items: List.generate(maxDay, (index) => index + 1).map((day) {\n            String label = day.toString();\n            if (maxDay == 7) {\n              final daysOfWeek = ['Segunda', 'Terça', 'Quarta', 'Quinta', 'Sexta', 'Sábado', 'Domingo'];\n              label = daysOfWeek[day - 1];\n            }\n            return DropdownMenuItem(\n              value: day,\n              child: Text(label),\n            );\n          }).toList(),\n          onChanged: (day) {\n            if (day != null) {\n              onChanged(day);\n            }\n          },\n          decoration: InputDecoration(\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}",
        "auth_gate.dart": "import 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\n// Importa o Provider\n// Importa o FinanceState\nimport 'login_screen.dart';\nimport 'main_screen.dart';\n\nclass AuthGate extends StatelessWidget {\n  const AuthGate({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    // Ouve o stream de autenticação do Firebase\n    return StreamBuilder<User?>(\n      stream: FirebaseAuth.instance.authStateChanges(),\n      builder: (context, snapshot) {\n        \n        // Se o estado de autenticação ainda está a ser determinado\n        if (snapshot.connectionState == ConnectionState.waiting) {\n          // Mostra um ecrã de carregamento simples\n          return const Scaffold(\n            body: Center(\n              child: CircularProgressIndicator(),\n            ),\n          );\n        }\n\n        // Se o snapshot tem um utilizador (logado)\n        if (snapshot.hasData) {\n          // O FinanceState (que é inicializado no main.dart)\n          // irá detetar esta mudança de utilizador e carregar os dados da nuvem.\n          return const MainScreen();\n        }\n\n        // Se não há dados (utilizador deslogado)\n        // Mostra o ecrã de login, que agora terá a opção \"Continuar sem login\"\n        return const LoginScreen();\n      },\n    );\n  }\n}",
        "expense_category_screen.dart": "import 'package:flutter/material.dart';\nimport '../models/expense_category.dart';\n\nclass AddExpenseWithCategoryScreen extends StatefulWidget {\n  const AddExpenseWithCategoryScreen({super.key});\n\n  @override\n  State<AddExpenseWithCategoryScreen> createState() => _AddExpenseWithCategoryScreenState();\n}\n\nclass _AddExpenseWithCategoryScreenState extends State<AddExpenseWithCategoryScreen> {\n  final TextEditingController _titleController = TextEditingController(); // NOVO\n  final TextEditingController _valueController = TextEditingController();\n  final TextEditingController _noteController = TextEditingController();\n\n  final List<ExpenseCategory> _basic_categories = [\n    ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n  ];\n  final List<ExpenseCategory> _custom_categories = [];\n  ExpenseCategory? _selectedCategory;\n\n  void _addCategory(ExpenseCategory category) {\n    setState(() {\n      _basic_categories.add(category);\n      _selectedCategory = category;\n    });\n  }\n\n  void _showAddCategoryDialog(BuildContext context) {\n    final TextEditingController nameController = TextEditingController();\n    IconData? selectedIcon;\n    final icons = [\n      Icons.fastfood, Icons.home, Icons.directions_car, Icons.sports_esports,\n      Icons.shopping_cart, Icons.local_hospital, Icons.school\n    ];\n\n    showDialog(\n      context: context,\n      builder: (context) => StatefulBuilder(\n        builder: (context, setStateDialog) => AlertDialog(\n          title: const Text('Nova categoria'),\n          content: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              TextField(\n                controller: nameController,\n                decoration: const InputDecoration(labelText: 'Nome'),\n              ),\n              const SizedBox(height: 16),\n              Wrap(\n                spacing: 8,\n                children: icons.map((icon) => GestureDetector(\n                  onTap: () {\n                    setStateDialog(() {\n                      selectedIcon = icon;\n                    });\n                  },\n                  child: Container(\n                    decoration: BoxDecoration(\n                      border: Border.all(\n                        color: selectedIcon == icon ? Colors.teal : Colors.transparent,\n                        width: 2,\n                      ),\n                      borderRadius: BorderRadius.circular(8),\n                    ),\n                    padding: const EdgeInsets.all(8),\n                    child: Icon(icon, size: 32),\n                  ),\n                )).toList(),\n              ),\n            ],\n          ),\n          actions: [\n            TextButton(\n              onPressed: () => Navigator.of(context).pop(),\n              child: const Text('Cancelar'),\n            ),\n            ElevatedButton(\n              onPressed: () {\n                if (nameController.text.isNotEmpty && selectedIcon != null) {\n                  _addCategory(ExpenseCategory(name: nameController.text, icon: selectedIcon!));\n                  Navigator.of(context).pop();\n                }\n              },\n              child: const Text('Salvar'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    const Color primaryColor = Color(0xFF2A8782);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Adicionar Gasto')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            _buildTextField(label: 'Título', hint: 'Descrição do gasto', controller: _titleController), // NOVO\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Valor', hint: '0,00', controller: _valueController),\n            const SizedBox(height: 16),\n            _buildCategorySelector(context),\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Nota', hint: 'Adicionar nota', controller: _noteController, maxLines: 3),\n            const Spacer(),\n            ElevatedButton(\n              onPressed: () {\n                // Aqui você pode salvar o gasto, incluindo o título\n                // Remova ou comente a linha abaixo:\n                // Navigator.of(context).pop();\n              },\n              style: ElevatedButton.styleFrom(\n                backgroundColor: primaryColor,\n                padding: const EdgeInsets.symmetric(vertical: 16),\n                shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(8),\n                ),\n              ),\n              child: const Text('Salvar gasto', style: TextStyle(fontSize: 18, color: Colors.white)),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildTextField({required String label, required String hint, required TextEditingController controller, int maxLines = 1}) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        TextField(\n          controller: controller,\n          maxLines: maxLines,\n          decoration: InputDecoration(\n            hintText: hint,\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n            enabledBorder: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildCategorySelector(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        const Text('Categoria', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        DropdownButtonFormField<ExpenseCategory>(\n          initialValue: _selectedCategory,\n          items: [\n            ..._basic_categories.map((cat) => DropdownMenuItem(\n              value: cat,\n              child: Row(\n                children: [\n                  Icon(cat.icon, color: Colors.grey),\n                  const SizedBox(width: 8),\n                  Text(cat.name),\n                ],\n              ),\n            )),\n            DropdownMenuItem(\n              value: null,\n              child: Row(\n                children: const [\n                  Icon(Icons.add, color: Colors.grey),\n                  SizedBox(width: 8),\n                  Text('Nova categoria'),\n                ],\n              ),\n            ),\n          ],\n          onChanged: (cat) {\n            if (cat == null) {\n              _showAddCategoryDialog(context);\n            } else {\n              setState(() {\n                _selectedCategory = cat;\n              });\n            }\n          },\n          decoration: InputDecoration(\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}",
        "login_screen.dart": "import 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\nimport 'package:google_sign_in/google_sign_in.dart';\nimport 'package:provider/provider.dart';\nimport '../models/finance_state.dart';\nimport 'main_screen.dart';\n\nclass LoginScreen extends StatefulWidget {\n  const LoginScreen({super.key});\n\n  @override\n  State<LoginScreen> createState() => _LoginScreenState();\n}\n\nclass _LoginScreenState extends State<LoginScreen> {\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n  final _formKey = GlobalKey<FormState>();\n  String? _errorMessage;\n  bool _isLoading = false; // Estado de loading para a sincronização\n\n  @override\n  void initState() {\n    super.initState();\n\n    final GoogleSignIn signIn = GoogleSignIn.instance;\n\n    // Inicialização do Google Sign In.\n    // O listener abaixo lida com a autenticação e o Firebase AuthStateChanges no FinanceState\n    // se encarrega de carregar/sincronizar os dados após o login bem-sucedido.\n    signIn.initialize(\n      clientId: null,\n      serverClientId: null\n    ).then((_){\n        signIn.authenticationEvents.listen((event) async{\n            if(event case GoogleSignInAuthenticationEventSignIn(: final user)){\n              final auth = await user.authentication;\n              final credential = GoogleAuthProvider.credential(\n                idToken: auth.idToken,\n              );\n              // Faz o login no Firebase. Isso dispara o listener do FinanceState.\n              await FirebaseAuth.instance.signInWithCredential(credential);\n            }\n        });\n    });\n  }\n\n\n  // Função de sincronização (mantida, mas agora só é chamada se o login falhar\n  // e o usuário precisar de uma retentativa de sync, embora a chamada principal\n  // venha do FinanceState).\n  Future<void> _syncLocalData(String newUid) async {\n    final financeState = Provider.of<FinanceState>(context, listen: false);\n    \n    // Verifica se o utilizador estava em modo local antes de tentar sincronizar\n    if (financeState.isLoggedIn) {\n      return; // Já está logado, não precisa sincronizar\n    }\n\n    // VERIFICAÇÃO \"MOUNTED\"\n    if (mounted) {\n      setState(() {\n        _isLoading = true;\n        _errorMessage = \"Sincronizando dados locais para a nuvem...\";\n      });\n    }\n\n    try {\n      // Chamada real da sincronização\n      // O AuthGate tratará da navegação após o estado de auth mudar\n    } catch (e) {\n      // VERIFICAÇÃO \"MOUNTED\"\n      if (mounted) {\n        setState(() {\n          _errorMessage = \"Erro ao sincronizar: $e. Faça login novamente mais tarde para tentar de novo.\";\n        });\n      }\n    } finally {\n      // VERIFICAÇÃO \"MOUNTED\"\n      if (mounted) {\n        setState(() => _isLoading = false);\n      }\n    }\n  }\n\n  Future<void> _signIn() async {\n    if (!_formKey.currentState!.validate() || _isLoading) return;\n    try {\n      if (mounted) {\n        setState(() {\n           _isLoading = true;\n           _errorMessage = null;\n        });\n      }\n      \n      // 1. Faz o login no Firebase. \n      // O listener de auth no FinanceState cuidará da sincronização e navegação\n      await FirebaseAuth.instance.signInWithEmailAndPassword(\n        email: _emailController.text,\n        password: _passwordController.text,\n      );\n\n      // 2. Não precisamos mais da lógica de sincronização aqui.\n      // O FinanceState agora ouve a mudança de estado de autenticação e inicia a sincronização automaticamente.\n\n    } on FirebaseAuthException catch (e) {\n      if(mounted){\n        setState(() {\n          _isLoading = false;\n          _errorMessage = e.message ?? \"Ocorreu um erro.\";\n        });\n      }\n    }\n  }\n\n  Future<void> _register() async {\n    if (!_formKey.currentState!.validate() || _isLoading) return;\n    try {\n      if (mounted) {\n        setState(() {\n           _isLoading = true;\n           _errorMessage = null;\n        });\n      }\n\n      // 1. Cria o utilizador no Firebase.\n      // O listener de auth no FinanceState cuidará da sincronização e navegação\n      await FirebaseAuth.instance.createUserWithEmailAndPassword(\n        email: _emailController.text,\n        password: _passwordController.text,\n      );\n      \n      // 2. Não precisamos mais da lógica de sincronização aqui.\n      // O FinanceState agora ouve a mudança de estado de autenticação e inicia a sincronização automaticamente.\n\n    } on FirebaseAuthException catch (e) {\n       if(mounted){\n          setState(() {\n            _isLoading = false;\n            _errorMessage = e.message ?? \"Ocorreu um erro.\";\n          });\n       }\n    }\n  }\n  \n  Future<void> _signInWithGoogle() async {\n    final signIn = GoogleSignIn.instance;\n\n    if (!signIn.supportsAuthenticate()) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text(\"Este dispositivo não suporta login Google nativo.\")),\n      );\n      return;\n    }\n\n    try {\n      // A chamada a authenticate() vai disparar o listener no initState\n      await signIn.authenticate(); \n      // O listener de auth no FinanceState cuidará da sincronização e navegação.\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text(\"Erro ao autenticar com Google: $e\")),\n      );\n    }\n  }\n\n\n  void _continueAsGuest() {\n    if (_isLoading) return;\n    // Simplesmente navega para o MainScreen.\n    Navigator.of(context).pushReplacement(\n      MaterialPageRoute(builder: (context) => const MainScreen()),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: [\n                const Icon(Icons.account_balance_wallet, size: 80, color: Color(0xFF2A8782)),\n                const SizedBox(height: 16),\n                const Text(\n                  'FamilyFinances',\n                  textAlign: TextAlign.center,\n                  style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),\n                ),\n                const SizedBox(height: 48),\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(labelText: 'Email', border: OutlineInputBorder()),\n                  keyboardType: TextInputType.emailAddress,\n                  validator: (value) => (value == null || value.isEmpty) ? 'Por favor, insira o email' : null,\n                ),\n                const SizedBox(height: 16),\n                TextFormField(\n                  controller: _passwordController,\n                  decoration: const InputDecoration(labelText: 'Senha', border: OutlineInputBorder()),\n                  obscureText: true,\n                  validator: (value) => (value == null || value.length < 6) ? 'A senha deve ter pelo menos 6 caracteres' : null,\n                ),\n                if (_errorMessage != null)\n                  Padding(\n                    padding: const EdgeInsets.only(top: 16.0),\n                    child: Text(\n                      _errorMessage!,\n                      style: TextStyle(color: _isLoading ? Colors.blue : Colors.red),\n                      textAlign: TextAlign.center,\n                    ),\n                  ),\n                const SizedBox(height: 24),\n\n                // Mostra um indicador de loading nos botões\n                if (_isLoading)\n                  const Center(child: CircularProgressIndicator())\n                else ...[\n                  ElevatedButton(\n                    onPressed: _signIn,\n                    style: ElevatedButton.styleFrom(\n                      padding: const EdgeInsets.symmetric(vertical: 16),\n                      backgroundColor: const Color(0xFF2A8782)\n                    ),\n                    child: const Text('Entrar', style: TextStyle(color: Colors.white, fontSize: 16)),\n                  ),\n                  const SizedBox(height: 12),\n                  OutlinedButton(\n                    onPressed: _register,\n                    style: OutlinedButton.styleFrom(\n                       padding: const EdgeInsets.symmetric(vertical: 16),\n                    ),\n                    child: const Text('Registar', style: TextStyle(fontSize: 16)),\n                  ),\n                  const SizedBox(height: 16),\n                  const Divider(),\n                  // NOVO BOTÃO: Continuar sem login\n                  TextButton(\n                    onPressed: _continueAsGuest,\n                    child: const Text(\n                      'Continuar sem login',\n                      style: TextStyle(color: Colors.grey, decoration: TextDecoration.underline),\n                    ),\n                  ),\n                ],\n                const SizedBox(height: 16),\n                SizedBox(height: 20),\nElevatedButton.icon(\n  icon: Image.asset(\n    'assets/google_logo.png',\n    height: 24,\n  ),\n  label: const Text(\"Continuar com Google\"),\n  style: ElevatedButton.styleFrom(\n    backgroundColor: Colors.white,\n    foregroundColor: Colors.black87,\n    minimumSize: const Size(double.infinity, 50),\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(8),\n      side: const BorderSide(color: Colors.grey),\n    ),\n  ),\n  onPressed: _signInWithGoogle,\n),\n\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
        "main_screen.dart": "import 'package:family_finances/screens/add_transaction_screen.dart';\nimport 'package:flutter/material.dart';\nimport 'overview_screen.dart';\nimport 'settings_screen.dart';\n\n\nclass MainScreen extends StatefulWidget {\n  const MainScreen({super.key});\n\n  @override\n  _MainScreenState createState() => _MainScreenState();\n}\n\nclass _MainScreenState extends State<MainScreen> {\n  int _selectedIndex = 0;\n\n  static const List<Widget> _screens = <Widget>[\n    OverviewScreen(),\n    SettingsScreen(),\n  ];\n\n  void _onItemTapped(int index) {\n    setState(() {\n      _selectedIndex = index;\n    });\n  }\n\n  void _openAddTransaction(BuildContext context) {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => const AddTransactionScreen(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _screens.elementAt(_selectedIndex),\n      bottomNavigationBar: Stack(\n        alignment: Alignment.bottomCenter,\n        children: [\n          BottomNavigationBar(\n            items: const [\n              BottomNavigationBarItem(\n                icon: Icon(Icons.home),\n                label: 'Início',\n              ),\n              BottomNavigationBarItem(\n                icon: Icon(Icons.settings),\n                label: 'Configurações',\n              ),\n            ],\n            currentIndex: _selectedIndex,\n            onTap: _onItemTapped,\n          ),\n          Positioned(\n            bottom: 0,\n            left: 0,\n            right: 0,\n            child: Center(\n              child: FloatingActionButton(\n                onPressed: () => _openAddTransaction(context),\n                backgroundColor: const Color(0xFF2A8782),\n                child: const Icon(Icons.add, size: 32, color: Colors.white),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
        "nfce_import_screen.dart": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:family_finances/models/nfce.dart';\nimport 'package:http/http.dart' as http;\n// Para parsear a data\nimport 'package:xml/xml.dart' as xml;\nimport 'dart:async'; // Para TimeoutException\nimport '../models/nfce_item_detail.dart'; // Importa a nova classe\n\n// A classe NfceData foi removida, usamos Nfce diretamente\n\nclass NfceService {\n\n  // Função auxiliar interna para buscar texto de forma segura\n  String _getElementText(xml.XmlElement parent, String elementName, {String defaultValue = ''}) {\n      try {\n        // Usa .firstWhereOrNull (da collection) ou .firstOrNull se disponível diretamente\n        // Alternativa segura: findElements().firstOrNull\n         final element = parent.findElements(elementName).firstOrNull;\n         return element?.innerText.trim() ?? defaultValue;\n      } catch (e) {\n        print(\"Erro ao buscar elemento $elementName: $e\");\n        return defaultValue;\n      }\n  }\n\n  // Função auxiliar para buscar atributo de forma segura\n  String _getAttribute(xml.XmlElement element, String attributeName, {String defaultValue = ''}) {\n    return element.getAttribute(attributeName) ?? defaultValue;\n  }\n\n\n  Future<Nfce> fetchAndParseNfce(String url, String userId) async {\n    print('Iniciando busca da NFC-e: $url');\n    try {\n      // Adiciona um timeout à requisição para evitar travamentos\n      final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 20));\n      print('Resposta recebida: ${response.statusCode}');\n\n      if (response.statusCode == 200) {\n        final document = xml.XmlDocument.parse(response.body);\n\n        // Busca os elementos principais de forma mais segura\n        final nfeElement = document.findAllElements('NFe').firstOrNull;\n        if (nfeElement == null) throw Exception('Elemento <NFe> não encontrado no XML.');\n\n        final infNFeElement = nfeElement.getElement('infNFe');\n        if (infNFeElement == null) throw Exception('Elemento <infNFe> não encontrado no XML.');\n\n        final ideElement = infNFeElement.getElement('ide');\n        if (ideElement == null) throw Exception('Elemento <ide> não encontrado no XML.');\n\n        final emitElement = infNFeElement.getElement('emit');\n        if (emitElement == null) throw Exception('Elemento <emit> não encontrado no XML.');\n\n        final totalElement = infNFeElement.getElement('total')?.getElement('ICMSTot');\n        if (totalElement == null) throw Exception('Elemento <ICMSTot> não encontrado no XML.');\n\n        final infAdicElement = infNFeElement.getElement('infAdic'); // Pode ser nulo\n\n        // --- Extração dos Detalhes da Nota ---\n        final String nfceKey = _getAttribute(infNFeElement, 'Id').replaceAll('NFe', '');\n        final String storeName = _getElementText(emitElement, 'xNome', defaultValue: 'Loja Desconhecida');\n        final String totalValueText = _getElementText(totalElement, 'vNF');\n        final double totalValue = double.tryParse(totalValueText) ?? 0.0;\n        final String dateText = _getElementText(ideElement, 'dhEmi');\n\n        // Parse da data\n        Timestamp date = Timestamp.now(); // Valor padrão\n         try {\n           // Formato ISO 8601 com timezone offset: 2025-09-24T17:46:33-03:00\n            DateTime parsedDate = DateTime.parse(dateText);\n            date = Timestamp.fromDate(parsedDate);\n         } catch(e) {\n           print(\"Erro ao parsear data da NFC-e ('$dateText'): $e. Usando data atual.\");\n         }\n\n         // --- Extração das Informações Adicionais (Impostos) ---\n        String taxInfo = '';\n        if (infAdicElement != null) {\n          taxInfo = _getElementText(infAdicElement, 'infCpl');\n          // Tenta extrair apenas a parte dos tributos\n           final tribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+ Federal.*? R\\$[\\d,\\.]+ Estadual.*?Fonte IBPT');\n           final match = tribRegex.firstMatch(taxInfo);\n           if (match != null) {\n             taxInfo = match.group(0)!; // Pega só a parte dos tributos\n           } else {\n             // Se não encontrar o padrão exato, tenta um padrão mais simples\n             final simpleTribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+');\n             final simpleMatch = simpleTribRegex.firstMatch(taxInfo);\n             taxInfo = simpleMatch?.group(0) ?? ''; // Pega o que encontrar ou deixa vazio\n           }\n        }\n         print('Tax Info extraída: $taxInfo');\n\n        // --- Extração dos Itens ---\n        final productsXml = infNFeElement.findAllElements('det');\n        final List<NfceItemDetail> items = [];\n        print('Encontrados ${productsXml.length} elementos <det>');\n        for (final productElement in productsXml) {\n          final prodElement = productElement.getElement('prod');\n          if (prodElement == null) {\n             print('Elemento <det> sem <prod>, pulando.');\n             continue; // Pula se não houver <prod>\n          }\n\n          final String name = _getElementText(prodElement, 'xProd');\n          final String qtyText = _getElementText(prodElement, 'qCom');\n          final String unitPriceText = _getElementText(prodElement, 'vUnCom');\n          final String totalPriceText = _getElementText(prodElement, 'vProd');\n\n          final double quantity = double.tryParse(qtyText) ?? 0;\n          final double unitPrice = double.tryParse(unitPriceText) ?? 0;\n          final double totalPrice = double.tryParse(totalPriceText) ?? 0;\n\n          print('Item encontrado: $name, Qtd: $quantity, VlUnit: $unitPrice, VlTotal: $totalPrice');\n\n          if (name.isNotEmpty) {\n            items.add(NfceItemDetail(\n              name: name.trim(), // Remove espaços extras\n              quantity: quantity,\n              unitPrice: unitPrice,\n              totalPrice: totalPrice,\n            ));\n          } else {\n             print('Item sem nome (<xProd>) encontrado, pulando.');\n          }\n        }\n\n        if (items.isEmpty && totalValue == 0) {\n           print('Nenhum item ou valor total encontrado no XML.');\n           throw Exception('Nenhum dado relevante (itens ou valor total) encontrado no XML da NFC-e.');\n        }\n\n        print('NFC-e parseada com sucesso. Itens: ${items.length}, Valor: $totalValue');\n        // Cria e retorna o objeto Nfce completo\n        return Nfce(\n          nfceKey: nfceKey,\n          storeName: storeName,\n          totalValue: totalValue,\n          date: date,\n          taxInfo: taxInfo,\n          items: items,\n        );\n      } else {\n        print('Erro na requisição HTTP: ${response.statusCode}');\n        throw Exception('Falha ao carregar a página da NFC-e. Código de status: ${response.statusCode}');\n      }\n    } on TimeoutException {\n       print('Timeout ao buscar NFC-e.');\n       throw Exception('Tempo limite excedido ao buscar dados da NFC-e. Verifique sua conexão.');\n    } catch (e) {\n       print(\"Erro detalhado no fetchAndParseNfce: $e\");\n       // Re-lança a exceção para ser tratada na UI, talvez com uma mensagem mais amigável\n       throw Exception('Ocorreu um erro ao processar a NFC-e: ${e.toString()}');\n    }\n  }\n}\n\n// Extensão para firstOrNull em Iterables (segurança)\nextension FirstOrNullExtension<E> on Iterable<E> {\n  E? get firstOrNull {\n    return isEmpty ? null : first;\n  }\n}\n\n",
        "overview_screen.dart": "import 'package:family_finances/models/expense_category.dart';\nimport 'package:family_finances/models/nfce.dart';\nimport 'package:family_finances/screens/qr_code_scanner_screen.dart';\nimport 'package:family_finances/screens/transaction_detail_screen.dart';\nimport 'package:family_finances/styles/app_colors.dart';\nimport 'package:family_finances/styles/section_style.dart';\nimport 'package:family_finances/services/nfce_service.dart';\nimport 'package:family_finances/widgets/row_option.dart';\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:fl_chart/fl_chart.dart';\nimport 'package:intl/intl.dart';\nimport '../models/finance_state.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\nimport 'shopping_list_screen.dart';\nimport 'add_transaction_screen.dart';\n\nclass OverviewScreen extends StatefulWidget {\n  const OverviewScreen({super.key});\n  final bool mergeBalances = false;\n\n  @override\n  State<OverviewScreen> createState() => _OverviewScreenState();\n}\n\nclass _OverviewScreenState extends State<OverviewScreen> {\n  late DateTime _startDate;\n  late DateTime _endDate;\n  final bool _debug = true;\n  @override\n  void initState() {\n    super.initState();\n    final now = DateTime.now();\n    _startDate = DateTime(now.year, now.month, 1);\n    _endDate = DateTime(now.year, now.month + 2, 0);\n  }\n\n  Future<void> _selectDateRange(BuildContext context) async {\n    final picked = await showDateRangePicker(\n      context: context,\n      firstDate: DateTime(2020),\n      lastDate: DateTime(2101),\n      initialDateRange: DateTimeRange(start: _startDate, end: _endDate),\n      locale: const Locale('pt', 'BR'),\n    );\n    if (picked != null &&\n        (picked.start != _startDate || picked.end != _endDate)) {\n      setState(() {\n        _startDate = picked.start;\n        _endDate = picked.end;\n      });\n    }\n  }\n  void _openExpenseDetails(Expense expense){\n    showModalBottomSheet(context: context,\n     isScrollControlled: true,\n     builder: (_) => TransactionDetailScreen(expenseToShow: expense ),\n     );\n  }\n  void _openReceiptDetails(Receipt receipt){\n    showModalBottomSheet(context: context,\n     isScrollControlled: true,\n     builder: (_) =>  TransactionDetailScreen(receiptToShow: receipt),\n     );\n  }\n  void _openAddTransactionScreen() {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => const AddTransactionScreen(),\n    );\n  }\n\n  void _openEditExpense(BuildContext context, Expense expense) {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => AddTransactionScreen(expenseToEdit: expense),\n    );\n  }\n\n  void _openEditReceipt(BuildContext context, Receipt receipt) {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => AddTransactionScreen(receiptToEdit: receipt),\n    );\n  }\n\n  void _confirmDeleteExpense(BuildContext context, Expense expense) {\n    showDialog(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: const Text('Confirmar exclusão'),\n          content: Text('Tem certeza de que deseja apagar a despesa \"${expense.title}\"?'),\n          actions: <Widget>[\n            TextButton(\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n              child: const Text('Cancelar'),\n            ),\n            TextButton(\n              onPressed: () async {\n                final financeState = Provider.of<FinanceState>(context, listen: false);\n                financeState.deleteExpense(expense.id!);\n                Navigator.of(context).pop();\n                ScaffoldMessenger.of(context).showSnackBar(\n                  const SnackBar(content: Text('Despesa apagada com sucesso!')),\n                );\n              },\n              child: const Text('Apagar'),\n            ),\n          ],\n        );\n      },\n    );\n  }\n\n  void _confirmDeleteReceipt(BuildContext context, Receipt receipt) {\n    showDialog(\n      context: context,\n      builder: (BuildContext context) {\n        return AlertDialog(\n          title: const Text('Confirmar exclusão'),\n          content: Text('Tem certeza de que deseja apagar a receita \"${receipt.title}\"?'),\n          actions: <Widget>[\n            TextButton(\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n              child: const Text('Cancelar'),\n            ),\n            TextButton(\n              onPressed: () async {\n                final financeState = Provider.of<FinanceState>(context, listen: false);\n                financeState.deleteReceipt(receipt.id!);\n                Navigator.of(context).pop();\n                ScaffoldMessenger.of(context).showSnackBar(\n                  const SnackBar(content: Text('Receita apagada com sucesso!')),\n                );\n              },\n              child: const Text('Apagar'),\n            ),\n          ],\n        );\n      },\n    );\n  }\n\n  void _showUserData(FinanceState state){\n    print(state.expenses.toString());\n    print(state.receipts);\n    print(state.shoppingListProducts);\n    print(state.productCategories);\n    print(state.expenseCategories);\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final financeState = Provider.of<FinanceState>(context);\n\n    final filteredExpenses = financeState.expenses.where((e) {\n      final expenseDate = e.date;\n      final inclusiveEndDate =\n          DateTime(_endDate.year, _endDate.month, _endDate.day, 23, 59, 59);\n      return !expenseDate.isBefore(_startDate) &&\n          !expenseDate.isAfter(inclusiveEndDate);\n    }).toList();\n\n    final filteredReceipts = financeState.receipts.where((r) {\n      final receiptDate = r.date;\n      final inclusiveEndDate =\n          DateTime(_endDate.year, _endDate.month, _endDate.day, 23, 59, 59);\n      return !receiptDate.isBefore(_startDate) &&\n          !receiptDate.isAfter(inclusiveEndDate);\n    }).toList();\n\n    final totalReceitasAtuais = filteredReceipts\n        .where((r) => !r.isFuture)\n        .fold(0.0, (sum, item) => sum + item.value);\n    final totalDespesasAtuais = filteredExpenses\n        .where((e) => !e.isFuture)\n        .fold(0.0, (sum, item) => sum + item.value);\n    final totalAReceber = filteredReceipts\n        .where((r) => r.isFuture)\n        .fold(0.0, (sum, item) => sum + item.value);\n    final totalAPagar = filteredExpenses\n        .where((e) => e.isFuture)\n        .fold(0.0, (sum, item) => sum + item.value);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('FamilyFinances'),\n        leading: const Icon(Icons.account_balance_wallet),\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            const SizedBox(height: 16),\n            _buildButtomsRow(context),\n            const SizedBox(height: 16),\n            IconButton(onPressed: () => _showUserData(financeState), icon: const Icon(Icons.info_outline)),\n            const SizedBox(height: 16),\n            Text(\n              'Saldo no período: R\\$ ${(totalReceitasAtuais - totalDespesasAtuais).toStringAsFixed(2)}',\n              style: const TextStyle(fontSize: 24, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            _buildDateFilter(context),\n            const SizedBox(height: 24),\n            Container(\n              padding: const EdgeInsets.all(5),\n              decoration: SectionStyle(),\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  _buildSectionTitle('Saldo Atual'),\n                  _buildBalanceSection(totalReceitasAtuais, totalDespesasAtuais),\n                  const SizedBox(height: 24),\n                ],\n              ),\n            ),\n            const SizedBox(height: 5,),\n            _buildFutureBalanceSection(totalAReceber, totalAPagar),\n            _buildSectionTitle('Despesas'),\n            ...filteredExpenses.map((expense) => _buildExpenseRow(context, expense)),\n            const Divider(height: 32),\n            _buildSectionTitle('Receitas'),\n            ...filteredReceipts.map((receipt) => _buildReceiptRow(context, receipt)),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          Navigator.push(context, MaterialPageRoute(\n            builder: (context) => const ShoppingListScreen(),\n          ));\n        },\n        backgroundColor: const Color(0xFF2A8782),\n        tooltip: 'Abrir lista de compras',\n        child: const Icon(Icons.shopping_cart, color: Colors.white),\n      ),\n    );\n  }\n\n  Widget _buildButtomsRow(BuildContext context){\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n      children: [\n        RowOption(title: \"Compras\", iconData: Icons.shopping_cart, onTap: () {\n          Navigator.push(\n            context,\n            MaterialPageRoute(builder: (context) => const ShoppingListScreen()),\n          );\n        }),\n        RowOption(\n  title: \"Importar NFC-e\",\n  iconData: Icons.qr_code_scanner,\n  onTap: () async {\n    final url = await Navigator.push<String>(\n      context,\n      MaterialPageRoute(builder: (context) =>  QRCodeScannerScreen()),\n    );\n\n    if (url != null && context.mounted) {\n\n      final Nfce data = await NfceService().fetchAndParseNfce(url);\n      print(data.items.toString());\n      print(data.totalValue.toString());\n      print(data.taxInfo.toString());\n      \n      final financeState = Provider.of<FinanceState>(context, listen: false);\n      financeState.addExpense( Expense(\n                      id: \"0000\",\n                      title: \"Compras NFC-e nº ${data.nfceKey}\",\n                      value: data.totalValue,\n                      category: ExpenseCategory(name: \"Compras\", icon: Icons.shopping_cart),\n                      note: data.items.map((item) => \"${item.name} - Qty: ${item.quantity}, Unit Price: R\\$ ${item.unitPrice.toStringAsFixed(2)}, Total: R\\$ ${item.totalPrice.toStringAsFixed(2)}\").join(\"\\n\"),\n                      date: DateTime.now(),\n                      isRecurrent: false,\n                      isInInstallments: false,\n      ));\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Nota nº ${data.nfceKey} importada com sucesso! Valor Total: R\\$ ${data.totalValue.toStringAsFixed(2)}')),\n      );\n        }\n  },\n),\n        ],\n    );\n  }\n\n  Widget _buildDateFilter(BuildContext context) {\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.spaceEvenly,\n      children: [\n        Text('Período: ', style: Theme.of(context).textTheme.titleMedium),\n        TextButton(\n          onPressed: () => _selectDateRange(context),\n          child: Text(\n            '${DateFormat('dd/MM/yy').format(_startDate)} - ${DateFormat('dd/MM/yy').format(_endDate)}',\n          ),\n        ),\n        IconButton(\n          icon: const Icon(Icons.calendar_today),\n          onPressed: () => _selectDateRange(context),\n          tooltip: 'Selecionar período',\n        ),\n      ],\n    );\n  }\n\n  Widget _buildBalanceSection(double receitas, double despesas) {\n    final receitasPercent =\n        (receitas + despesas == 0 ? 0 : (receitas / (receitas + despesas)) * 100).toDouble();\n    final despesasPercent =\n        (receitas + despesas == 0 ? 0 : (despesas / (receitas + despesas)) * 100).toDouble();\n    final saldo = receitas - despesas;\n    return Row(\n      mainAxisAlignment: MainAxisAlignment.spaceBetween,\n      children: [\n        Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            const Text('Receitas atuais', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),\n            Text('R\\$ ${receitas.toStringAsFixed(2)}',\n                style: const TextStyle(fontSize: 16, color: Colors.green)),\n            const SizedBox(height: 8),\n            const Text('Despesas atuais', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),\n            Text('R\\$ ${despesas.toStringAsFixed(2)}',\n                style: const TextStyle(fontSize: 16, color: Colors.red)),\n          ],\n        ),\n        SizedBox(\n          height: 80,\n          width: 80,\n          child: PieChart(\n            PieChartData(\n              sections: saldo >= 0 ? [\n                PieChartSectionData(\n                    color: Colors.green,\n                    value: receitasPercent,\n                    radius: 15,\n                    showTitle: false),\n                PieChartSectionData(\n                    color: Colors.red,\n                    value: despesasPercent,\n                    radius: 15,\n                    showTitle: false),\n              ] : [\n                PieChartSectionData(\n                    color: Colors.red[800],\n                    value: despesasPercent,\n                    radius: 15,\n                    showTitle: false),\n              ],\n              centerSpaceRadius: 25,\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildFutureBalanceSection(double aReceber, double aPagar) {\n    final total = aReceber + aPagar;\n    final aReceberPercent = (total == 0 ? 0 : (aReceber / total) * 100).toDouble();\n    final aPagarPercent = (total == 0 ? 0 : (aPagar / total) * 100).toDouble();\n    if (total == 0.0){\n      return Container();\n    }\n    return Container(\n      padding: const EdgeInsets.all(5),\n      decoration: SectionStyle(),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          _buildSectionTitle('A Receber / A Pagar'),\n          Row(\n            mainAxisAlignment: MainAxisAlignment.spaceBetween,\n            children: [\n              Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  const Text('A Receber', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),\n                  Text('R\\$ ${aReceber.toStringAsFixed(2)}',\n                      style: const TextStyle(fontSize: 16, color: Colors.green)),\n                  const SizedBox(height: 8),\n                  const Text('A Pagar', style: TextStyle(fontSize: 16, fontWeight: FontWeight.bold)),\n                  Text('R\\$ ${aPagar.toStringAsFixed(2)}',\n                      style: const TextStyle(fontSize: 16, color: Colors.red)),\n                ],\n              ),\n              SizedBox(\n                height: 80,\n                width: 80,\n                child: PieChart(\n                  PieChartData(\n                    sections: [\n                      PieChartSectionData(\n                          color: Colors.blue,\n                          value: aReceberPercent,\n                          radius: 15,\n                          showTitle: false),\n                      PieChartSectionData(\n                          color: Colors.orange,\n                          value: aPagarPercent,\n                          radius: 15,\n                          showTitle: false),\n                    ],\n                    centerSpaceRadius: 25,\n                  ),\n                ),\n              ),\n            ],\n          ),\n          const SizedBox(height: 24),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildSectionTitle(String title) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8.0),\n      child: Text(title,\n          style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.grey)),\n    );\n  }\n\n  Widget _buildExpenseRow(BuildContext context, Expense expense) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 4.0),\n      child: ListTile(\n        leading: Icon(expense.category.icon,\n            color: expense.isFuture ? Colors.orange : Colors.red),\n        title: Text(expense.title),\n        subtitle: Text(expense.isFuture\n            ? 'A pagar em ${DateFormat('dd/MM/yyyy').format(expense.date)}'\n            : DateFormat('dd/MM/yyyy').format(expense.date)),\n        trailing: Row(\n          crossAxisAlignment: CrossAxisAlignment.center,\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            Text('R\\$ ${expense.value.toStringAsFixed(2)}',\n                style: TextStyle(color: expense.isFuture ? Colors.orange : Colors.red)),\n\n                    IconButton(\n              icon: const Icon(Icons.visibility, color: AppColors.primary),\n              onPressed: () => _openExpenseDetails(expense),\n            ),\nIconButton(\n              icon: const Icon(Icons.edit, color: Colors.blue),\n              onPressed: () => _openEditExpense(context, expense),\n            ),\n            IconButton(\n              icon: const Icon(Icons.delete, color: Colors.red),\n              onPressed: () => _confirmDeleteExpense(context, expense),\n            ),\n\n            \n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildReceiptRow(BuildContext context, Receipt receipt) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 4.0),\n      child: ListTile(\n        leading: Icon(receipt.category.icon,\n            color: receipt.isFuture ? Colors.blue : Colors.green),\n        title: Text(receipt.title),\n        subtitle: Text(receipt.isFuture\n            ? 'A receber em ${DateFormat('dd/MM/yyyy').format(receipt.date)}'\n            : DateFormat('dd/MM/yyyy').format(receipt.date)),\n        trailing: Row(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            Text('R\\$ ${receipt.value.toStringAsFixed(2)}',\n                style: TextStyle(color: receipt.isFuture ? Colors.blue : Colors.green)),\n            IconButton(\n              icon: const Icon(Icons.edit, color: Colors.blue),\n              onPressed: () => _openEditReceipt(context, receipt),\n            ),\n            IconButton(\n              icon: const Icon(Icons.delete, color: Colors.red),\n              onPressed: () => _confirmDeleteReceipt(context, receipt),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}",
        "qr_code_scanner_screen.dart": "import 'package:mobile_scanner/mobile_scanner.dart';\nimport 'package:flutter/material.dart';\n\nclass QRCodeScannerScreen extends StatelessWidget {\n  const QRCodeScannerScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Ler QR Code da NFC-e')),\n      body: MobileScanner(\n        controller: MobileScannerController(\n          detectionSpeed: DetectionSpeed.noDuplicates, // Evita detecções repetidas\n          facing: CameraFacing.back,\n        ),\n        onDetect: (capture) {\n          final List<Barcode> barcodes = capture.barcodes;\n          if (barcodes.isNotEmpty) {\n            final String? url = barcodes.first.rawValue;\n            // Garante que o URL não é nulo e que o ecrã ainda está ativo\n            if (url != null && context.mounted) {\n              // Fecha o scanner e devolve o URL como resultado\n              Navigator.of(context).pop(url);\n            }\n          }\n        },\n      ),\n    );\n  }\n}",
        "receipts_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\nimport 'package:provider/provider.dart';\nimport 'package:family_finances/models/receipt_category.dart';\nimport '../models/finance_state.dart';\nimport '../models/receipt.dart';\n\nclass ReceiptsScreen extends StatefulWidget {\n  const ReceiptsScreen({super.key});\n\n  @override\n  State<ReceiptsScreen> createState() => _ReceiptsScreenState();\n}\n\nclass _ReceiptsScreenState extends State<ReceiptsScreen> {\n  final TextEditingController _titleController = TextEditingController();\n  final TextEditingController _valueController = TextEditingController();\n  DateTime _selectedDate = DateTime.now(); // NOVO\n\n  @override\n  Widget build(BuildContext context) {\n    const Color primaryColor = Color(0xFF2A8782);\n    final financeState = Provider.of<FinanceState>(context);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Receitas')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            Text(\n              'R\\$ ${financeState.totalReceitas.toStringAsFixed(2)}',\n              style: const TextStyle(fontSize: 36, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 24),\n            _buildTextField(label: 'Título', hint: 'Título da receita', controller: _titleController),\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Valor', hint: '0,00', controller: _valueController),\n            const SizedBox(height: 16),\n            _buildDatePicker(context), // NOVO\n            const Spacer(),\n            ElevatedButton(\n              onPressed: () {\n                if (_titleController.text.isNotEmpty &&\n                    _valueController.text.isNotEmpty) {\n                  final receipt = Receipt(\n                    title: _titleController.text,\n                    value: double.tryParse(_valueController.text.replaceAll(',', '.')) ?? 0,\n                    date: _selectedDate,\n                    category: ReceiptCategory(name: 'Outros', icon: Icons.category),\n                    isRecurrent: false,\n                  );\n                  Provider.of<FinanceState>(context, listen: false).addReceipt(receipt);\n                  _titleController.clear();\n                  _valueController.clear();\n                  setState(() {\n                    _selectedDate = DateTime.now();\n                  });\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(content: Text('Receita salva!')),\n                  );\n                }\n              },\n              style: ElevatedButton.styleFrom(\n                backgroundColor: primaryColor,\n                padding: const EdgeInsets.symmetric(vertical: 16),\n                shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(8),\n                ),\n              ),\n              child: const Text('Salvar', style: TextStyle(fontSize: 18, color: Colors.white)),\n            ),\n            const SizedBox(height: 24),\n            const Text('Receitas cadastradas', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.grey)),\n            const Divider(),\n            Expanded(\n              child: ListView(\n                children: financeState.receipts\n                    .map((item) => _buildReceiptItem(item.title, item.value.toStringAsFixed(2), item.date))\n                    .toList(),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildTextField({required String label, required String hint, required TextEditingController controller, int maxLines = 1}) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        TextField(\n          controller: controller,\n          maxLines: maxLines,\n          decoration: InputDecoration(\n            hintText: hint,\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n            enabledBorder: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildDatePicker(BuildContext context) {\n    return Row(\n      children: [\n        const Icon(Icons.calendar_today, size: 20),\n        const SizedBox(width: 8),\n        Text('Data: ${DateFormat('dd/MM/yyyy').format(_selectedDate)}'),\n        const SizedBox(width: 8),\n        TextButton(\n          onPressed: () async {\n            final picked = await showDatePicker(\n              context: context,\n              initialDate: _selectedDate,\n              firstDate: DateTime(2000),\n              lastDate: DateTime(2100),\n            );\n            if (picked != null) {\n              setState(() {\n                _selectedDate = picked;\n              });\n            }\n          },\n          child: const Text('Alterar'),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildReceiptItem(String title, String value, DateTime date) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 12.0),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: [\n          Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              Text(title, style: const TextStyle(fontSize: 16)),\n              Text(DateFormat('dd/MM/yyyy').format(date), style: const TextStyle(fontSize: 12, color: Colors.grey)),\n            ],\n          ),\n          Text('R\\$ $value', style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500)),\n        ],\n      ),\n    );\n  }\n}",
        "settings_screen.dart": "  import 'package:family_finances/models/partnership.dart';\n  import 'package:family_finances/models/product_category.dart';\n  import 'package:firebase_auth/firebase_auth.dart';\n  import 'package:flutter/material.dart';\n  import 'package:provider/provider.dart';\n  import 'dart:convert';\n  import 'dart:io';\n  import 'package:path_provider/path_provider.dart';\n  import 'package:file_picker/file_picker.dart';\n  import 'package:intl/intl.dart'; \n  import 'package:family_finances/screens/auth_gate.dart';\n  import '../models/finance_state.dart';\n  import '../models/expense.dart';\n  import '../models/receipt.dart';\n  import '../models/product.dart'; \n\n  class SettingsScreen extends StatelessWidget {\n    const SettingsScreen({super.key});\n\n    Future<void> _exportData(BuildContext context) async {\n      final state = Provider.of<FinanceState>(context, listen: false);\n      final userId = FirebaseAuth.instance.currentUser?.uid;\n      if (userId == null) {\n        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Erro: Usuário não logado.')));\n        return;\n      }\n\n      // Exporta apenas os dados privados e compartilhados (que já estão no state)\n      final data = {\n        'expenses': state.expenses.map((e) => e.toMapForFirestore()).toList(),\n        'receipts': state.receipts.map((r) => r.toMapForFirestore()).toList(),\n        'products': state.shoppingListProducts.map((p) => p.toMapForFirestore()).toList(),\n      };\n\n      final jsonStr = const JsonEncoder.withIndent('  ').convert(data);\n\n      try {\n        String fileName = 'family_finances_backup_${DateFormat('yyyyMMdd_HHmm').format(DateTime.now())}.json';\n        String? outputFile;\n\n        if (Platform.isAndroid || Platform.isIOS || Platform.isMacOS || Platform.isWindows || Platform.isLinux) {\n          outputFile = await FilePicker.platform.saveFile(\n            dialogTitle: 'Salvar backup como...',\n            fileName: fileName,\n            allowedExtensions: ['json'],\n            type: FileType.custom,\n          );\n        } else {\n            final directory = await getApplicationDocumentsDirectory();\n            outputFile = '${directory.path}/$fileName';\n        }\n\n\n        if (outputFile != null) {\n            final file = File(outputFile);\n            await file.writeAsString(jsonStr);\n            if(context.mounted) {\n              ScaffoldMessenger.of(context).showSnackBar(\n                SnackBar(content: Text('Backup salvo em: ${file.path}')),\n              );\n            }\n        } else {\n          if(context.mounted) {\n              ScaffoldMessenger.of(context).showSnackBar(\n                const SnackBar(content: Text('Exportação cancelada.')),\n              );\n          }\n        }\n      } catch (e) {\n          print(\"Erro ao exportar dados: $e\");\n          if(context.mounted){\n            ScaffoldMessenger.of(context).showSnackBar(\n              SnackBar(content: Text('Erro ao exportar dados: $e'), backgroundColor: Colors.red),\n            );\n          }\n      }\n    }\n\n    Future<void> _importData(BuildContext context) async {\n      final user = FirebaseAuth.instance.currentUser;\n      if (user == null) {\n        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Erro: Usuário não logado.')));\n        return;\n      }\n\n      final result = await FilePicker.platform.pickFiles(\n        type: FileType.custom,\n        allowedExtensions: ['json'],\n      );\n\n      if (result == null || result.files.single.path == null) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Nenhum arquivo selecionado')),\n        );\n        return;\n      }\n\n      final filePath = result.files.single.path!;\n      final file = File(filePath);\n\n      if (!await file.exists()) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Arquivo de importação não encontrado')),\n        );\n        return;\n      }\n\n      showDialog(\n        context: context,\n        barrierDismissible: false,\n        builder: (context) => const Center(child: CircularProgressIndicator()),\n      );\n\n      try {\n        final jsonStr = await file.readAsString();\n        final data = jsonDecode(jsonStr);\n        final state = Provider.of<FinanceState>(context, listen: false);\n\n        int importedExpenses = 0;\n        int importedReceipts = 0;\n        int importedProducts = 0;\n        int skippedExpenses = 0;\n        int skippedReceipts = 0;\n        int skippedProducts = 0;\n\n        if (data['expenses'] is List) {\n          for (var eMap in data['expenses']) {\n            if (eMap is Map<String, dynamic>) {\n              try {\n                final newExpense = Expense.fromMapFromFirestore(eMap..['id'] = null, '');\n                bool exists = state.expenses.any((existing) =>\n                  existing.title == newExpense.title &&\n                  existing.value == newExpense.value &&\n                  existing.date.isAtSameMomentAs(newExpense.date)\n                );\n                if (!exists) {\n                  await state.addExpense(newExpense);\n                  importedExpenses++;\n                } else {\n                  skippedExpenses++;\n                }\n              } catch (e) {\n                print(\"Erro ao importar despesa: $e - Dados: $eMap\");\n                skippedExpenses++;\n              }\n            }\n          }\n        }\n\n        if (data['receipts'] is List) {\n          for (var rMap in data['receipts']) {\n            if (rMap is Map<String, dynamic>) {\n              try {\n                  final newReceipt = Receipt.fromMapFromFirestore(rMap..['id'] = null, '');\n                  bool exists = state.receipts.any((existing) =>\n                    existing.title == newReceipt.title &&\n                    existing.value == newReceipt.value &&\n                    existing.date.isAtSameMomentAs(newReceipt.date)\n                  );\n                  if (!exists) {\n                    await state.addReceipt(newReceipt);\n                    importedReceipts++;\n                  } else {\n                    skippedReceipts++;\n                  }\n              } catch (e) {\n                  print(\"Erro ao importar receita: $e - Dados: $rMap\");\n                  skippedReceipts++;\n              }\n            }\n          }\n        }\n\n        if (data['products'] is List) {\n          for (var pMap in data['products']) {\n              if (pMap is Map<String, dynamic>) {\n                try {\n                  final categoryId = pMap['categoryId'] ?? ProductCategory.indefinida.id;\n                  final category = state.productCategories.firstWhere(\n                    (c) => c.id == categoryId, \n                    orElse: () => ProductCategory.indefinida\n                  );\n\n                  final newProduct = Product.fromMapFromFirestore(pMap..['id'] = null, '', category);\n\n                  bool exists = state.shoppingListProducts.any((existing) =>\n                    existing.nameLower == newProduct.nameLower\n                  );\n\n                  if (!exists) {\n                      await state.addProduct(newProduct);\n                      importedProducts++;\n                  } else {\n                    skippedProducts++;\n                  }\n                } catch (e) {\n                    print(\"Erro ao importar produto: $e - Dados: $pMap\");\n                    skippedProducts++;\n                }\n              }\n          }\n        }\n\n        Navigator.of(context).pop(); // Fecha o loading\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(\n            content: Text('Importação concluída: ${importedExpenses}E/${importedReceipts}R/${importedProducts}P novos. ${skippedExpenses}E/${skippedReceipts}R/${importedProducts}P ignorados (duplicados/erro).'),\n            duration: const Duration(seconds: 5),\n        ),\n        );\n      } catch (e) {\n          Navigator.of(context).pop(); // Fecha o loading\n          print(\"Erro crítico ao importar dados: $e\");\n          if(context.mounted) {\n            ScaffoldMessenger.of(context).showSnackBar(\n              SnackBar(content: Text('Erro ao ler ou processar o arquivo de backup: $e'), backgroundColor: Colors.red),\n            );\n          }\n      }\n    }\n\n    // NOVO: UI para enviar convite\n    void _showSendInviteDialog(BuildContext context) {\n      final TextEditingController emailController = TextEditingController();\n      showDialog(\n        context: context,\n        builder: (ctx) => AlertDialog(\n          title: const Text('Convidar Parceiro'),\n          content: TextField(\n            controller: emailController,\n            decoration: const InputDecoration(labelText: 'UID ou Email do Parceiro'),\n            keyboardType: TextInputType.emailAddress,\n          ),\n          actions: [\n            TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancelar')),\n            ElevatedButton(\n              onPressed: () async {\n                final partnerIdentifier = emailController.text.trim();\n                if (partnerIdentifier.isNotEmpty) {\n                  Navigator.of(ctx).pop(); // Fecha o diálogo\n                  try {\n                    // O parceiro pode inserir o UID ou o email (para simplificar o teste)\n                    await Provider.of<FinanceState>(context, listen: false).sendInvite(partnerIdentifier);\n                    ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Convite enviado!')));\n                  } catch (e) {\n                    ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erro ao enviar convite: ${e.toString()}'), backgroundColor: Colors.red));\n                  }\n                }\n              },\n              child: const Text('Enviar Convite'),\n            ),\n          ],\n        )\n      );\n    }\n\n    // NOVO: UI para aceitar convite\n    void _handleAcceptInvite(BuildContext context, PartnershipInvite invite) async {\n      showDialog(\n        context: context,\n        barrierDismissible: false,\n        builder: (ctx) => const Center(child: CircularProgressIndicator()),\n      );\n      try {\n        await Provider.of<FinanceState>(context, listen: false).acceptInvite(invite);\n        Navigator.of(context).pop();\n        ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Parceria estabelecida com sucesso!')));\n      } catch (e) {\n        Navigator.of(context).pop();\n        ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erro ao aceitar parceria: ${e.toString()}'), backgroundColor: Colors.red));\n      }\n    }\n\n    // NOVO: UI para remover parceria\n    void _confirmRemovePartnership(BuildContext context) {\n      final financeState = Provider.of<FinanceState>(context, listen: false);\n      showDialog(\n        context: context,\n        builder: (ctx) => AlertDialog(\n          title: const Text('Confirmar Remoção'),\n          content: const Text('Tem certeza que deseja terminar a parceria? As transações conjuntas não serão removidas do histórico de transações conjuntas.'),\n          actions: [\n            TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancelar')),\n            TextButton(\n              onPressed: () async {\n                Navigator.of(ctx).pop();\n                try {\n                  await financeState.removePartnership();\n                  ScaffoldMessenger.of(context).showSnackBar(const SnackBar(content: Text('Parceria terminada.')));\n                } catch (e) {\n                  ScaffoldMessenger.of(context).showSnackBar(SnackBar(content: Text('Erro ao terminar parceria: ${e.toString()}'), backgroundColor: Colors.red));\n                }\n              },\n              child: const Text('Terminar Parceria', style: TextStyle(color: Colors.red)),\n            ),\n          ],\n        )\n      );\n    }\n\n    @override\n    Widget build(BuildContext context) {\n      final financeState = Provider.of<FinanceState>(context);\n      final bool isLoggedIn = financeState.isLoggedIn;\n      final user = FirebaseAuth.instance.currentUser;\n      final String? currentPartnerId = financeState.currentPartnerId;\n      final List<PartnershipInvite> incomingInvites = financeState.incomingInvites;\n\n      return Scaffold(\n        appBar: AppBar(title: const Text('Configurações e Backup')),\n        body: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.stretch,\n            children: [\n              // --- Seção de Parceria ---\n              Text('Parceria de Contas (Compartilhamento)', style: Theme.of(context).textTheme.titleMedium),\n              const SizedBox(height: 8),\n\n              if (!isLoggedIn)\n                const Padding(\n                  padding: EdgeInsets.only(bottom: 16.0),\n                  child: Text('Faça login para gerenciar a parceria.', style: TextStyle(color: Colors.red)),\n                ),\n              \n              // Gerenciamento de Parceria\n              if (isLoggedIn) ...[\n                if (currentPartnerId != null) ...[\n                  // Parceria Ativa\n                  Card(\n                    color: Colors.lightGreen.shade50,\n                    margin: const EdgeInsets.only(bottom: 16),\n                    child: Padding(\n                      padding: const EdgeInsets.all(16.0),\n                      child: Column(\n                        crossAxisAlignment: CrossAxisAlignment.start,\n                        children: [\n                          const Text('Parceria Ativa:', style: TextStyle(fontWeight: FontWeight.bold)),\n                          // Exibe o UID do parceiro (aqui com substring para não poluir demais)\n                          Text('UID do Parceiro: ${currentPartnerId.length > 8 ? '${currentPartnerId.substring(0, 8)}...' : currentPartnerId}'),\n                          const SizedBox(height: 8),\n                          Text('Transações conjuntas salvas em: ${financeState.sharedCollectionId}', style: TextStyle(fontSize: 10, color: Colors.grey.shade700)),\n                          const SizedBox(height: 16),\n                          ElevatedButton.icon(\n                            icon: const Icon(Icons.close),\n                            label: const Text('Terminar Parceria'),\n                            onPressed: () => _confirmRemovePartnership(context),\n                            style: ElevatedButton.styleFrom(\n                              backgroundColor: Colors.red.shade400,\n                              foregroundColor: Colors.white,\n                            ),\n                          ),\n                        ],\n                      ),\n                    ),\n                  ),\n                ] else if (incomingInvites.isNotEmpty) ...[\n                  // Convites Pendentes\n                  // CORREÇÃO APLICADA AQUI: Removido o list wrapper desnecessário e o .expand/.toList()\n                  ...incomingInvites.map((invite) => Card(\n                    color: Colors.yellow.shade100,\n                    margin: const EdgeInsets.only(bottom: 8),\n                    child: ListTile(\n                      title: const Text('Convite de Parceria Recebido'),\n                      subtitle: Text('De: ${invite.senderId.length > 8 ? '${invite.senderId.substring(0, 8)}...' : invite.senderId}'),\n                      trailing: Row(\n                        mainAxisSize: MainAxisSize.min,\n                        children: [\n                          IconButton(\n                            icon: const Icon(Icons.check, color: Colors.green),\n                            onPressed: () => _handleAcceptInvite(context, invite),\n                          ),\n                            IconButton(\n                            icon: const Icon(Icons.close, color: Colors.red),\n                            onPressed: () => financeState.declineInvite(invite.id),\n                          ),\n                        ],\n                      ),\n                    ),\n                  )).toList(),\n                ] else ...[\n                  // Sem Parceria\n                  const Text('Você não tem uma parceria ativa.', style: TextStyle(fontStyle: FontStyle.italic, color: Colors.grey)),\n                  const SizedBox(height: 8),\n                  ElevatedButton.icon(\n                    icon: const Icon(Icons.person_add),\n                    label: const Text('Convidar Novo Parceiro'),\n                    onPressed: () => _showSendInviteDialog(context),\n                    style: ElevatedButton.styleFrom(\n                      backgroundColor: Theme.of(context).primaryColor,\n                      foregroundColor: Colors.white,\n                    ),\n                  ),\n                ],\n              ],\n\n              const SizedBox(height: 32),\n              // --- Seção de Backup ---\n              Text('Backup e Restauração', style: Theme.of(context).textTheme.titleMedium),\n              const SizedBox(height: 8),\n              \n              ElevatedButton.icon(\n                icon: const Icon(Icons.upload_file),\n                label: const Text('Exportar Backup (JSON)'),\n                onPressed: isLoggedIn ? () => _exportData(context) : null,\n                style: ElevatedButton.styleFrom(\n                  disabledBackgroundColor: Colors.grey.shade300,\n                ),\n              ),\n              const SizedBox(height: 16),\n              ElevatedButton.icon(\n                icon: const Icon(Icons.download),\n                label: const Text('Importar Backup (JSON)'),\n                onPressed: isLoggedIn ? () => _importData(context) : null,\n                style: ElevatedButton.styleFrom(\n                  disabledBackgroundColor: Colors.grey.shade300,\n                ),\n              ),\n              \n              const SizedBox(height: 32),\n              // --- Seção de Conta ---\n              Text('Conta', style: Theme.of(context).textTheme.titleMedium),\n              const SizedBox(height: 8),\n\n              if (isLoggedIn) ...[\n                Center(\n                  child: Padding(\n                    padding: const EdgeInsets.only(bottom: 8.0),\n                    child: Text(\n                      user?.email ?? 'Logado',\n                      style: Theme.of(context).textTheme.bodySmall,\n                    ),\n                  ),\n                ),\n                ElevatedButton.icon(\n                  icon: const Icon(Icons.logout),\n                  label: const Text('Sair da Conta'),\n                  onPressed: () async {\n                    showDialog(\n                      context: context,\n                      builder: (ctx) => AlertDialog(\n                        title: const Text('Confirmar Saída'),\n                        content: const Text('Tem certeza que deseja sair? Os seus dados locais serão apagados e os dados da nuvem serão carregados no próximo login.'),\n                        actions: [\n                          TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancelar')),\n                          TextButton(\n                            onPressed: () async {\n                              Navigator.of(ctx).pop();\n                              await FirebaseAuth.instance.signOut();\n                            },\n                            child: const Text('Sair', style: TextStyle(color: Colors.red)),\n                          ),\n                        ],\n                      )\n                    );\n                  },\n                  style: ElevatedButton.styleFrom(\n                    backgroundColor: Colors.redAccent,\n                    foregroundColor: Colors.white,\n                  ),\n                ),\n              ] else ...[\n                Center(\n                  child: Padding(\n                    padding: const EdgeInsets.only(bottom: 8.0),\n                    child: Text(\n                      'Você está em modo local (convidado).',\n                      style: Theme.of(context).textTheme.bodySmall,\n                    ),\n                  ),\n                ),\n                ElevatedButton.icon(\n                  icon: const Icon(Icons.login),\n                  label: const Text('Fazer Login ou Registar'),\n                  onPressed: () {\n                    Navigator.of(context).pushAndRemoveUntil(\n                      MaterialPageRoute(builder: (context) => const AuthGate()),\n                      (route) => false,\n                    );\n                  },\n                  style: ElevatedButton.styleFrom(\n                    backgroundColor: Theme.of(context).primaryColor,\n                    foregroundColor: Colors.white,\n                  ),\n                ),\n              ],\n\n              const SizedBox(height: 32),\n              //),\n              const Center(child: Text('Versão 1.0.0 (híbrida)')),\n            ],\n          ),\n        ),\n      );\n    }\n  }",
        "shopping_list_screen.dart": "import 'package:family_finances/models/product_category.dart';\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport '../models/finance_state.dart';\nimport '../models/product.dart'; // Importa o novo modelo Product\nimport '../models/product_option.dart'; // Importa ProductOption\nimport 'package:cloud_firestore/cloud_firestore.dart'; // Para Timestamp\nimport 'package:intl/intl.dart'; // Para formatar data\n\nclass ShoppingListScreen extends StatefulWidget {\n  const ShoppingListScreen({super.key});\n\n  @override\n  State<ShoppingListScreen> createState() => _ShoppingListScreenState();\n}\n\nclass _ShoppingListScreenState extends State<ShoppingListScreen> {\n\n  @override\n  Widget build(BuildContext context) {\n    // Ouve as mudanças na lista de produtos do FinanceState\n    // Usando o getter correto que adicionaremos ao FinanceState\n    final products = Provider.of<FinanceState>(context).shoppingListProducts;\n    const Color primaryColor = Color(0xFF2A8782); // Cor primária definida\n\n    // Ordena os produtos alfabeticamente pelo nome para exibição\n    products.sort((a, b) => a.nameLower.compareTo(b.nameLower));\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Produtos / Lista de Compras')),\n      body: products.isEmpty\n        ? const Center(\n            child: Padding(\n              padding: EdgeInsets.all(20.0),\n              child: Text(\n                'Nenhum produto cadastrado ainda.\\nClique no botão + para adicionar.',\n                textAlign: TextAlign.center,\n                style: TextStyle(fontSize: 16, color: Colors.grey),\n              ),\n            ),\n          )\n        : ListView.builder(\n            padding: const EdgeInsets.only(left: 8.0, right: 8.0, top: 8.0, bottom: 80.0), // Padding inferior para FAB\n            itemCount: products.length,\n            itemBuilder: (context, index) {\n              final product = products[index];\n              return _buildProductItem(context, product);\n            },\n          ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: () {\n          Navigator.push(context, MaterialPageRoute(\n            builder: (context) => const AddProductScreen(), // Navega para a nova tela de adicionar produto\n          ));\n        },\n        backgroundColor: primaryColor,\n        tooltip: 'Adicionar Novo Produto', // Tooltip para acessibilidade\n        child: const Icon(Icons.add, color: Colors.white),\n      ),\n    );\n  }\n\n  // Widget para construir cada item da lista de produtos\n  Widget _buildProductItem(BuildContext context, Product product) {\n    final financeState = Provider.of<FinanceState>(context, listen: false);\n    // Pega a opção de compra mais recente (primeira da lista ordenada)\n    final latestOption = product.options.isNotEmpty ? product.options.first : null;\n\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 4.0),\n      child: Card( // Usa Card para destacar cada item\n        elevation: 2,\n        child: ExpansionTile(\n          key: ValueKey(product.id), // Chave única para o item\n          leading: Checkbox(\n            value: product.isChecked, // Estado do checkbox (para lista de compras)\n            onChanged: (bool? value) {\n              if (product.id != null) {\n                // Atualiza o estado 'checked' no Firebase via FinanceState\n                financeState.toggleProductChecked(product, value ?? false);\n              }\n            },\n            activeColor: const Color(0xFF2A8782), // Cor do checkbox\n          ),\n          // Título com nome e categoria\n          title: Row(\n            children: [\n              Icon(product.category.icon, size: 18, color: Colors.grey[700]),\n              const SizedBox(width: 8),\n              Expanded(child: Text(product.name, style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500))),\n            ],\n          ),\n          // Subtítulo com informações da última compra\n          subtitle: latestOption != null\n            ? Text(\n                'Última: ${latestOption.storeName} - R\\$ ${latestOption.price.toStringAsFixed(2)} (${latestOption.quantity}) em ${DateFormat('dd/MM/yy').format(latestOption.purchaseDate.toDate())}',\n                style: const TextStyle(fontSize: 12, color: Colors.grey)\n              )\n            : const Text('Nenhuma compra registrada', style: TextStyle(fontSize: 12, color: Colors.grey, fontStyle: FontStyle.italic)),\n          childrenPadding: const EdgeInsets.symmetric(horizontal: 16.0, vertical: 8.0), // Padding interno\n          children: [\n            // Mostra o histórico das últimas opções/compras\n             Column(\n               crossAxisAlignment: CrossAxisAlignment.start,\n               children: [\n                 const Text('Histórico Recente:', style: TextStyle(fontWeight: FontWeight.bold, color: Colors.black54)),\n                 const Divider(height: 8),\n                 if (product.options.isEmpty)\n                    const Text('Nenhum histórico de compra.', style: TextStyle(fontStyle: FontStyle.italic, color: Colors.grey)),\n                 // Mostra as 3 últimas compras em ListTiles\n                 ...product.options.take(3).map((opt) => ListTile(\n                      dense: true, // Torna o ListTile mais compacto\n                       contentPadding: EdgeInsets.zero, // Remove padding padrão\n                       title: Text('${opt.storeName} - ${opt.brand}', style: const TextStyle(fontSize: 13)),\n                       subtitle: Text('Qtd: ${opt.quantity} - Data: ${DateFormat('dd/MM/yy HH:mm').format(opt.purchaseDate.toDate())}', style: const TextStyle(fontSize: 11)), // Mostra data e hora\n                       trailing: Text('R\\$ ${opt.price.toStringAsFixed(2)}', style: const TextStyle(fontSize: 13, fontWeight: FontWeight.w500)),\n                     )),\n                  if (product.options.length > 3)\n                     Padding(\n                       padding: const EdgeInsets.only(top: 4.0),\n                       child: Text('... (ver histórico completo no botão editar)', style: TextStyle(fontSize: 10, color: Colors.grey[600])),\n                     ),\n               ],\n             ),\n            // Botões de Ação alinhados à direita\n            Row(\n              mainAxisAlignment: MainAxisAlignment.end,\n              children: [\n                TextButton.icon(\n                  icon: const Icon(Icons.edit, size: 18), // Ícone menor\n                  label: const Text('Editar/Histórico'),\n                  style: TextButton.styleFrom(padding: const EdgeInsets.symmetric(horizontal: 8)), // Menos padding\n                  onPressed: () {\n                    // Navega para a tela de edição, passando o produto\n                    Navigator.push(context, MaterialPageRoute(\n                      builder: (context) => AddProductScreen(editProduct: product),\n                    ));\n                  },\n                ),\n                IconButton(\n                  icon: const Icon(Icons.delete, color: Colors.redAccent, size: 20),\n                  tooltip: 'Apagar Produto',\n                  onPressed: () {\n                    // Confirmação antes de apagar\n                    showDialog(\n                        context: context,\n                        builder: (ctx) => AlertDialog(\n                          title: const Text('Confirmar Exclusão'),\n                          content: Text('Tem certeza que deseja apagar o produto \"${product.name}\" e todo o seu histórico de compras? Esta ação não pode ser desfeita.'),\n                          actions: [\n                            TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancelar')),\n                            TextButton(\n                              onPressed: () {\n                                 if (product.id != null) {\n                                  // Chama o método deleteProduct no FinanceState\n                                  financeState.deleteProduct(product.id!);\n                                }\n                                Navigator.of(ctx).pop(); // Fecha o diálogo\n                                // Mostra confirmação\n                                if(context.mounted) {\n                                   ScaffoldMessenger.of(context).showSnackBar(\n                                    SnackBar(content: Text('Produto \"${product.name}\" apagado.'))\n                                  );\n                                }\n                              },\n                               child: const Text('Apagar', style: TextStyle(color: Colors.red)),\n                            ),\n                          ],\n                        ));\n                  },\n                ),\n              ],\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n\n// --- Nova Tela para Adicionar/Editar Produto ---\n// (Esta tela foi movida para seu próprio arquivo ou mantida aqui por conveniência)\nclass AddProductScreen extends StatefulWidget {\n  final Product? editProduct; // Recebe um produto existente para edição\n\n  const AddProductScreen({super.key, this.editProduct});\n\n  @override\n  State<AddProductScreen> createState() => _AddProductScreenState();\n}\n\nclass _AddProductScreenState extends State<AddProductScreen> {\n  final _formKey = GlobalKey<FormState>(); // Chave para validação do formulário\n  late TextEditingController _nameController;\n  late ProductCategory _selectedCategory;\n  late List<ProductOption> _options; // Mantém as opções existentes/novas\n\n  // Controllers para adicionar NOVA opção\n  final TextEditingController _brandController = TextEditingController();\n  final TextEditingController _storeController = TextEditingController();\n  final TextEditingController _priceController = TextEditingController();\n  final TextEditingController _quantityController = TextEditingController();\n  final List<String> _units = ['un','g', 'kg',  'ml', 'L', 'cx', 'pct', 'dz', 'm', 'cm']; // Unidades\n  String _selectedUnit = 'un'; // Unidade padrão\n\n  // Carrega as categorias disponíveis (idealmente viriam do Firestore ou config)\n  final List<ProductCategory> _availableCategories = [\n    ProductCategory.indefinida, // Garante que 'Indefinida' esteja sempre disponível\n    ProductCategory.alimentacao,\n    ProductCategory.casa,\n    ProductCategory(id: 'hygiene', name: 'Higiene', icon: Icons.clean_hands),\n    ProductCategory(id: 'pets', name: 'Pets', icon: Icons.pets),\n    ProductCategory(id: 'transport', name: 'Transporte', icon: Icons.directions_car),\n    ProductCategory(id: 'health', name: 'Saúde', icon: Icons.local_hospital),\n    ProductCategory(id: 'leisure', name: 'Lazer', icon: Icons.sports_esports),\n    ProductCategory(id: 'clothes', name: 'Vestuário', icon: Icons.checkroom),\n    ProductCategory(id: 'others', name: 'Outros', icon: Icons.more_horiz),\n    // Adicionar outras categorias aqui\n  ];\n\n  @override\n  void initState() {\n    super.initState();\n    _nameController = TextEditingController(text: widget.editProduct?.name ?? '');\n    // Seleciona a categoria existente ou a indefinida como padrão\n    _selectedCategory = _findCategoryById(widget.editProduct?.category.id ?? ProductCategory.indefinida.id);\n    _options = widget.editProduct != null\n        ? List<ProductOption>.from(widget.editProduct!.options) // Copia as opções existentes\n        : [];\n     // Ordena as opções existentes pela data mais recente\n     _options.sort((a, b) => b.purchaseDate.compareTo(a.purchaseDate));\n  }\n\n  // Função auxiliar para encontrar a categoria na lista _availableCategories pelo ID\n  ProductCategory _findCategoryById(String id) {\n    return _availableCategories.firstWhere((cat) => cat.id == id, orElse: () => ProductCategory.indefinida);\n  }\n\n  // Adiciona uma nova opção de compra à lista temporária _options\n  void _addOption() {\n    // Valida os campos antes de adicionar\n    final priceString = _priceController.text.replaceAll(',', '.');\n    final quantityString = _quantityController.text.replaceAll(',', '.');\n    final price = double.tryParse(priceString);\n    final quantityValue = double.tryParse(quantityString);\n\n    if (_brandController.text.trim().isEmpty) {\n      _showErrorSnackbar('O campo \"Marca\" não pode estar vazio.');\n      return;\n    }\n     if (_storeController.text.trim().isEmpty) {\n      _showErrorSnackbar('O campo \"Loja\" não pode estar vazio.');\n      return;\n    }\n     if (quantityValue == null || quantityValue <= 0) {\n       _showErrorSnackbar('A quantidade deve ser um número maior que zero.');\n       return;\n     }\n      if (price == null || price <= 0) {\n      _showErrorSnackbar('O preço deve ser um número maior que zero.');\n      return;\n    }\n\n\n    setState(() {\n      _options.insert(0, // Insere no início para mostrar a mais recente primeiro\n        ProductOption(\n          brand: _brandController.text.trim(),\n          storeName: _storeController.text.trim(),\n          price: price,\n          quantity: '$quantityString $_selectedUnit', // Usa o valor parseado para garantir formato\n          purchaseDate: Timestamp.now(), // Data da adição da opção\n        )\n      );\n      // Limpa os campos após adicionar\n      _brandController.clear();\n      _storeController.clear();\n      _priceController.clear();\n      _quantityController.clear();\n      _selectedUnit = _units[0]; // Reseta a unidade\n      FocusScope.of(context).unfocus(); // Esconde o teclado\n    });\n  }\n\n   // Remove uma opção da lista temporária _options\n  void _removeOption(int index) {\n    setState(() {\n      _options.removeAt(index);\n    });\n  }\n\n  // Salva o produto (novo ou editado) no Firestore\n  void _saveProduct() {\n     // Valida o formulário principal (Nome e Categoria)\n     if (!(_formKey.currentState?.validate() ?? false)) {\n        return; // Não salva se o formulário for inválido\n     }\n\n      final financeState = Provider.of<FinanceState>(context, listen: false);\n      final product = Product(\n        id: widget.editProduct?.id, // Mantém o ID se estiver editando\n        name: _nameController.text.trim(),\n        category: _selectedCategory,\n        options: _options, // Usa a lista de opções atualizada\n        isChecked: widget.editProduct?.isChecked ?? false, // Mantém o estado 'checked'\n        priority: widget.editProduct?.priority, // Mantém a prioridade se já existir\n      );\n\n      // Ordena as opções antes de salvar (garante a ordem no Firestore)\n      product.options.sort((a, b) => b.purchaseDate.compareTo(a.purchaseDate));\n\n      // Mostra loading\n      showDialog(\n          context: context,\n          barrierDismissible: false,\n          builder: (context) => const Center(child: CircularProgressIndicator()),\n      );\n\n      // Chama o método apropriado no FinanceState (add ou update)\n      Future<void> saveFuture = widget.editProduct != null\n          ? financeState.updateProduct(product)\n          : financeState.addProduct(product);\n\n      saveFuture.then((_) {\n            Navigator.of(context).pop(); // Fecha o loading\n            Navigator.of(context).pop(); // Fecha a tela de Add/Edit\n            ScaffoldMessenger.of(context).showSnackBar(\n              SnackBar(content: Text(widget.editProduct == null ? 'Produto adicionado!' : 'Produto atualizado!'), backgroundColor: Colors.green)\n            );\n        }).catchError((e){\n             Navigator.of(context).pop(); // Fecha o loading\n             print(\"Erro ao salvar produto: $e\");\n             ScaffoldMessenger.of(context).showSnackBar(\n               SnackBar(content: Text('Erro ao salvar: ${e.toString()}'), backgroundColor: Colors.red)\n             );\n        });\n  }\n\n  // Função auxiliar para mostrar SnackBar de erro\n  void _showErrorSnackbar(String message) {\n     ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text(message), backgroundColor: Colors.orange[800])\n     );\n  }\n\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: Text(widget.editProduct == null ? 'Adicionar Produto' : 'Editar Produto')),\n      body: Form( // Envolve com um Form para validação\n         key: _formKey,\n        child: Padding(\n          padding: const EdgeInsets.all(16.0),\n          child: Column(\n            crossAxisAlignment: CrossAxisAlignment.stretch,\n            children: [\n              // Nome do Produto (só editável se for novo)\n              TextFormField( // Usa TextFormField para validação\n                controller: _nameController,\n                decoration: InputDecoration(\n                  labelText: 'Nome do Produto*',\n                   // Mostra o nome antigo se estiver editando e desabilitado\n                  hintText: widget.editProduct != null ? 'Nome original: ${widget.editProduct!.name}' : null,\n                ),\n                enabled: widget.editProduct == null, // Desabilita edição do nome se já existe\n                textCapitalization: TextCapitalization.words,\n                validator: (value) { // Validação simples de nome não vazio\n                  if (value == null || value.trim().isEmpty) {\n                    return 'Por favor, insira o nome do produto.';\n                  }\n                  return null;\n                },\n              ),\n              const SizedBox(height: 16),\n\n              // Seleção de Categoria\n              DropdownButtonFormField<ProductCategory>(\n                initialValue: _selectedCategory,\n                items: _availableCategories.map((cat) => DropdownMenuItem(\n                  value: cat,\n                  child: Row(children: [Icon(cat.icon, size: 20, color: Colors.grey[700]), const SizedBox(width: 8), Text(cat.name)]),\n                )).toList(),\n                onChanged: (cat) {\n                  if (cat != null) {\n                    setState(() => _selectedCategory = cat);\n                  }\n                },\n                decoration: const InputDecoration(labelText: 'Categoria*', border: OutlineInputBorder()),\n                 validator: (value) { // Validação da categoria\n                  if (value == null || value.id == ProductCategory.indefinida.id) {\n                    return 'Por favor, selecione uma categoria válida.';\n                  }\n                  return null;\n                },\n              ),\n              const SizedBox(height: 24),\n\n              // Seção para Adicionar Nova Opção de Compra\n              Text('Adicionar Nova Opção/Compra', style: Theme.of(context).textTheme.titleMedium),\n              Card(\n                elevation: 1,\n                margin: const EdgeInsets.symmetric(vertical: 8),\n                child: Padding(\n                  padding: const EdgeInsets.all(12.0),\n                  child: Column(\n                    children: [\n                       Row(\n                        children: [\n                          Expanded(child: TextField(controller: _brandController, decoration: const InputDecoration(labelText: 'Marca*'), textCapitalization: TextCapitalization.words,)),\n                          const SizedBox(width: 8),\n                          Expanded(child: TextField(controller: _storeController, decoration: const InputDecoration(labelText: 'Loja*'), textCapitalization: TextCapitalization.words,)),\n                        ],\n                      ),\n                      const SizedBox(height: 8),\n                      Row(\n                        crossAxisAlignment: CrossAxisAlignment.end, // Alinha itens na base\n                        children: [\n                          Expanded(\n                            flex: 3, // Mais espaço para quantidade\n                            child: TextField(\n                               controller: _quantityController,\n                               decoration: const InputDecoration(labelText: 'Qtd*', hintText: 'Ex: 500'),\n                               keyboardType: const TextInputType.numberWithOptions(decimal: true), // Permite decimal\n                             ),\n                          ),\n                          const SizedBox(width: 8),\n                          // Dropdown de Unidades\n                          DropdownButton<String>(\n                              value: _selectedUnit,\n                              items: _units.map((u) => DropdownMenuItem(value: u, child: Text(u))).toList(),\n                              onChanged: (value) {\n                                if(value != null) setState(() => _selectedUnit = value);\n                              },\n                               underline: Container(), // Remove linha padrão\n                               style: Theme.of(context).textTheme.bodyLarge,\n                            ),\n                           const SizedBox(width: 8),\n                          Expanded(\n                            flex: 2, // Menos espaço para preço\n                            child: TextField(\n                               controller: _priceController,\n                               decoration: const InputDecoration(labelText: 'Preço*', prefixText: 'R\\$ '),\n                               keyboardType: const TextInputType.numberWithOptions(decimal: true),\n                             ),\n                          ),\n                          // Botão Adicionar Opção\n                          IconButton(\n                            icon: Icon(Icons.add_circle, color: Theme.of(context).primaryColor, size: 28),\n                            tooltip: 'Adicionar esta opção de compra',\n                            onPressed: _addOption,\n                          ),\n                        ],\n                      ),\n                    ],\n                  ),\n                ),\n              ),\n               const SizedBox(height: 16),\n\n              // Lista de Opções Adicionadas/Existentes\n              Text('Histórico de Compras (${_options.length}):', style: Theme.of(context).textTheme.titleMedium),\n              Expanded(\n                child: _options.isEmpty\n                  ? Center(child: Text(widget.editProduct == null ? 'Nenhuma opção adicionada ainda.' : 'Nenhum histórico de compra registrado.'))\n                  : ListView.builder(\n                      itemCount: _options.length,\n                      itemBuilder: (context, index) {\n                        // A lista _options já está ordenada por data descendente\n                        final opt = _options[index];\n                        return Card(\n                           margin: const EdgeInsets.symmetric(vertical: 4),\n                           child: ListTile(\n                            dense: true,\n                            title: Text('${opt.brand} - ${opt.storeName}', style: const TextStyle(fontSize: 14)),\n                            subtitle: Text('Qtd: ${opt.quantity} - Data: ${DateFormat('dd/MM/yy HH:mm').format(opt.purchaseDate.toDate())}', style: const TextStyle(fontSize: 12)),\n                            trailing: Row(\n                              mainAxisSize: MainAxisSize.min,\n                              children: [\n                                Text('R\\$ ${opt.price.toStringAsFixed(2)}', style: const TextStyle(fontWeight: FontWeight.w500)),\n                                 IconButton(\n                                  icon: const Icon(Icons.remove_circle_outline, color: Colors.redAccent, size: 20),\n                                  tooltip: 'Remover esta compra do histórico',\n                                  // Confirmação antes de remover opção\n                                  onPressed: () => showDialog(\n                                    context: context,\n                                    builder: (ctx) => AlertDialog(\n                                      title: const Text('Remover Compra'),\n                                      content: const Text('Tem certeza que deseja remover esta entrada do histórico?'),\n                                      actions: [\n                                         TextButton(onPressed: () => Navigator.of(ctx).pop(), child: const Text('Cancelar')),\n                                         TextButton(onPressed: (){\n                                           _removeOption(index); // Remove da lista temporária\n                                            Navigator.of(ctx).pop();\n                                         }, child: const Text('Remover', style: TextStyle(color: Colors.red)))\n                                      ],\n                                    )\n                                  ),\n                                ),\n                              ],\n                            ),\n                          ),\n                        );\n                      },\n                    ),\n              ),\n              const SizedBox(height: 16),\n\n              // Botão Salvar\n              ElevatedButton(\n                onPressed: _saveProduct,\n                style: ElevatedButton.styleFrom(\n                   backgroundColor: Theme.of(context).primaryColor,\n                   foregroundColor: Colors.white,\n                   padding: const EdgeInsets.symmetric(vertical: 12)\n                ),\n                child: Text(widget.editProduct == null ? 'Salvar Novo Produto' : 'Salvar Alterações'),\n              ),\n            ],\n          ),\n        ),\n      ),\n    );\n  }\n}\n\n",
        "transaction_detail_screen.dart": "\nimport 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\n\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\n\nenum RecurrencyType { monthly, weekly, custom }\n\nclass TransactionDetailScreen extends StatefulWidget {\n  final Expense? expenseToShow;\n  final Receipt? receiptToShow;\n\n  const TransactionDetailScreen({super.key, this.expenseToShow, this.receiptToShow});\n\n  @override\n  State<TransactionDetailScreen> createState() => _TransactionDetailScreenState();\n}\n\nclass _TransactionDetailScreenState extends State<TransactionDetailScreen> {\n  \n\n  @override\n  void initState() {\n    super.initState();\n   \n  }\n\n  @override\n  Widget build(BuildContext context) {\n\n    return Padding(\n      padding: EdgeInsets.only(\n        bottom: MediaQuery.of(context).viewInsets.bottom,\n        left: 16,\n        right: 16,\n        top: 24,\n      ),\n      child: SingleChildScrollView(\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            if (widget.expenseToShow != null) ...[\n              _buildDetailRow('Tipo:', 'Despesa'),\n              _buildDetailRow('Título:', widget.expenseToShow!.title),\n              _buildDetailRow('Valor:', 'R\\$ ${widget.expenseToShow!.value.toStringAsFixed(2)}'),\n              _buildDetailRow('Data:', DateFormat('dd/MM/yyyy').format(widget.expenseToShow!.date)),\n              _buildDetailRow('Categoria:', widget.expenseToShow!.category.name),\n              if (widget.expenseToShow!.note.isNotEmpty)\n                _buildDetailRow('Nota:', widget.expenseToShow!.note),\n              //_buildDetailRow('Recorrente:', widget.expenseToShow!.isRecurrent ? 'Sim' : 'Não'),\n              if (widget.expenseToShow!.isRecurrent)\n                _buildDetailRow('Tipo de Recorrência:', RecurrencyType.values[widget.expenseToShow!.recurrencyType!].toString().split('.').last),\n              //_buildDetailRow('Parcelado:', widget.expenseToShow!.isInInstallments ? 'Sim' : 'Não'),\n              if (widget.expenseToShow!.isInInstallments)\n                _buildDetailRow('Parcelas:', widget.expenseToShow!.installmentCount.toString()),\n            ] else if (widget.receiptToShow != null) ...[\n              _buildDetailRow('Tipo:', 'Receita'),\n              _buildDetailRow('Título:', widget.receiptToShow!.title),\n              _buildDetailRow('Valor:', 'R\\$ ${widget.receiptToShow!.value.toStringAsFixed(2)}'),\n              _buildDetailRow('Data:', DateFormat('dd/MM/yyyy').format(widget.receiptToShow!.date)),\n              _buildDetailRow('Categoria:', widget.receiptToShow!.category.name),\n              //_buildDetailRow('Recorrente:', widget.receiptToShow!.isRecurrent ? 'Sim' : 'Não'),\n              // Adicione mais detalhes da receita conforme necessário\n            ] else ...[\n              const Text('Nenhum detalhe de transação para exibir.', style: TextStyle(fontSize: 16)),\n            ],\n            const SizedBox(height: 24),\n            ElevatedButton(\n              onPressed: () {\n                Navigator.of(context).pop();\n              },\n              style: ElevatedButton.styleFrom(\n                backgroundColor: Theme.of(context).primaryColor,\n                padding: const EdgeInsets.symmetric(vertical: 16),\n                shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(8),\n                ),\n              ),\n              child: const Text('Fechar', style: TextStyle(fontSize: 18, color: Colors.white)),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildDetailRow(String label, String value) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 8.0),\n      child: Row(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Text(\n            label,\n            style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16),\n          ),\n          const SizedBox(width: 8),\n          Expanded(\n            child: Text(\n              value,\n              style: const TextStyle(fontSize: 16),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}"
    },
    "services": {
        "firestore_service.dart": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:family_finances/models/partnership.dart';\nimport 'package:family_finances/models/product_category.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\nimport '../models/product.dart';\n// Importa o novo modelo\n\n// Constantes para o caminho da coleção pública compartilhada\nconst String PUBLIC_TRANSACTIONS_PATH = 'shared_transactions';\nconst String PARTNERSHIPS_COLLECTION = 'partnerships';\nconst String PARTNERSHIP_INVITES_COLLECTION = 'partnership_invites';\n\nclass FirestoreService {\n  final String uid;\n  FirestoreService({required this.uid});\n\n  // Coleção principal do utilizador\n  CollectionReference get _usersCollection =>\n      FirebaseFirestore.instance.collection('users');\n\n  // Sub-coleções para cada tipo de dado\n  CollectionReference get _expensesCollection =>\n      _usersCollection.doc(uid).collection('expenses');\n  CollectionReference get _receiptsCollection =>\n      _usersCollection.doc(uid).collection('receipts');\n  \n  // Nova coleção para Produtos\n  CollectionReference get _productsCollection =>\n      _usersCollection.doc(uid).collection('products');\n  \n  // Nova coleção para Categorias de Produto\n  CollectionReference get _productCategoriesCollection =>\n      _usersCollection.doc(uid).collection('productCategories');\n      \n  // Coleção de Parcerias na raiz (pública)\n  CollectionReference get partnershipsCollection =>\n      FirebaseFirestore.instance.collection(PARTNERSHIPS_COLLECTION);\n  \n  // Coleção de Convites de Parceria (pública)\n  CollectionReference get partnershipInvitesCollection =>\n      FirebaseFirestore.instance.collection(PARTNERSHIP_INVITES_COLLECTION);\n      \n  // --- Métodos de Parceria ---\n\n  /// Envia um convite de parceria para outro usuário (UID, que pode ser simulado por email no teste).\n  Future<void> sendPartnershipInvite(String receiverUidOrEmail) async {\n    // Usaremos o UID (ou email no teste) do recebedor como ID de convite temporário.\n    final inviteId = Partnership.createId(uid, receiverUidOrEmail); \n\n    final invite = PartnershipInvite(\n      id: inviteId,\n      senderId: uid,\n      receiverId: receiverUidOrEmail, // Aqui, para simplificar, o receiverId é o UID/Email\n      sentAt: Timestamp.now(),\n    );\n\n    // Salva o convite\n    await partnershipInvitesCollection.doc(inviteId).set(invite.toMap());\n  }\n  \n  /// Busca a parceria atual do usuário.\n  /// Retorna a Parceria ou null se não houver.\n  // NOTE: A busca real por parceria é feita no FinanceState usando Rx.combineLatest2.\n  Stream<Partnership?> getPartnershipStream() {\n    // Retorna um stream base para um dos lados da busca.\n    return partnershipsCollection\n        .where('user1Id', isEqualTo: uid)\n        .snapshots()\n        .map((snapshot) {\n          if (snapshot.docs.isNotEmpty) {\n            return Partnership.fromMap(snapshot.docs.first.data() as Map<String, dynamic>, snapshot.docs.first.id);\n          }\n          return null;\n        });\n  }\n\n  /// Cria ou aceita uma parceria.\n  Future<Partnership> establishPartnership(String partnerUid) async {\n    final partnershipId = Partnership.createId(uid, partnerUid);\n    \n    // O ID da coleção compartilhada será o ID da Partnership\n    final sharedCollectionId = partnershipId; \n\n    final partnership = Partnership(\n      id: partnershipId,\n      user1Id: Partnership.createId(uid, partnerUid) == uid ? uid : partnerUid,\n      user2Id: Partnership.createId(uid, partnerUid) == uid ? partnerUid : uid,\n      sharedCollectionId: sharedCollectionId,\n    );\n\n    await partnershipsCollection.doc(partnershipId).set(partnership.toMap());\n    \n    // Remove o convite após estabelecer a parceria (se existir)\n    try {\n        final inviteId = Partnership.createId(uid, partnerUid);\n        await partnershipInvitesCollection.doc(inviteId).delete();\n    } catch (_) {\n        // Ignora se o convite não existir\n    }\n\n    return partnership;\n  }\n  \n  /// Termina a parceria.\n  Future<void> removePartnership(String partnershipId) async {\n    // Deleta o documento da parceria\n    await partnershipsCollection.doc(partnershipId).delete();\n    // NOTA: As transações conjuntas permanecem na shared_transactions\n  }\n\n  // --- Funções Auxiliares para Coleções Compartilhadas ---\n  \n  // Rota para a coleção compartilhada: artifacts/{appId}/public/data/shared_transactions/{sharedCollectionId}/...\n  CollectionReference _getSharedCollectionRef(String sharedCollectionId, String transactionType) {\n     return FirebaseFirestore.instance\n      .collection('artifacts')\n      .doc('FamilyFinances') // Usando nome fixo para simulação\n      .collection('public')\n      .doc('data')\n      .collection(PUBLIC_TRANSACTIONS_PATH)\n      .doc(sharedCollectionId)\n      .collection(transactionType); // 'expenses' ou 'receipts'\n  }\n\n  CollectionReference getSharedExpensesCollection(String sharedCollectionId) {\n    return _getSharedCollectionRef(sharedCollectionId, 'expenses');\n  }\n\n  CollectionReference getSharedReceiptsCollection(String sharedCollectionId) {\n    return _getSharedCollectionRef(sharedCollectionId, 'receipts');\n  }\n\n  // --- MÉTODOS CRUD (Privados e Compartilhados) ---\n\n  Future<void> addExpense(Expense expense, {String? sharedCollectionId}) {\n    if (expense.isShared && sharedCollectionId != null) {\n      return getSharedExpensesCollection(sharedCollectionId).add(expense.toMap());\n    } else {\n      return _expensesCollection.add(expense.toMap());\n    }\n  }\n\n  Future<void> updateExpense(Expense expense, {String? sharedCollectionId}) {\n    if (expense.isShared && sharedCollectionId != null && expense.id != null) {\n      return getSharedExpensesCollection(sharedCollectionId).doc(expense.id).update(expense.toMap());\n    } else if (expense.id != null) {\n      return _expensesCollection.doc(expense.id).update(expense.toMap());\n    }\n    return Future.value();\n  }\n\n  Future<void> deleteExpense(String id, {String? sharedCollectionId, bool isShared = false}) {\n     if (isShared && sharedCollectionId != null) {\n       return getSharedExpensesCollection(sharedCollectionId).doc(id).delete();\n     }\n     return _expensesCollection.doc(id).delete();\n  }\n\n  Future<void> addReceipt(Receipt receipt, {String? sharedCollectionId}) {\n    if (receipt.isShared && sharedCollectionId != null) {\n      return getSharedReceiptsCollection(sharedCollectionId).add(receipt.toMap());\n    } else {\n      return _receiptsCollection.add(receipt.toMap());\n    }\n  }\n\n  Future<void> updateReceipt(Receipt receipt, {String? sharedCollectionId}) {\n    if (receipt.isShared && sharedCollectionId != null && receipt.id != null) {\n      return getSharedReceiptsCollection(sharedCollectionId).doc(receipt.id).update(receipt.toMap());\n    } else if (receipt.id != null) {\n      return _receiptsCollection.doc(receipt.id).update(receipt.toMap());\n    }\n    return Future.value();\n  }\n\n  Future<void> deleteReceipt(String id, {String? sharedCollectionId, bool isShared = false}) {\n    if (isShared && sharedCollectionId != null) {\n      return getSharedReceiptsCollection(sharedCollectionId).doc(id).delete();\n    }\n    return _receiptsCollection.doc(id).delete();\n  }\n  \n  // --- MÉTODOS DE STREAM PRIVADOS (utilizados pelo FinanceState) ---\n  \n  Stream<List<Expense>> getPrivateExpensesStream() {\n    return _expensesCollection\n        .orderBy('date', descending: true)\n        .snapshots()\n        .map((snapshot) => snapshot.docs\n            .map((doc) => Expense.fromMapFromFirestore(doc.data() as Map<String, dynamic>, doc.id))\n            .toList());\n  }\n\n  Stream<List<Receipt>> getPrivateReceiptsStream() {\n    return _receiptsCollection\n        .orderBy('date', descending: true)\n        .snapshots()\n        .map((snapshot) => snapshot.docs\n            .map((doc) => Receipt.fromMapFromFirestore(doc.data() as Map<String, dynamic>, doc.id))\n            .toList());\n  }\n\n  // --- MÉTODOS PRODUTOS E CATEGORIAS (mantidos) ---\n\n  Future<Map<String, ProductCategory>> _getCategoryMap() async {\n    final snapshot = await _productCategoriesCollection.get();\n    final categories = snapshot.docs.map((doc) {\n      return ProductCategory.fromMapFromFirestore(doc.data() as Map<String, dynamic>, doc.id);\n    }).toList();\n    \n    Map<String, ProductCategory> categoryMap = {\n      for (var cat in categories) cat.id: cat\n    };\n    \n    categoryMap[ProductCategory.indefinida.id] = ProductCategory.indefinida;\n    \n    return categoryMap;\n  }\n  \n  Future<void> addProduct(Product product) =>\n      _productsCollection.add(product.toMap());\n\n  Future<void> updateProduct(Product product) =>\n      _productsCollection.doc(product.id).update(product.toMap());\n\n  Future<void> deleteProduct(String id) =>\n      _productsCollection.doc(id).delete();\n\n  Stream<List<Product>> getProductsStream() {\n    return _productsCollection.snapshots().asyncMap((productSnapshot) async {\n      final categoryMap = await _getCategoryMap();\n      \n      final products = productSnapshot.docs.map((doc) {\n        final data = doc.data() as Map<String, dynamic>;\n        return Product.fromMapFromFirestore(\n          data,\n          doc.id,\n          categoryMap[data['categoryId']] ?? ProductCategory.indefinida,\n        );\n      }).toList();\n      \n      return products;\n    });\n  }\n\n  Stream<List<ProductCategory>> getCategoriesStream() {\n     return _productCategoriesCollection\n        .snapshots()\n        .map((snapshot) => snapshot.docs\n            .map((doc) => ProductCategory.fromMapFromFirestore(doc.data() as Map<String, dynamic>, doc.id))\n            .toList());\n  }\n\n  Future<void> addProductCategory(ProductCategory category) =>\n      _productCategoriesCollection.doc(category.id).set(category.toMap());\n}",
        "gemini_service.dart": "import 'dart:convert';\nimport 'dart:async'; // Para StreamSubscription e temporizadores\nimport 'package:http/http.dart' as http;\n\n/// Classe auxiliar para analisar a resposta JSON estruturada da IA.\n/// Não é um modelo do Firestore, é apenas um DTO (Data Transfer Object).\nclass ClassifiedProduct {\n  final String productName;\n  final String categoryName;\n  final int priority;\n\n  ClassifiedProduct({\n    required this.productName,\n    required this.categoryName,\n    required this.priority,\n  });\n\n  factory ClassifiedProduct.fromJson(Map<String, dynamic> json) {\n    return ClassifiedProduct(\n      productName: json['productName'] ?? 'Produto Desconhecido',\n      categoryName: json['categoryName'] ?? 'Indefinida',\n      priority: (json['priority'] as num? ?? 3).toInt(),\n    );\n  }\n}\n\nclass GeminiService {\n  // ATENÇÃO: Obtenha a sua chave de API no Google AI Studio\n  // Execute a app com: flutter run --dart-define=GEMINI_API_KEY=SUA_CHAVE_AQUI\n  static const _apiKey = String.fromEnvironment('GEMINI_API_KEY');\n  final String model = 'gemini-1.5-flash-latest';\n  final String _apiUrl;\n\n  GeminiService() : _apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$_apiKey';\n\n  /// Classifica uma lista de nomes de produtos e atribui-lhes prioridades.\n  Future<List<ClassifiedProduct>> classifyProducts(List<String> productNames, List<String> categories) async {\n    if (_apiKey.isEmpty) {\n      throw Exception('Chave de API do Gemini não configurada. Use --dart-define=GEMINI_API_KEY=SUA_CHAVE');\n    }\n\n    // 1. O Prompt do Sistema: Define as regras para a IA\n    final systemPrompt = \"\"\"\n      Você é um assistente de finanças pessoais especializado em classificar listas de compras no Brasil.\n      Sua tarefa é analisar uma lista de nomes de produtos de uma nota fiscal e atribuir a cada um:\n      1.  Uma categoria da lista fornecida.\n      2.  Uma prioridade de 1 (essencial) a 5 (supérfluo).\n\n      Categorias disponíveis: ${categories.join(', ')}\n      Use a categoria \"Indefinida\" se nenhuma outra se aplicar.\n\n      Níveis de Prioridade:\n      1: Essencial (ex: Arroz, Feijão, Ovos, Papel Higiênico, Sabonete)\n      2: Importante (ex: Frutas, Legumes, Carne, Café, Pão)\n      3: Neutro (ex: Iogurte, Manteiga, Suco, Shampoo, Detergente)\n      4. Dispensável (ex: Refrigerante, Salgadinhos, Biscoitos Recheados)\n      5: Supérfluo/Luxo (ex: Vinho Caro, Chocolate Importado, Decoração)\n\n      Responda APENAS com um objeto JSON contendo um array chamado \"classifications\".\n      NÃO inclua markdown (```json ... ```) ou qualquer outro texto.\n    \"\"\";\n\n    // 2. O Prompt do Utilizador: Os dados a serem processados\n    final userPrompt = \"Classifique os seguintes produtos:\\n${productNames.join('\\n')}\";\n\n    // 3. O Schema da Resposta: Como queremos que a IA devolva os dados\n    final responseSchema = {\n      \"type\": \"OBJECT\",\n      \"properties\": {\n        \"classifications\": {\n          \"type\": \"ARRAY\",\n          \"items\": {\n            \"type\": \"OBJECT\",\n            \"properties\": {\n              \"productName\": {\"type\": \"STRING\"},\n              \"categoryName\": {\"type\": \"STRING\"},\n              \"priority\": {\"type\": \"NUMBER\"}\n            },\n            \"required\": [\"productName\", \"categoryName\", \"priority\"]\n          }\n        }\n      },\n      \"required\": [\"classifications\"]\n    };\n\n    // 4. O Payload da Requisição\n    final payload = {\n      \"systemInstruction\": {\n        \"parts\": [{\"text\": systemPrompt}]\n      },\n      \"contents\": [\n        {\"parts\": [{\"text\": userPrompt}]}\n      ],\n      \"generationConfig\": {\n        \"responseMimeType\": \"application/json\",\n        \"responseSchema\": responseSchema,\n      }\n    };\n\n    // 5. A Chamada de API com Retentativa (Exponential Backoff)\n    int retries = 0;\n    while (retries < 3) { // Tenta até 3 vezes\n      try {\n        final response = await http.post(\n          Uri.parse(_apiUrl),\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(payload),\n        ).timeout(const Duration(seconds: 45));\n\n        if (response.statusCode == 200) {\n          final body = jsonDecode(response.body);\n          final candidate = body['candidates']?[0];\n          \n          if (candidate == null) {\n            throw Exception('Resposta da API inválida: \"candidates\" não encontrado.');\n          }\n\n          final jsonText = candidate['content']?['parts']?[0]?['text'];\n          if (jsonText == null) {\n            throw Exception('Resposta da API inválida: \"text\" não encontrado.');\n          }\n\n          final Map<String, dynamic> result = jsonDecode(jsonText);\n          final List<dynamic> classifications = result['classifications'] ?? [];\n          \n          return classifications\n              .map((item) => ClassifiedProduct.fromJson(item as Map<String, dynamic>))\n              .toList();\n\n        } else if (response.statusCode == 429 || response.statusCode == 503) {\n          // 429: Too Many Requests / 503: Service Unavailable (comum em picos)\n          throw http.ClientException(\"Serviço indisponível ou limite de taxa atingido.\", response.request?.url);\n        } else {\n          // Outros erros\n          final errorBody = jsonDecode(response.body);\n          throw Exception('Erro da API Gemini: ${response.statusCode} - ${errorBody['error']?['message'] ?? response.body}');\n        }\n\n      } catch (e) {\n        retries++;\n        if (e is TimeoutException || e is http.ClientException) {\n          if (retries >= 3) rethrow; // Desiste após a última tentativa\n          final delay = Duration(seconds: 2 * retries); // 2s, 4s\n          print('Erro de rede ou timeout, tentando novamente em $delay... ($e)');\n          await Future.delayed(delay);\n        } else {\n          // Erro de parsing ou outro erro inesperado\n          print('Erro não recuperável no GeminiService: $e');\n          rethrow; // Desiste imediatamente\n        }\n      }\n    }\n    // Se sair do loop (o que não deve acontecer)\n    throw Exception('Falha ao classificar produtos após 3 tentativas.');\n  }\n}\n\n",
        "nfce_service.dart": "import 'dart:async';\n\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:family_finances/models/nfce.dart';\nimport 'package:http/http.dart' as http;\n// Para parsear a data\nimport 'package:xml/xml.dart' as xml;\nimport '../models/nfce_item_detail.dart'; // Importa a nova classe\n\n// A classe NfceData foi removida, usamos NotaFiscal diretamente\n\nclass NfceService {\n\n  // Função auxiliar interna para buscar texto de forma segura\n  String _getElementText(xml.XmlElement parent, String elementName, {String defaultValue = ''}) {\n      try {\n        // Usa .firstOrNull para evitar exceções se o elemento não for encontrado\n        return parent.findElements(elementName).firstOrNull?.innerText ?? defaultValue;\n      } catch (e) {\n        print(\"Erro ao buscar elemento $elementName: $e\");\n        return defaultValue;\n      }\n  }\n\n\n  Future<Nfce> fetchAndParseNfce(String url) async {\n    try {\n      // Adiciona um timeout à requisição para evitar travamentos\n      final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 15));\n\n      if (response.statusCode == 200) {\n        final document = xml.XmlDocument.parse(response.body);\n\n        // Busca os elementos principais de forma mais segura\n        final nfeElement = document.findAllElements('NFe').firstOrNull;\n        if (nfeElement == null) throw Exception('Elemento <NFe> não encontrado no XML.');\n\n        final infNFeElement = nfeElement.getElement('infNFe');\n        if (infNFeElement == null) throw Exception('Elemento <infNFe> não encontrado no XML.');\n\n        final ideElement = infNFeElement.getElement('ide');\n        if (ideElement == null) throw Exception('Elemento <ide> não encontrado no XML.');\n\n        final emitElement = infNFeElement.getElement('emit');\n        if (emitElement == null) throw Exception('Elemento <emit> não encontrado no XML.');\n\n        final totalElement = infNFeElement.getElement('total')?.getElement('ICMSTot');\n        if (totalElement == null) throw Exception('Elemento <ICMSTot> não encontrado no XML.');\n\n        final infAdicElement = infNFeElement.getElement('infAdic'); // Pode ser nulo\n\n        // --- Extração dos Detalhes da Nota ---\n        final String nfceKey = infNFeElement.getAttribute('Id')?.replaceAll('NFe', '') ?? '';\n        final String storeName = _getElementText(emitElement, 'xNome', defaultValue: 'Loja Desconhecida');\n        final String totalValueText = _getElementText(totalElement, 'vNF');\n        final double totalValue = double.tryParse(totalValueText) ?? 0.0;\n        final String dateText = _getElementText(ideElement, 'dhEmi');\n\n        // Parse da data\n        Timestamp date = Timestamp.now(); // Valor padrão\n         try {\n           // Formato ISO 8601 com timezone offset: 2025-09-24T17:46:33-03:00\n            DateTime parsedDate = DateTime.parse(dateText);\n            date = Timestamp.fromDate(parsedDate);\n         } catch(e) {\n           print(\"Erro ao parsear data da NFC-e ('$dateText'): $e. Usando data atual.\");\n         }\n\n         // --- Extração das Informações Adicionais (Impostos) ---\n        String taxInfo = '';\n        if (infAdicElement != null) {\n          taxInfo = _getElementText(infAdicElement, 'infCpl');\n          // Tenta extrair apenas a parte dos tributos\n           final tribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+ Federal.*? R\\$[\\d,\\.]+ Estadual.*?Fonte IBPT');\n           final match = tribRegex.firstMatch(taxInfo);\n           if (match != null) {\n             taxInfo = match.group(0)!; // Pega só a parte dos tributos\n           } else {\n             // Se não encontrar o padrão exato, tenta um padrão mais simples\n             final simpleTribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+');\n             final simpleMatch = simpleTribRegex.firstMatch(taxInfo);\n             taxInfo = simpleMatch?.group(0) ?? ''; // Pega o que encontrar ou deixa vazio\n           }\n        }\n\n        // --- Extração dos Itens ---\n        final productsXml = infNFeElement.findAllElements('det');\n        \n        final List<NfceItemDetail> items = [];\n        for (final product in productsXml) {\n          final prodElement = product.getElement('prod');\n          if (prodElement == null) continue; // Pula se não houver <prod>\n\n          final String name = _getElementText(prodElement, 'xProd');\n          final String qtyText = _getElementText(prodElement, 'qCom');\n          final String unitPriceText = _getElementText(prodElement, 'vUnCom');\n          final String totalPriceText = _getElementText(prodElement, 'vProd');\n\n          final double quantity = double.tryParse(qtyText) ?? 0;\n          final double unitPrice = double.tryParse(unitPriceText) ?? 0;\n          final double totalPrice = double.tryParse(totalPriceText) ?? 0;\n\n          if (name.isNotEmpty) {\n            items.add(NfceItemDetail(\n              name: name.trim(), // Remove espaços extras\n              quantity: quantity,\n              unitPrice: unitPrice,\n              totalPrice: totalPrice,\n            ));\n          }\n        }\n\n        if (items.isEmpty && totalValue == 0) {\n           throw Exception('Nenhum dado relevante (itens ou valor total) encontrado no XML da NFC-e.');\n        }\n\n        // Cria e retorna o objeto NotaFiscal completo\n        return Nfce(\n          nfceKey: nfceKey,\n          storeName: storeName,\n          totalValue: totalValue,\n          date: date,\n          taxInfo: taxInfo,\n          items: items,\n        );\n      } else {\n        throw Exception('Falha ao carregar a página da NFC-e. Código de status: ${response.statusCode}');\n      }\n    } on TimeoutException {\n       throw Exception('Tempo limite excedido ao buscar dados da NFC-e.');\n    } catch (e) {\n       print(\"Erro detalhado no fetchAndParseNfce: $e\");\n       // Re-lança a exceção para ser tratada na UI, talvez com uma mensagem mais amigável\n       throw Exception('Ocorreu um erro ao processar a NFC-e: ${e.toString()}');\n    }\n  }\n}\n\n"
    },
    "styles": {
        "app_colors.dart": "import 'package:flutter/material.dart';\nclass AppColors {\n  static const Color primary = Color(0xFF2A8782);\n  static const Color secondary = Color(0xFFF8F8F8);\n  static const Color background = Color(0xFFFFFFFF);\n  static const Color surface = Color(0xFFFFFFFF);\n  static const Color error = Color(0xFFB00020);\n  static const Color onPrimary = Color(0xFFFFFFFF);\n  static const Color onSecondary = Color(0xFF000000);\n  static const Color onBackground = Color(0xFF000000);\n  static const Color onSurface = Color(0xFF000000);\n  static const Color onError = Color(0xFFFFFFFF);\n}",
        "app_theme.dart": "import 'package:family_finances/styles/app_colors.dart';\nimport 'package:flutter/material.dart';\n\nclass AppTheme{\n  static ColorScheme get appColorScheme => ColorScheme.fromSeed(seedColor: AppColors.primary);\n  static ThemeData get appTheme => ThemeData(\n    colorScheme: appColorScheme,\n        useMaterial3: true,\n    primaryColor: AppColors.primary,\n        scaffoldBackgroundColor: AppColors.background,\n        fontFamily: 'sans-serif',\n        appBarTheme: AppBarTheme(\n          backgroundColor: AppColors.primary,\n          foregroundColor: Colors.white,\n          elevation: 0,\n          titleTextStyle: TextStyle(\n            fontSize: 20,\n            fontWeight: FontWeight.bold,\n            fontFamily: 'sans-serif',\n          ),\n        ),\n        bottomNavigationBarTheme: const BottomNavigationBarThemeData(\n          selectedItemColor: Color(0xFF2A8782),\n          unselectedItemColor: Colors.grey,\n          backgroundColor: Colors.white,\n        ),\n        );\n}",
        "section_style.dart": "import 'package:flutter/material.dart';\n\nclass SectionStyle extends BoxDecoration{\n  SectionStyle() : super(\n    color: Colors.white,\n    borderRadius: BorderRadius.circular(8),\n    \n    boxShadow: [\n      BoxShadow(\n        color: Colors.black.withOpacity(0.1),\n        blurRadius: 4,\n        offset: const Offset(0, 2),\n      ),\n    ],\n  );\n}"
    },
    "utils": {
        "nfce_parser.dart": "String? extractAccessKeyFromUrl(String url) {\n  // A expressão regular procura por uma sequência de 44 dígitos numéricos\n  final RegExp regExp = RegExp(r'(\\d{44})');\n  final match = regExp.firstMatch(url);\n  \n  // Retorna a chave encontrada ou null se não encontrar\n  return match?.group(1);\n}"
    },
    "widgets": {
        "input_card.dart": "import 'package:flutter/material.dart';\nclass InputCard extends StatelessWidget {\n  final Widget child;\n  const InputCard(\n   {super.key, required this.child,});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      elevation: 4,\n      margin: const EdgeInsets.symmetric(vertical: 8.0),\n      child: Padding(\n        padding: const EdgeInsets.all(8.0),\n        child: child,\n      ),\n    );\n  }\n}",
        "row_option.dart": "\nimport 'package:flutter/material.dart';\nclass RowOption extends StatelessWidget {\n  final String title;\n  final IconData iconData;\n  final VoidCallback onTap;\n\n  const RowOption({super.key, \n    required this.title,\n    required this.iconData,\n    required this.onTap,\n  }); \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n        children: [\n      IconButton.filled(\n        color: Colors.white,\n        iconSize: 40,\n        highlightColor: Colors.grey[300],\n        onPressed: onTap, \n        icon: Icon(iconData),\n        ),\n        Text(title),\n        ]\n      );\n  }\n}"
    }
}