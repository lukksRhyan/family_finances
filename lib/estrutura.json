{
    "database_helper.dart": "// lib/database_helper.dart\nimport 'dart:async';\nimport 'package:path/path.dart';\nimport 'package:sqflite/sqflite.dart';\nimport 'models/expense.dart';\nimport 'models/receipt.dart';\nimport 'models/product.dart';\nimport 'models/product_category.dart';\n\nclass DatabaseHelper {\n  static final DatabaseHelper instance = DatabaseHelper._();\n  static Database? _database;\n  DatabaseHelper._();\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _init();\n    return _database!;\n  }\n\n  Future<Database> _init() async {\n    final dbPath = await getDatabasesPath();\n    final path = join(dbPath, 'family_finances.db');\n\n    return await openDatabase(path, version: 1, onCreate: (db, version) async {\n      // expenses\n      await db.execute('''\n        CREATE TABLE expenses (\n          localId INTEGER PRIMARY KEY AUTOINCREMENT,\n          id TEXT,\n          title TEXT,\n          value REAL,\n          categoryId TEXT,\n          categoryName TEXT,\n          note TEXT,\n          date TEXT,\n          isRecurrent INTEGER,\n          isInInstallments INTEGER,\n          installmentCount INTEGER,\n          recurrencyType INTEGER,\n          recurrentIntervalDays INTEGER,\n          isShared INTEGER,\n          sharedFromUid TEXT\n        )\n      ''');\n\n      // receipts\n      await db.execute('''\n        CREATE TABLE receipts (\n          localId INTEGER PRIMARY KEY AUTOINCREMENT,\n          id TEXT,\n          title TEXT,\n          value REAL,\n          categoryId TEXT,\n          categoryName TEXT,\n          date TEXT,\n          isRecurrent INTEGER,\n          recurrencyType INTEGER,\n          isShared INTEGER,\n          sharedFromUid TEXT\n        )\n      ''');\n\n      // product categories\n      await db.execute('''\n        CREATE TABLE productCategories (\n          localId INTEGER PRIMARY KEY AUTOINCREMENT,\n          id TEXT,\n          name TEXT,\n          iconCodePoint INTEGER\n        )\n      ''');\n\n      // products\n      await db.execute('''\n        CREATE TABLE products (\n          localId INTEGER PRIMARY KEY AUTOINCREMENT,\n          id TEXT,\n          name TEXT,\n          categoryId TEXT,\n          optionsJson TEXT,\n          isChecked INTEGER,\n          priority INTEGER\n        )\n      ''');\n    });\n  }\n\n  // --- Expenses ---\n  Future<Expense> createExpense(Expense expense) async {\n    final db = await database;\n    final id = await db.insert('expenses', {\n      ...expense.toMapForSqlite(),\n      'id': expense.id,\n    });\n    // Retorna com localId preenchido corretamente\n    return expense.copyWith(id: expense.id, localId: id);\n  }\n\n  Future<List<Expense>> getAllExpenses() async {\n    final db = await database;\n    final rows = await db.query('expenses', orderBy: 'date DESC');\n    return rows.map((r) {\n      // add localId to map for factory\n      final map = Map<String, dynamic>.from(r);\n      map['localId'] = r['localId'];\n      return Expense.fromMapForSqlite(map);\n    }).toList();\n  }\n\n  Future<void> updateExpense(Expense expense) async {\n    final db = await database;\n    await db.update('expenses', expense.toMapForSqlite()..['id'] = expense.id, where: 'localId = ?', whereArgs: [expense.localId]);\n  }\n\n  Future<void> deleteExpense(int localId) async {\n    final db = await database;\n    await db.delete('expenses', where: 'localId = ?', whereArgs: [localId]);\n  }\n\n  Future<void> deleteAllLocalData() async {\n    final db = await database;\n    await db.delete('expenses');\n    await db.delete('receipts');\n    await db.delete('products');\n    await db.delete('productCategories');\n  }\n\n  // --- Receipts ---\n  Future<Receipt> createReceipt(Receipt receipt) async {\n    final db = await database;\n    final id = await db.insert('receipts', {\n      ...receipt.toMapForSqlite(),\n      'id': receipt.id,\n    });\n    return receipt.copyWith(id: receipt.id, localId: id);\n  }\n\n  Future<List<Receipt>> getAllReceipts() async {\n    final db = await database;\n    final rows = await db.query('receipts', orderBy: 'date DESC');\n    return rows.map((r) {\n      final map = Map<String, dynamic>.from(r);\n      map['localId'] = r['localId'];\n      return Receipt.fromMapForSqlite(map);\n    }).toList();\n  }\n\n  Future<void> updateReceipt(Receipt receipt) async {\n    final db = await database;\n    await db.update('receipts', receipt.toMapForSqlite()..['id'] = receipt.id, where: 'localId = ?', whereArgs: [receipt.localId]);\n  }\n\n  Future<void> deleteReceipt(int localId) async {\n    final db = await database;\n    await db.delete('receipts', where: 'localId = ?', whereArgs: [localId]);\n  }\n\n  // --- Product Categories ---\n  Future<List<ProductCategory>> getAllProductCategories() async {\n    final db = await database;\n    final rows = await db.query('productCategories');\n    return rows.map((r) {\n      return ProductCategory.fromMapForSqlite({...r, 'id': r['id']?.toString()});\n    }).toList();\n  }\n\n  Future<void> createProductCategory(ProductCategory category) async {\n    final db = await database;\n    await db.insert('productCategories', {\n      'id': category.id,\n      'name': category.name,\n      'iconCodePoint': category.icon.codePoint,\n    });\n  }\n\n  // --- Products ---\n  Future<Product> createProduct(Product product) async {\n    final db = await database;\n    final id = await db.insert('products', {\n      ...product.toMapForSqlite(),\n      'id': product.id,\n    });\n    return product.copyWith(id: product.id, localId: id);\n  }\n\n  Future<List<Product>> getAllProducts() async {\n    final db = await database;\n    final rows = await db.query('products', orderBy: 'name COLLATE NOCASE ASC');\n    // Category resolution should be done by caller (we can't guess categories here)\n    return rows.map((r) {\n      final map = Map<String, dynamic>.from(r);\n      return Product.fromMapForSqlite(map);\n    }).toList();\n  }\n\n  Future<void> updateProduct(Product product) async {\n    final db = await database;\n    await db.update('products', product.toMapForSqlite()..['id'] = product.id, where: 'localId = ?', whereArgs: [product.localId]);\n  }\n\n  Future<void> deleteProduct(int localId) async {\n    final db = await database;\n    await db.delete('products', where: 'localId = ?', whereArgs: [localId]);\n  }\n}\n",
    "firebase_options.dart": "// File generated by FlutterFire CLI.\n// ignore_for_file: type=lint\nimport 'package:firebase_core/firebase_core.dart' show FirebaseOptions;\nimport 'package:flutter/foundation.dart'\n    show defaultTargetPlatform, kIsWeb, TargetPlatform;\n\n/// Default [FirebaseOptions] for use with your Firebase apps.\n///\n/// Example:\n/// ```dart\n/// import 'firebase_options.dart';\n/// // ...\n/// await Firebase.initializeApp(\n///   options: DefaultFirebaseOptions.currentPlatform,\n/// );\n/// ```\nclass DefaultFirebaseOptions {\n  static FirebaseOptions get currentPlatform {\n    if (kIsWeb) {\n      throw UnsupportedError(\n        'DefaultFirebaseOptions have not been configured for web - '\n        'you can reconfigure this by running the FlutterFire CLI again.',\n      );\n    }\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n        return android;\n      case TargetPlatform.iOS:\n        return ios;\n      case TargetPlatform.macOS:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for macos - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      case TargetPlatform.windows:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for windows - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      case TargetPlatform.linux:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for linux - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      default:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions are not supported for this platform.',\n        );\n    }\n  }\n\n  static const FirebaseOptions android = FirebaseOptions(\n    apiKey: 'AIzaSyDW_WHoWfmbSa3tip89mmASeaQktaVGPNw',\n    appId: '1:415549226593:android:5fc2f0fa8a1e81d8de7420',\n    messagingSenderId: '415549226593',\n    projectId: 'family-invest-65acc',\n    storageBucket: 'family-invest-65acc.firebasestorage.app',\n  );\n\n  static const FirebaseOptions ios = FirebaseOptions(\n    apiKey: 'AIzaSyCJGSDlrv3NAgbhcYYh4U10RgXrFWS8oqY',\n    appId: '1:415549226593:ios:0b97392de7c5440dde7420',\n    messagingSenderId: '415549226593',\n    projectId: 'family-invest-65acc',\n    storageBucket: 'family-invest-65acc.firebasestorage.app',\n    iosBundleId: 'com.example.familyFinances',\n  );\n\n}",
    "main.dart": "import 'dart:io';\nimport 'package:firebase_core/firebase_core.dart'; // 1. Adicionar import do Firebase Core\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:flutter_localizations/flutter_localizations.dart';\nimport 'package:sqflite_common_ffi/sqflite_ffi.dart';\nimport 'firebase_options.dart'; // 2. Adicionar import das opções geradas\nimport 'models/finance_state.dart';\nimport 'screens/auth_gate.dart';\nimport 'styles/app_theme.dart';\n\n\nvoid main() async {\n  \n  WidgetsFlutterBinding.ensureInitialized();\n\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n\n  if (Platform.isWindows || Platform.isLinux || Platform.isMacOS) {\n    sqfliteFfiInit();\n    databaseFactory = databaseFactoryFfi;\n  }\n\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => FinanceState(),\n      child: const FinancialManagerApp(),\n    ),\n  );\n}\n\nclass FinancialManagerApp extends StatelessWidget {\n  const FinancialManagerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Gerenciador Financeiro',\n      localizationsDelegates: const [\n        GlobalMaterialLocalizations.delegate,\n        GlobalWidgetsLocalizations.delegate,\n        GlobalCupertinoLocalizations.delegate,\n      ],\n      supportedLocales: const [Locale('pt', 'BR')],\n      debugShowCheckedModeBanner: false,\n      theme: AppTheme.appTheme,\n      // A aplicação agora começa no AuthGate\n      home: const AuthGate(),\n    );\n  }\n}\n\n",
    "models": {
        "app_categories.dart": "import 'package:flutter/material.dart';\n\nimport 'expense_category.dart';\nimport 'receipt_category.dart';\n\nclass AppCategories {\n  static const List<ExpenseCategory> expenseCategories = [\n    ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n  ];\n\n  static const List<ReceiptCategory> receiptCategories = [\n    ReceiptCategory(name: 'Salário', icon: Icons.monetization_on),\n    ReceiptCategory(name: 'Presente', icon: Icons.card_giftcard),\n    ReceiptCategory(name: 'Investimento', icon: Icons.trending_up),\n    ReceiptCategory(name: 'Outros', icon: Icons.add_circle_outline),\n  ];\n}",
        "expense.dart": "// lib/models/expense.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:flutter/material.dart';\nimport 'expense_category.dart';\n\nclass Expense {\n  final String? id; // Firestore document ID (nullable)\n  final int? localId; // SQLite autoincrement ID (nullable)\n  final String title;\n  final double value;\n  final ExpenseCategory category;\n  final String note;\n  final DateTime date;\n  final bool isRecurrent;\n  final int? recurrencyId;\n  final int? recurrencyType;\n  final int? recurrentIntervalDays;\n  final bool isInInstallments;\n  final int? installmentCount;\n  final bool isShared;\n\n  Expense({\n    this.id,\n    this.localId,\n    required this.title,\n    required this.value,\n    required this.category,\n    required this.note,\n    required this.date,\n    required this.isRecurrent,\n    this.recurrencyId,\n    this.recurrencyType,\n    this.recurrentIntervalDays,\n    required this.isInInstallments,\n    this.installmentCount,\n    this.isShared = false,\n  });\n\n  bool get isFuture => date.isAfter(DateTime.now());\n\n  /// Cria a partir de um mapa do Firestore. `id` é o documentId passado separadamente.\n  static Expense fromMap(Map<String, dynamic> map, {String? id}) {\n    return Expense(\n      id: id,\n      localId: null,\n      title: map['title'] ?? '',\n      value: (map['value'] is num) ? (map['value'] as num).toDouble() : 0.0,\n      category:ExpenseCategory.fromMapFromFirestore(map['category']),\n      note: map['note'] ?? '',\n      date: (map['date'] is Timestamp)\n          ? (map['date'] as Timestamp).toDate()\n          : DateTime.tryParse(map['date']?.toString() ?? '') ?? DateTime.now(),\n      isRecurrent: map['is_recurrent'] ?? map['isRecurrent'] ?? false,\n      recurrencyId: map['recurrency_id'] ?? map['recurrencyId'],\n      recurrencyType: map['recurrency_type'] ?? map['recurrencyType'],\n      recurrentIntervalDays: map['recurrent_interval_days'] ?? map['recurrentIntervalDays'],\n      isInInstallments: map['is_in_installments'] ?? map['isInInstallments'] ?? false,\n      installmentCount: map['installment_count'] ?? map['installmentCount'],\n      isShared: map['isShared'] ?? false,\n    );\n  }\n\n  /// Map usado para enviar para o Firestore\n  Map<String, dynamic> toMap() {\n    return {\n      'title': title,\n      'value': value,\n      'category':category.toMapForFirestore(),\n      'note': note,\n      'date': Timestamp.fromDate(date),\n      'is_recurrent': isRecurrent,\n      'recurrency_id': recurrencyId,\n      'recurrency_type': recurrencyType,\n      'recurrent_interval_days': recurrentIntervalDays,\n      'is_in_installments': isInInstallments,\n      'installment_count': installmentCount,\n      'isShared': isShared,\n    };\n  }\n\n  /// Map para armazenar no SQLite (use as chaves existentes no schema)\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      // 'id' aqui é o Firestore ID (nullable) — não confundir com localId\n      'id': id,\n      'title': title,\n      'value': value,\n      'category':category.toMapForSqlite(),\n      'note': note,\n      'date': date.toIso8601String(),\n      'isRecurrent': isRecurrent ? 1 : 0,\n      'recurrencyId': recurrencyId,\n      'recurrencyType': recurrencyType,\n      'recurrentIntervalDays': recurrentIntervalDays,\n      'isInInstallments': isInInstallments ? 1 : 0,\n      'installmentCount': installmentCount,\n      'isShared': isShared ? 1 : 0,\n      'sharedFromUid': null,\n    };\n  }\n\n  /// Constrói a partir de um row do SQLite (Map resultante do db.query)\n  factory Expense.fromMapForSqlite(Map<String, dynamic> map) {\n    final localId = map['localId'] is int\n        ? map['localId'] as int\n        : (map['localId'] != null ? int.tryParse(map['localId'].toString()) : null);\n\n    return Expense(\n      id: map['id']?.toString(),\n      localId: localId,\n      title: map['title']?.toString() ?? '',\n      value: (map['value'] is num) ? (map['value'] as num).toDouble() : double.tryParse(map['value']?.toString() ?? '') ?? 0.0,\n      category: ExpenseCategory.fromMapForSqlite(map['category']),\n      note: map['note']?.toString() ?? '',\n      date: DateTime.tryParse(map['date']?.toString() ?? '') ?? DateTime.now(),\n      isRecurrent: (map['isRecurrent'] ?? 0) == 1,\n      recurrencyId: map['recurrencyId'] is int ? map['recurrencyId'] as int : (map['recurrencyId'] != null ? int.tryParse(map['recurrencyId'].toString()) : null),\n      recurrencyType: map['recurrencyType'] is int ? map['recurrencyType'] as int : (map['recurrencyType'] != null ? int.tryParse(map['recurrencyType'].toString()) : null),\n      recurrentIntervalDays: map['recurrentIntervalDays'] is int ? map['recurrentIntervalDays'] as int : (map['recurrentIntervalDays'] != null ? int.tryParse(map['recurrentIntervalDays'].toString()) : null),\n      isInInstallments: (map['isInInstallments'] ?? 0) == 1,\n      installmentCount: map['installmentCount'] is int ? map['installmentCount'] as int : (map['installmentCount'] != null ? int.tryParse(map['installmentCount'].toString()) : null),\n      isShared: (map['isShared'] ?? 0) == 1,\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() => toMap();\n\n  factory Expense.fromMapFromFirestore(Map<String, dynamic> map, String id) => fromMap(map, id: id);\n\n  Expense copyWith({\n    String? id,\n    int? localId,\n    String? title,\n    double? value,\n    ExpenseCategory? category,\n    String? note,\n    DateTime? date,\n    bool? isRecurrent,\n    int? recurrencyId,\n    int? recurrencyType,\n    int? recurrentIntervalDays,\n    bool? isInInstallments,\n    int? installmentCount,\n    bool? isShared,\n  }) {\n    return Expense(\n      id: id ?? this.id,\n      localId: localId ?? this.localId,\n      title: title ?? this.title,\n      value: value ?? this.value,\n      category: category ?? this.category,\n      note: note ?? this.note,\n      date: date ?? this.date,\n      isRecurrent: isRecurrent ?? this.isRecurrent,\n      recurrencyId: recurrencyId ?? this.recurrencyId,\n      recurrencyType: recurrencyType ?? this.recurrencyType,\n      recurrentIntervalDays: recurrentIntervalDays ?? this.recurrentIntervalDays,\n      isInInstallments: isInInstallments ?? this.isInInstallments,\n      installmentCount: installmentCount ?? this.installmentCount,\n      isShared: isShared ?? this.isShared,\n    );\n  }\n}\n",
        "expense_category.dart": "//lib/models/expense_category.dart\nimport 'package:flutter/material.dart';\n\nclass ExpenseCategory {\n  final String name;\n  final IconData icon;\n\n  const ExpenseCategory({required this.name, required this.icon});\n\n  static List<ExpenseCategory> basicCategories = [\n    ExpenseCategory(name: 'Alimentação', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Casa', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n  ];\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) return true;\n    return other is ExpenseCategory && other.name == name && other.icon == icon;\n  }\n\n  @override\n  int get hashCode => Object.hash(name, icon);\n\n  static ExpenseCategory fromMapFromFirestore(Map<String, dynamic> map) {\n    return ExpenseCategory(\n      name: map['name'] ?? 'Desconhecida',\n      icon: IconData(\n        map['icon'] ?? Icons.label_outline.codePoint,\n        fontFamily: Icons.label_outline.fontFamily,\n      ),\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'icon': icon.codePoint,\n    };\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'name': name,\n      'icon': icon.codePoint,\n    };\n  }\n\n  static ExpenseCategory fromMapForSqlite(Map<String, dynamic> map) {\n    return ExpenseCategory(\n      name: map['name'] ?? 'Desconhecida',\n      icon: IconData(\n        map['icon'] ?? Icons.label_outline.codePoint,\n        fontFamily: Icons.label_outline.fontFamily,\n      ),\n    );\n  }\n  \n\n  \n}",
        "finance_state.dart": "import 'dart:async';\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\n\nimport '../database_helper.dart';\nimport '../services/firestore_service.dart';\nimport '../services/gemini_service.dart';\n\nimport 'expense.dart';\nimport 'receipt.dart';\nimport 'product.dart';\nimport 'product_category.dart';\nimport 'expense_category.dart';\nimport 'nfce.dart';\nimport 'partnership.dart';\n\nclass FinanceState with ChangeNotifier {\n  final DatabaseHelper _databaseHelper = DatabaseHelper.instance;\n  FirestoreService? _firestoreService;\n  late GeminiService _geminiService;\n\n  StreamSubscription<List<Expense>>? _expensesPrivateSub;\n  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _expensesSharedSub;\n\n  StreamSubscription<List<Receipt>>? _receiptsPrivateSub;\n  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _receiptsSharedSub;\n\n  StreamSubscription<List<Product>>? _productsPrivateSub;\n  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _productsSharedSub;\n\n  StreamSubscription<List<ProductCategory>>? _categoriesPrivateSub;\n  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _categoriesSharedSub;\n  \n  StreamSubscription<DocumentSnapshot>? _partnershipSnapSub;\n\n  String? _uid;\n  bool _isLoading = true;\n\n  String? _activePartnershipId;\n  String? _activeSharedCollectionId;\n\n  List<Expense> _expensesPrivate = [];\n  List<Expense> _expensesShared = [];\n\n  List<Receipt> _receiptsPrivate = [];\n  List<Receipt> _receiptsShared = [];\n\n  List<Product> _productsPrivate = [];\n  List<Product> _productsShared = [];\n\n  List<ProductCategory> _categoriesPrivate = [];\n  List<ProductCategory> _categoriesShared = [];\n\n  final List<ExpenseCategory> _expenseCategories = [\n    ExpenseCategory(name: 'Compras', icon: Icons.shopping_cart),\n    ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n    ExpenseCategory(name: 'Outros', icon: Icons.category),\n  ];\n\n  FinanceState() {\n    _geminiService = GeminiService();\n    FirebaseAuth.instance.authStateChanges().listen(_handleAuth);\n    _handleAuth(FirebaseAuth.instance.currentUser);\n  }\n\n  bool get isLoggedIn => _uid != null;\n  bool get hasPartnership => _activeSharedCollectionId != null;\n\n  bool get isLoading => _isLoading;\n\n  List<Expense> get expenses {\n    final merged = [..._expensesPrivate, ..._expensesShared];\n    merged.sort((a, b) => b.date.compareTo(a.date));\n    return merged;\n  }\n\n  List<Receipt> get receipts {\n    final merged = [..._receiptsPrivate, ..._receiptsShared];\n    merged.sort((a, b) => b.date.compareTo(a.date));\n    return merged;\n  }\n\n  List<Product> get shoppingListProducts {\n    final merged = [..._productsPrivate, ..._productsShared];\n    merged.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));\n    return merged;\n  }\n\n  List<ProductCategory> get productCategories {\n    final merged = [\n      ProductCategory.indefinida,\n      ..._categoriesPrivate,\n      ..._categoriesShared\n    ];\n    return merged;\n  }\n\n  List<ExpenseCategory> get expenseCategories => _expenseCategories;\n\n  void _handleAuth(User? user) {\n    if (user != null && _uid != user.uid) {\n      _uid = user.uid;\n      _initializeCloud(user.uid);\n    } else if (user == null && _uid != null) {\n      _uid = null;\n      _clearCloud();\n      _initializeLocal();\n    } else if (user == null && _uid == null) {\n      _initializeLocal();\n    }\n  }\n\n  Future<void> _clearCloud() async {\n    await _expensesPrivateSub?.cancel();\n    await _expensesSharedSub?.cancel();\n    await _receiptsPrivateSub?.cancel();\n    await _receiptsSharedSub?.cancel();\n    await _productsPrivateSub?.cancel();\n    await _productsSharedSub?.cancel();\n    await _categoriesPrivateSub?.cancel();\n    await _categoriesSharedSub?.cancel();\n    await _partnershipSnapSub?.cancel();\n\n    _expensesPrivateSub = null;\n    _expensesSharedSub = null;\n    _receiptsPrivateSub = null;\n    _receiptsSharedSub = null;\n    _productsPrivateSub = null;\n    _productsSharedSub = null;\n    _categoriesPrivateSub = null;\n    _categoriesSharedSub = null;\n    _partnershipSnapSub = null;\n\n    _activePartnershipId = null;\n    _activeSharedCollectionId = null;\n  }\n\n  Future<void> _initializeLocal() async {\n    _isLoading = true;\n    notifyListeners();\n\n    _expensesPrivate = await _databaseHelper.getAllExpenses();\n    _receiptsPrivate = await _databaseHelper.getAllReceipts();\n    _categoriesPrivate = await _databaseHelper.getAllProductCategories();\n    _productsPrivate = await _databaseHelper.getAllProducts();\n\n    _expensesShared = [];\n    _receiptsShared = [];\n    _productsShared = [];\n    _categoriesShared = [];\n\n    _isLoading = false;\n    notifyListeners();\n  }\n\n  void _initializeCloud(String uid) {\n    _isLoading = true;\n    notifyListeners();\n\n    _firestoreService = FirestoreService(uid: uid);\n\n    _partnershipSnapSub = FirebaseFirestore.instance\n        .collection('partnerships')\n        .doc(uid)\n        .snapshots()\n        .listen(_handlePartnershipSnapshot, onError: (_) {});\n\n    _subscribePrivateCollections();\n\n    Future.delayed(const Duration(milliseconds: 300), () {\n      _isLoading = false;\n      notifyListeners();\n    });\n  }\n\n  void _handlePartnershipSnapshot(DocumentSnapshot snap) {\n    if (!snap.exists) {\n      _activePartnershipId = null;\n      _activeSharedCollectionId = null;\n      _unsubscribeSharedCollections();\n      _clearShared();\n      notifyListeners();\n      return;\n    }\n\n    final data = snap.data() as Map<String, dynamic>;\n    final sharedId = data['sharedCollectionId'];\n    final pid = snap.id;\n\n    if (_activeSharedCollectionId == sharedId) return;\n\n    _activePartnershipId = pid;\n    _activeSharedCollectionId = sharedId;\n\n    _subscribeSharedCollections();\n  }\n\n  void _subscribePrivateCollections() {\n    _expensesPrivateSub = _firestoreService!.getExpensesStream().listen((d) {\n      _expensesPrivate = d;\n      notifyListeners();\n    });\n\n    _receiptsPrivateSub = _firestoreService!.getReceiptsStream().listen((d) {\n      _receiptsPrivate = d;\n      notifyListeners();\n    });\n\n    _productsPrivateSub = _firestoreService!.getProductsStream().listen((d) {\n      _productsPrivate = d;\n      notifyListeners();\n    });\n\n    _categoriesPrivateSub =\n        _firestoreService!.getCategoriesStream().listen((d) {\n      _categoriesPrivate = d;\n      notifyListeners();\n    });\n  }\n\n  void _subscribeSharedCollections() {\n    if (_activeSharedCollectionId == null) return;\n\n    final base = FirebaseFirestore.instance\n        .collection('partnerships')\n        .doc(_activePartnershipId)\n        .collection('shared');\n\n    _expensesSharedSub = base\n        .doc('expenses')\n        .collection('items')\n        .snapshots()\n        .listen((snap) {\n      _expensesShared = snap.docs\n          .map((doc) =>\n              Expense.fromMapFromFirestore(doc.data(), doc.id))\n          .toList();\n      notifyListeners();\n    });\n\n    _receiptsSharedSub = base\n        .doc('receipts')\n        .collection('items')\n        .snapshots()\n        .listen((snap) {\n      _receiptsShared = snap.docs\n          .map((doc) =>\n              Receipt.fromMapFromFirestore(doc.data(), doc.id))\n          .toList();\n      notifyListeners();\n    });\n\n    _productsSharedSub = base\n        .doc('products')\n        .collection('items')\n        .snapshots()\n        .listen((snap) {\n      _productsShared = snap.docs\n          .map((doc) =>\n              Product.fromMapFromFirestore(doc.data(), doc.id))\n          .toList();\n      notifyListeners();\n    });\n\n    _categoriesSharedSub = base\n        .doc('productCategories')\n        .collection('items')\n        .snapshots()\n        .listen((snap) {\n      _categoriesShared = snap.docs\n          .map((doc) => ProductCategory.fromMapFromFirestore(\n              doc.data(), doc.id))\n          .toList();\n      notifyListeners();\n    });\n  }\n\n  void _unsubscribeSharedCollections() async {\n    await _expensesSharedSub?.cancel();\n    await _receiptsSharedSub?.cancel();\n    await _productsSharedSub?.cancel();\n    await _categoriesSharedSub?.cancel();\n\n    _expensesSharedSub = null;\n    _receiptsSharedSub = null;\n    _productsSharedSub = null;\n    _categoriesSharedSub = null;\n  }\n\n  void _clearShared() {\n    _expensesShared = [];\n    _receiptsShared = [];\n    _productsShared = [];\n    _categoriesShared = [];\n  }\n\n  Future<void> addExpense(Expense e) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('expenses')\n          .collection('items');\n      await base.add(e.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.addExpense(e);\n    } else {\n      final newE = await _databaseHelper.createExpense(e);\n      _expensesPrivate.insert(0, newE.copyWith(localId: newE.localId));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateExpense(Expense e) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('expenses')\n          .collection('items');\n      await base.doc(e.id).update(e.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.updateExpense(e);\n    } else {\n      await _databaseHelper.updateExpense(e);\n      _expensesPrivate = await _databaseHelper.getAllExpenses();\n      notifyListeners();\n    }\n  }\n\n  Future<void> deleteExpense(String id) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('expenses')\n          .collection('items');\n      await base.doc(id).delete();\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.deleteExpense(id);\n    } else {\n      final lid = int.tryParse(id);\n      if (lid == null) return;\n      await _databaseHelper.deleteExpense(lid);\n      _expensesPrivate.removeWhere((e) => e.localId == lid);\n      notifyListeners();\n    }\n  }\n\n  Future<void> addReceipt(Receipt r) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('receipts')\n          .collection('items');\n      await base.add(r.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.addReceipt(r);\n    } else {\n      final newR = await _databaseHelper.createReceipt(r);\n      _receiptsPrivate.insert(0, newR.copyWith(localId: newR.localId));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateReceipt(Receipt r) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('receipts')\n          .collection('items');\n      await base.doc(r.id).update(r.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.updateReceipt(r);\n    } else {\n      await _databaseHelper.updateReceipt(r);\n      _receiptsPrivate = await _databaseHelper.getAllReceipts();\n      notifyListeners();\n    }\n  }\n\n  Future<void> deleteReceipt(String id) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('receipts')\n          .collection('items');\n      await base.doc(id).delete();\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.deleteReceipt(id);\n    } else {\n      final lid = int.tryParse(id);\n      if (lid == null) return;\n      await _databaseHelper.deleteReceipt(lid);\n      _receiptsPrivate.removeWhere((e) => e.localId == lid);\n      notifyListeners();\n    }\n  }\n\n  Future<void> addProduct(Product p) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('products')\n          .collection('items');\n      await base.add(p.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.addProduct(p);\n    } else {\n      final newP = await _databaseHelper.createProduct(p);\n      _productsPrivate.add(newP.copyWith(localId: newP.localId));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateProduct(Product p) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('products')\n          .collection('items');\n      await base.doc(p.id).update(p.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.updateProduct(p);\n    } else {\n      await _databaseHelper.updateProduct(p);\n      _productsPrivate = await _databaseHelper.getAllProducts();\n      notifyListeners();\n    }\n  }\n\n  Future<void> deleteProduct(String id) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('products')\n          .collection('items');\n      await base.doc(id).delete();\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.deleteProduct(id);\n    } else {\n      final lid = int.tryParse(id);\n      if (lid == null) return;\n      await _databaseHelper.deleteProduct(lid);\n      _productsPrivate.removeWhere((p) => p.localId == lid);\n      notifyListeners();\n    }\n  }\n\n  Future<void> toggleProductChecked(Product p, bool val) async {\n    final updated = p.copyWith(isChecked: val);\n\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('products')\n          .collection('items');\n      await base.doc(p.id).update(updated.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.updateProduct(updated);\n    } else {\n      await _databaseHelper.updateProduct(updated);\n      final idx =\n          _productsPrivate.indexWhere((e) => e.localId == updated.localId);\n      if (idx != -1) {\n        _productsPrivate[idx] = updated;\n      }\n      notifyListeners();\n    }\n  }\n\n  Future<void> addProductCategory(ProductCategory c) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('productCategories')\n          .collection('items');\n      await base.add(c.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.addProductCategory(c);\n    } else {\n      await _databaseHelper.createProductCategory(c);\n      _categoriesPrivate.add(c);\n      notifyListeners();\n    }\n  }\n\n  Future<void> processNfceItems(Nfce nfce) async {}\n\n  double get totalReceitas =>\n      receipts.fold(0.0, (s, x) => s + x.value);\n\n  double get totalDespesas =>\n      expenses.fold(0.0, (s, x) => s + x.value);\n\n  double get totalReceitasAtuais =>\n      receipts.where((x) => !x.isFuture).fold(0.0, (s, x) => s + x.value);\n\n  double get totalDespesasAtuais =>\n      expenses.where((x) => !x.isFuture).fold(0.0, (s, x) => s + x.value);\n\n  double get saldoAtual => totalReceitasAtuais - totalDespesasAtuais;\n\n  void forceNotify() => notifyListeners();\n}\n",
        "nfce.dart": "// lib/models/nfce.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'nfce_item_detail.dart';\n\nclass Nfce {\n  final String? id;\n  final String nfceKey;\n  final String storeName;\n  final double totalValue;\n  final Timestamp date;\n  final String taxInfo;\n  final List<NfceItemDetail> items;\n\n  Nfce({\n    this.id,\n    required this.nfceKey,\n    required this.storeName,\n    required this.totalValue,\n    required this.date,\n    required this.taxInfo,\n    required this.items,\n  });\n\n  Map<String, dynamic> toMap() {\n    return {\n      'nfceKey': nfceKey,\n      'storeName': storeName,\n      'totalValue': totalValue,\n      'date': date,\n      'taxInfo': taxInfo,\n      'items': items.map((e) => e.toMap()).toList(),\n    };\n  }\n\n  factory Nfce.fromMap(Map<String, dynamic> map, String id) {\n    final itemsList = (map['items'] as List? ?? [])\n        .map((e) => NfceItemDetail.fromMap(e))\n        .toList();\n\n    return Nfce(\n      id: id,\n      nfceKey: map['nfceKey'],\n      storeName: map['storeName'],\n      totalValue: (map['totalValue'] as num).toDouble(),\n      date: map['date'] ?? Timestamp.now(),\n      taxInfo: map['taxInfo'],\n      items: itemsList,\n    );\n  }\n}\n",
        "nfce_item_detail.dart": "// lib/models/nfce_item_detail.dart\nclass NfceItemDetail {\n  final String name;\n  final double quantity;\n  final double unitPrice;\n  final double totalPrice;\n\n  NfceItemDetail({\n    required this.name,\n    required this.quantity,\n    required this.unitPrice,\n    required this.totalPrice,\n  });\n\n  Map<String, dynamic> toMap() {\n    return {\n      'name': name,\n      'quantity': quantity,\n      'unitPrice': unitPrice,\n      'totalPrice': totalPrice,\n    };\n  }\n\n  factory NfceItemDetail.fromMap(Map<String, dynamic> map) {\n    return NfceItemDetail(\n      name: map['name'],\n      quantity: (map['quantity'] as num).toDouble(),\n      unitPrice: (map['unitPrice'] as num).toDouble(),\n      totalPrice: (map['totalPrice'] as num).toDouble(),\n    );\n  }\n}\n",
        "partnership.dart": "// lib/models/partnership.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nclass Partnership {\n  final String id;\n  final String user1Id;\n  final String user2Id;\n  final String sharedCollectionId;\n\n  Partnership({\n    required this.id,\n    required this.user1Id,\n    required this.user2Id,\n    required this.sharedCollectionId,\n  });\n\n  static String createId(String a, String b) =>\n      (a.compareTo(b) < 0) ? '$a _ $b' : '$b _ $a';\n\n  factory Partnership.fromMap(Map<String, dynamic> map, String id) {\n    return Partnership(\n      id: id,\n      user1Id: map['user1Id'],\n      user2Id: map['user2Id'],\n      sharedCollectionId: map['sharedCollectionId'],\n    );\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'user1Id': user1Id,\n      'user2Id': user2Id,\n      'sharedCollectionId': sharedCollectionId,\n      'createdAt': Timestamp.now(),\n    };\n  }\n}\n\nclass PartnershipInvite {\n  final String id;\n  final String senderId;\n  final String receiverId;\n  final Timestamp sentAt;\n\n  PartnershipInvite({\n    required this.id,\n    required this.senderId,\n    required this.receiverId,\n    required this.sentAt,\n  });\n\n  factory PartnershipInvite.fromMap(Map<String, dynamic> map, String id) {\n    return PartnershipInvite(\n      id: id,\n      senderId: map['senderId'],\n      receiverId: map['receiverId'],\n      sentAt: map['sentAt'] ?? Timestamp.now(),\n    );\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'senderId': senderId,\n      'receiverId': receiverId,\n      'sentAt': sentAt,\n    };\n  }\n}\n",
        "product.dart": "// lib/models/product.dart\nimport 'dart:convert';\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nimport 'product_category.dart';\nimport 'product_option.dart';\n\nclass Product {\n  final String? id;\n  final int? localId;\n  final String name;\n  final ProductCategory category;\n  final List<ProductOption> options;\n  final bool isChecked;\n  final int? priority;\n\n  String get nameLower => name.toLowerCase();\n@override\nbool operator ==(Object other) {\n  if (identical(this, other)) return true;\n\n  return other is Product &&\n      nameLower == other.nameLower;\n}\n \n  Product({\n    this.id,\n    this.localId,\n    required this.name,\n    required this.category,\n    this.options = const [],\n    this.isChecked = false,\n    this.priority,\n  });\n\n  Product copyWith({\n    String? id,\n    int? localId,\n    String? name,\n    ProductCategory? category,\n    List<ProductOption>? options,\n    bool? isChecked,\n    int? priority,\n  }) {\n    return Product(\n      id: id ?? this.id,\n      localId: localId ?? this.localId,\n      name: name ?? this.name,\n      category: category ?? this.category,\n      options: options ?? List<ProductOption>.from(this.options),\n      isChecked: isChecked ?? this.isChecked,\n      priority: priority ?? this.priority,\n    );\n    }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'category': category.toMapForFirestore(),\n      'options': options.map((o) => o.toMap()).toList(),\n      'isChecked': isChecked,\n      'priority': priority,\n    };\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': id,\n      'name': name,\n      'category': category.toMapForSqlite(),\n      'optionsJson': ProductOption.encode(options),\n      'isChecked': isChecked ? 1 : 0,\n      'priority': priority,\n    };\n  }\n\n  factory Product.fromMapFromFirestore(\n      Map<String, dynamic> map,\n      String id,\n      ) {\n    final List options = map['options'] ?? [];\n    final parsed = options.map((o) => ProductOption.fromMap(o)).toList();\n\n    return Product(\n      id: id,\n      name: map['name'] ?? '',\n      category: ProductCategory.fromMapFromFirestore(map['category'], map['category'][\"id\"] ?? \"undefined\"),\n      options: List<ProductOption>.from(parsed),\n      isChecked: map['isChecked'] ?? false,\n      priority: map['priority'],\n    );\n  }\n\n  factory Product.fromMapForSqlite(Map<String, dynamic> map) {\n    return Product(\n      id: map['id']?.toString(),\n      localId: map['localId'] is int ? map['localId'] : int.tryParse(map['localId'].toString()),\n      name: map['name'],\n      category: ProductCategory.fromMapForSqlite(map['category']),\n      options: ProductOption.decode(map['optionsJson']),\n      isChecked: map['isChecked'] == 1,\n      priority: map['priority'],\n    );\n  }\n  \n  @override\n  int get hashCode => name.hashCode;\n  \n}\n",
        "product_category.dart": "// lib/models/product_category.dart\nimport 'package:flutter/material.dart';\n\nclass ProductCategory {\n  final String id;\n  final String name;\n  final IconData icon;\n  final int? defaultPriority;\n\n  const ProductCategory({\n    required this.id,\n    required this.name,\n    required this.icon,\n    this.defaultPriority,\n  });\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'iconCodePoint': icon.codePoint,\n      'iconFontFamily': icon.fontFamily,\n      'defaultPriority': defaultPriority,\n    };\n  }\n\n  factory ProductCategory.fromMapFromFirestore(Map<String, dynamic> map, String id) {\n    return ProductCategory(\n      id: id,\n      name: map['name'],\n      icon: IconData(\n        map['iconCodePoint'],\n        fontFamily: map['iconFontFamily'],\n      ),\n      defaultPriority: map['defaultPriority'],\n    );\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': id,\n      'name': name,\n      'iconCodePoint': icon.codePoint,\n      'iconFontFamily': icon.fontFamily,\n      'defaultPriority': defaultPriority,\n    };\n  }\n\n  factory ProductCategory.fromMapForSqlite(Map<String, dynamic> map) {\n    return ProductCategory(\n      id: map['id'],\n      name: map['name'],\n      icon: IconData(\n        map['iconCodePoint'],\n        fontFamily: map['iconFontFamily'],\n      ),\n      defaultPriority: map['defaultPriority'],\n    );\n  }\n\n  static const indefinida = ProductCategory(\n    id: 'undefined',\n    name: 'Indefinida',\n    icon: Icons.label_outline,\n    defaultPriority: 3,\n  );\n\n  static const alimentacao = ProductCategory(\n    id: 'food',\n    name: 'Alimentação',\n    icon: Icons.fastfood,\n    defaultPriority: 1,\n  );\n\n  static const casa = ProductCategory(\n    id: 'home',\n    name: 'Casa',\n    icon: Icons.home,\n    defaultPriority: 2,\n  );\n}\n",
        "product_option.dart": "// lib/models/product_option.dart\nimport 'dart:convert';\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nclass ProductOption {\n  final String brand;\n  final String storeName;\n  final double price;\n  final String quantity;\n  final Timestamp purchaseDate;\n\n  ProductOption({\n    required this.brand,\n    required this.storeName,\n    required this.price,\n    required this.quantity,\n    required this.purchaseDate,\n  });\n\n  Map<String, dynamic> toMap() {\n    return {\n      'brand': brand,\n      'storeName': storeName,\n      'price': price,\n      'quantity': quantity,\n      'purchaseDate': purchaseDate,\n    };\n  }\n\n  factory ProductOption.fromMap(Map<String, dynamic> map) {\n    return ProductOption(\n      brand: map['brand'],\n      storeName: map['storeName'],\n      price: (map['price'] as num).toDouble(),\n      quantity: map['quantity'],\n      purchaseDate: map['purchaseDate'] ?? Timestamp.now(),\n    );\n  }\n\n  static String encode(List<ProductOption> list) =>\n      jsonEncode(list.map((o) => o.toMap()).toList());\n\n  static List<ProductOption> decode(String? jsonStr) {\n    if (jsonStr == null || jsonStr.isEmpty) return [];\n    final raw = jsonDecode(jsonStr);\n    return raw.map<ProductOption>((o) => ProductOption.fromMap(o)).toList();\n  }\n}\n",
        "receipt.dart": "// lib/models/receipt.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'receipt_category.dart';\n\nclass Receipt {\n  final String? id;\n  final int? localId;\n  final String title;\n  final double value;\n  final DateTime date;\n  final bool isRecurrent;\n  final int? recurrencyType;\n  final bool isShared;\n  final String? sharedFromUid;\n  final ReceiptCategory category;\n  final String? note;\n\n  Receipt({\n    this.id,\n    this.localId,\n    required this.title,\n    required this.value,\n    required this.date,\n    this.isRecurrent = false,\n    this.recurrencyType,\n    this.isShared = false,\n    this.sharedFromUid,\n    required this.category,\n    this.note\n  });\n\n  bool get isFuture => date.isAfter(DateTime.now());\n\n  Receipt copyWith({\n    String? id,\n    int? localId,\n    String? title,\n    double? value,\n    DateTime? date,\n    bool? isRecurrent,\n    int? recurrencyType,\n    bool? isShared,\n    String? sharedFromUid,\n    ReceiptCategory? category,\n    String? note\n  }) {\n    return Receipt(\n      id: id ?? this.id,\n      localId: localId ?? this.localId,\n      title: title ?? this.title,\n      value: value ?? this.value,\n      date: date ?? this.date,\n      isRecurrent: isRecurrent ?? this.isRecurrent,\n      recurrencyType: recurrencyType ?? this.recurrencyType,\n      isShared: isShared ?? this.isShared,\n      sharedFromUid: sharedFromUid ?? this.sharedFromUid,\n      category: category ?? this.category,\n      note: note ?? this.note\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'title': title,\n      'value': value,\n      // Store the Firestore-friendly Timestamp\n      'date': Timestamp.fromDate(date),\n      'isRecurrent': isRecurrent,\n      'recurrencyType': recurrencyType,\n      'isShared': isShared,\n      'sharedFromUid': sharedFromUid,\n      'category': category.toMapForFirestore(),\n      'note': note\n    };\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': id,\n      'title': title,\n      'value': value,\n      'date': date.toIso8601String(),\n      'isRecurrent': isRecurrent ? 1 : 0,\n      'recurrencyType': recurrencyType,\n      'isShared': isShared ? 1 : 0,\n      'sharedFromUid': sharedFromUid,\n      'category': category.toMapForSqlite(),\n      'note':note\n    };\n  }\n\n  factory Receipt.fromMapFromFirestore(Map<String, dynamic> map, String id) {\n    DateTime parsedDate;\n    if (map['date'] is Timestamp) {\n      parsedDate = (map['date'] as Timestamp).toDate();\n    } else {\n      parsedDate = DateTime.tryParse(map['date']?.toString() ?? '') ?? DateTime.now();\n    }\n\n    return Receipt(\n      id: id,\n      localId: null,\n      title: map['title'] ?? '',\n      value: (map['value'] is num) ? (map['value'] as num).toDouble() : double.tryParse(map['value']?.toString() ?? '') ?? 0.0,\n      date: parsedDate,\n      isRecurrent: map['isRecurrent'] ?? false,\n      recurrencyType: map['recurrencyType'] as int?,\n      isShared: map['isShared'] ?? false,\n      sharedFromUid: map['sharedFromUid']?.toString(),\n      category: ReceiptCategory.fromMapFromFirestore(map['category']),\n      note: map['note']\n    );\n  }\n\n  factory Receipt.fromMapForSqlite(Map<String, dynamic> map) {\n    final localId = map['localId'] is int\n        ? map['localId'] as int\n        : (map['localId'] != null ? int.tryParse(map['localId'].toString()) : null);\n\n    return Receipt(\n      id: map['id']?.toString(),\n      localId: localId,\n      title: map['title'] ?? '',\n      value: (map['value'] is num) ? (map['value'] as num).toDouble() : double.tryParse(map['value']?.toString() ?? '') ?? 0.0,\n      date: DateTime.tryParse(map['date']?.toString() ?? '') ?? DateTime.now(),\n      isRecurrent: (map['isRecurrent'] ?? 0) == 1,\n      recurrencyType: map['recurrencyType'] is int ? map['recurrencyType'] as int : (map['recurrencyType'] != null ? int.tryParse(map['recurrencyType'].toString()) : null),\n      isShared: (map['isShared'] ?? 0) == 1,\n      sharedFromUid: map['sharedFromUid']?.toString(),\n      category: ReceiptCategory.fromMapForSqlite(map['category']),\n      note: map['note']\n    );\n  }\n}\n",
        "receipt_category.dart": "// lib/models/receipt_category.dart\nimport 'package:flutter/material.dart';\n\nclass ReceiptCategory {\n  final String name;\n  final IconData icon;\n\n  const ReceiptCategory({required this.name, required this.icon});\n\n  static const basicCategories = [\n    ReceiptCategory(name: 'Salário', icon: Icons.monetization_on),\n    ReceiptCategory(name: 'Presente', icon: Icons.card_giftcard),\n    ReceiptCategory(name: 'Investimento', icon: Icons.trending_up),\n    ReceiptCategory(name: 'Outros', icon: Icons.add_circle_outline),\n  ];\n\n  static List<ReceiptCategory> allCategories() => [...basicCategories];\n\n  static ReceiptCategory fromMapFromFirestore(Map<String, dynamic> map) {\n    return ReceiptCategory(\n      name: map['name'] ?? 'Desconhecida',\n      icon: IconData(\n        map['icon'] ?? Icons.label_outline.codePoint,\n        fontFamily: Icons.label_outline.fontFamily,\n      ),\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'icon': icon.codePoint,\n    };\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'name': name,\n      'icon': icon.codePoint,\n    };\n  }\n\n  static ReceiptCategory fromMapForSqlite(Map<String, dynamic> map) {\n    return ReceiptCategory(\n      name: map['name'],\n      icon: IconData(\n        map['icon'],\n        fontFamily: Icons.label_outline.fontFamily,\n      ),\n    );\n  }\n}\n",
        "transaction.dart": "// lib/models/transaction.dart\nimport 'package:flutter/material.dart';\n\nabstract class TransactionModel {\n  String? get id;\n  String get title;\n  double get value;\n  DateTime get date;\n  bool get isRecurrent;\n\n  String get categoryName;\n  IconData get categoryIcon;\n\n  bool get isExpense;\n\n  Map<String, dynamic> toMapForFirestore();\n  Map<String, dynamic> toMapForSqlite();\n}\n"
    },
    "screens": {
        "add_transaction_screen.dart": "import 'package:family_finances/models/receipt_category.dart';\nimport 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\nimport 'package:provider/provider.dart';\nimport '../models/finance_state.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\nimport '../models/expense_category.dart';\n\nclass AddTransactionScreen extends StatefulWidget {\n  final Expense? expenseToEdit;\n  final Receipt? receiptToEdit;\n  const AddTransactionScreen({super.key, this.expenseToEdit, this.receiptToEdit});\n  @override\n  State<AddTransactionScreen> createState() => _AddTransactionScreenState();\n}\n\nclass _AddTransactionScreenState extends State<AddTransactionScreen> {\n  final _title = TextEditingController();\n  final _value = TextEditingController();\n  DateTime _date = DateTime.now();\n  bool _isExpense = true;\n\n  @override\n  void initState() {\n    super.initState();\n    if (widget.expenseToEdit != null) {\n      final e = widget.expenseToEdit!;\n      _isExpense = true;\n      _title.text = e.title;\n      _value.text = e.value.toString();\n      _date = e.date;\n    }\n    if (widget.receiptToEdit != null) {\n      final r = widget.receiptToEdit!;\n      _isExpense = false;\n      _title.text = r.title;\n      _value.text = r.value.toString();\n      _date = r.date;\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final state = Provider.of<FinanceState>(context);\n\n    return Padding(\n      padding: MediaQuery.of(context).viewInsets,\n      child: SingleChildScrollView(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          children: [\n            Row(\n              children: [\n                ChoiceChip(\n                  label: const Text('Despesa'),\n                  selected: _isExpense,\n                  onSelected: (_) => setState(() => _isExpense = true),\n                ),\n                const SizedBox(width: 12),\n                ChoiceChip(\n                  label: const Text('Receita'),\n                  selected: !_isExpense,\n                  onSelected: (_) => setState(() => _isExpense = false),\n                ),\n              ],\n            ),\n            TextField(controller: _title, decoration: const InputDecoration(labelText: 'Título')),\n            TextField(controller: _value, decoration: const InputDecoration(labelText: 'Valor'), keyboardType: TextInputType.number),\n            TextButton(\n              onPressed: () async {\n                final picked = await showDatePicker(\n                  context: context,\n                  firstDate: DateTime(2020),\n                  lastDate: DateTime(2100),\n                  initialDate: _date,\n                );\n                if (picked != null) setState(() => _date = picked);\n              },\n              child: Text(DateFormat('dd/MM/yyyy').format(_date)),\n            ),\n            ElevatedButton(\n              onPressed: () async {\n                final t = _title.text.trim();\n                final v = double.tryParse(_value.text) ?? 0;\n                if (t.isEmpty || v <= 0) return;\n\n                if (_isExpense) {\n                  final e = Expense(\n                    id: widget.expenseToEdit?.id,\n                    title: t,\n                    value: v,\n                    category: ExpenseCategory(name: 'Geral', icon: Icons.label),\n                    note: '',\n                    date: _date,\n                    isRecurrent: false,\n                    isInInstallments: false,\n                  );\n                  widget.expenseToEdit == null\n                      ? await state.addExpense(e)\n                      : await state.updateExpense(e);\n                } else {\n                  final r = Receipt(\n                    id: widget.receiptToEdit?.id,\n                    title: t,\n                    value: v,\n                    category: ReceiptCategory(name: 'Geral', icon: Icons.label),\n                    note: '',\n                    date: _date,\n                  \n                  );\n                  widget.receiptToEdit == null\n                      ? await state.addReceipt(r)\n                      : await state.updateReceipt(r);\n                }\n                if (mounted) Navigator.pop(context);\n              },\n              child: const Text('Salvar'),\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
        "auth_gate.dart": "import 'package:flutter/material.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'overview_screen.dart';\nimport 'login_screen.dart';\n\nclass AuthGate extends StatelessWidget {\n  const AuthGate({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<User?>(\n      stream: FirebaseAuth.instance.authStateChanges(),\n      builder: (_, snap) {\n        if (!snap.hasData) return const LoginScreen();\n        return const OverviewScreen();\n      },\n    );\n  }\n}\n",
        "expense_category_screen.dart": "import 'package:flutter/material.dart';\nimport '../models/expense_category.dart';\n\nclass AddExpenseWithCategoryScreen extends StatefulWidget {\n  const AddExpenseWithCategoryScreen({super.key});\n\n  @override\n  State<AddExpenseWithCategoryScreen> createState() => _AddExpenseWithCategoryScreenState();\n}\n\nclass _AddExpenseWithCategoryScreenState extends State<AddExpenseWithCategoryScreen> {\n  final TextEditingController _titleController = TextEditingController(); // NOVO\n  final TextEditingController _valueController = TextEditingController();\n  final TextEditingController _noteController = TextEditingController();\n\n  final List<ExpenseCategory> _basic_categories = [\n    ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n  ];\n  final List<ExpenseCategory> _custom_categories = [];\n  ExpenseCategory? _selectedCategory;\n\n  void _addCategory(ExpenseCategory category) {\n    setState(() {\n      _basic_categories.add(category);\n      _selectedCategory = category;\n    });\n  }\n\n  void _showAddCategoryDialog(BuildContext context) {\n    final TextEditingController nameController = TextEditingController();\n    IconData? selectedIcon;\n    final icons = [\n      Icons.fastfood, Icons.home, Icons.directions_car, Icons.sports_esports,\n      Icons.shopping_cart, Icons.local_hospital, Icons.school\n    ];\n\n    showDialog(\n      context: context,\n      builder: (context) => StatefulBuilder(\n        builder: (context, setStateDialog) => AlertDialog(\n          title: const Text('Nova categoria'),\n          content: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              TextField(\n                controller: nameController,\n                decoration: const InputDecoration(labelText: 'Nome'),\n              ),\n              const SizedBox(height: 16),\n              Wrap(\n                spacing: 8,\n                children: icons.map((icon) => GestureDetector(\n                  onTap: () {\n                    setStateDialog(() {\n                      selectedIcon = icon;\n                    });\n                  },\n                  child: Container(\n                    decoration: BoxDecoration(\n                      border: Border.all(\n                        color: selectedIcon == icon ? Colors.teal : Colors.transparent,\n                        width: 2,\n                      ),\n                      borderRadius: BorderRadius.circular(8),\n                    ),\n                    padding: const EdgeInsets.all(8),\n                    child: Icon(icon, size: 32),\n                  ),\n                )).toList(),\n              ),\n            ],\n          ),\n          actions: [\n            TextButton(\n              onPressed: () => Navigator.of(context).pop(),\n              child: const Text('Cancelar'),\n            ),\n            ElevatedButton(\n              onPressed: () {\n                if (nameController.text.isNotEmpty && selectedIcon != null) {\n                  _addCategory(ExpenseCategory(name: nameController.text, icon: selectedIcon!));\n                  Navigator.of(context).pop();\n                }\n              },\n              child: const Text('Salvar'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    const Color primaryColor = Color(0xFF2A8782);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Adicionar Gasto')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            _buildTextField(label: 'Título', hint: 'Descrição do gasto', controller: _titleController), // NOVO\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Valor', hint: '0,00', controller: _valueController),\n            const SizedBox(height: 16),\n            _buildCategorySelector(context),\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Nota', hint: 'Adicionar nota', controller: _noteController, maxLines: 3),\n            const Spacer(),\n            ElevatedButton(\n              onPressed: () {\n                // Aqui você pode salvar o gasto, incluindo o título\n                // Remova ou comente a linha abaixo:\n                // Navigator.of(context).pop();\n              },\n              style: ElevatedButton.styleFrom(\n                backgroundColor: primaryColor,\n                padding: const EdgeInsets.symmetric(vertical: 16),\n                shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(8),\n                ),\n              ),\n              child: const Text('Salvar gasto', style: TextStyle(fontSize: 18, color: Colors.white)),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildTextField({required String label, required String hint, required TextEditingController controller, int maxLines = 1}) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        TextField(\n          controller: controller,\n          maxLines: maxLines,\n          decoration: InputDecoration(\n            hintText: hint,\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n            enabledBorder: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildCategorySelector(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        const Text('Categoria', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        DropdownButtonFormField<ExpenseCategory>(\n          initialValue: _selectedCategory,\n          items: [\n            ..._basic_categories.map((cat) => DropdownMenuItem(\n              value: cat,\n              child: Row(\n                children: [\n                  Icon(cat.icon, color: Colors.grey),\n                  const SizedBox(width: 8),\n                  Text(cat.name),\n                ],\n              ),\n            )),\n            DropdownMenuItem(\n              value: null,\n              child: Row(\n                children: const [\n                  Icon(Icons.add, color: Colors.grey),\n                  SizedBox(width: 8),\n                  Text('Nova categoria'),\n                ],\n              ),\n            ),\n          ],\n          onChanged: (cat) {\n            if (cat == null) {\n              _showAddCategoryDialog(context);\n            } else {\n              setState(() {\n                _selectedCategory = cat;\n              });\n            }\n          },\n          decoration: InputDecoration(\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}",
        "login_screen.dart": "import 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\nimport 'package:google_sign_in/google_sign_in.dart';\nimport 'package:provider/provider.dart';\nimport '../models/finance_state.dart';\nimport 'main_screen.dart';\n\nclass LoginScreen extends StatefulWidget {\n  const LoginScreen({super.key});\n\n  @override\n  State<LoginScreen> createState() => _LoginScreenState();\n}\n\nclass _LoginScreenState extends State<LoginScreen> {\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n  final _formKey = GlobalKey<FormState>();\n  String? _errorMessage;\n  bool _isLoading = false; // Estado de loading para a sincronização\n\n  @override\n  void initState() {\n    super.initState();\n\n    final GoogleSignIn signIn = GoogleSignIn.instance;\n\n    // Inicialização do Google Sign In.\n    // O listener abaixo lida com a autenticação e o Firebase AuthStateChanges no FinanceState\n    // se encarrega de carregar/sincronizar os dados após o login bem-sucedido.\n    signIn.initialize(\n      clientId: null,\n      serverClientId: null\n    ).then((_){\n        signIn.authenticationEvents.listen((event) async{\n            if(event case GoogleSignInAuthenticationEventSignIn(: final user)){\n              final auth = await user.authentication;\n              final credential = GoogleAuthProvider.credential(\n                idToken: auth.idToken,\n              );\n              // Faz o login no Firebase. Isso dispara o listener do FinanceState.\n              await FirebaseAuth.instance.signInWithCredential(credential);\n            }\n        });\n    });\n  }\n\n\n  // Função de sincronização (mantida, mas agora só é chamada se o login falhar\n  // e o usuário precisar de uma retentativa de sync, embora a chamada principal\n  // venha do FinanceState).\n  Future<void> _syncLocalData(String newUid) async {\n    final financeState = Provider.of<FinanceState>(context, listen: false);\n    \n    // Verifica se o utilizador estava em modo local antes de tentar sincronizar\n    if (financeState.isLoggedIn) {\n      return; // Já está logado, não precisa sincronizar\n    }\n\n    // VERIFICAÇÃO \"MOUNTED\"\n    if (mounted) {\n      setState(() {\n        _isLoading = true;\n        _errorMessage = \"Sincronizando dados locais para a nuvem...\";\n      });\n    }\n\n    try {\n      // Chamada real da sincronização\n      // O AuthGate tratará da navegação após o estado de auth mudar\n    } catch (e) {\n      // VERIFICAÇÃO \"MOUNTED\"\n      if (mounted) {\n        setState(() {\n          _errorMessage = \"Erro ao sincronizar: $e. Faça login novamente mais tarde para tentar de novo.\";\n        });\n      }\n    } finally {\n      // VERIFICAÇÃO \"MOUNTED\"\n      if (mounted) {\n        setState(() => _isLoading = false);\n      }\n    }\n  }\n\n  Future<void> _signIn() async {\n    if (!_formKey.currentState!.validate() || _isLoading) return;\n    try {\n      if (mounted) {\n        setState(() {\n           _isLoading = true;\n           _errorMessage = null;\n        });\n      }\n      \n      // 1. Faz o login no Firebase. \n      // O listener de auth no FinanceState cuidará da sincronização e navegação\n      await FirebaseAuth.instance.signInWithEmailAndPassword(\n        email: _emailController.text,\n        password: _passwordController.text,\n      );\n\n      // 2. Não precisamos mais da lógica de sincronização aqui.\n      // O FinanceState agora ouve a mudança de estado de autenticação e inicia a sincronização automaticamente.\n\n    } on FirebaseAuthException catch (e) {\n      if(mounted){\n        setState(() {\n          _isLoading = false;\n          _errorMessage = e.message ?? \"Ocorreu um erro.\";\n        });\n      }\n    }\n  }\n\n  Future<void> _register() async {\n    if (!_formKey.currentState!.validate() || _isLoading) return;\n    try {\n      if (mounted) {\n        setState(() {\n           _isLoading = true;\n           _errorMessage = null;\n        });\n      }\n\n      // 1. Cria o utilizador no Firebase.\n      // O listener de auth no FinanceState cuidará da sincronização e navegação\n      await FirebaseAuth.instance.createUserWithEmailAndPassword(\n        email: _emailController.text,\n        password: _passwordController.text,\n      );\n      \n      // 2. Não precisamos mais da lógica de sincronização aqui.\n      // O FinanceState agora ouve a mudança de estado de autenticação e inicia a sincronização automaticamente.\n\n    } on FirebaseAuthException catch (e) {\n       if(mounted){\n          setState(() {\n            _isLoading = false;\n            _errorMessage = e.message ?? \"Ocorreu um erro.\";\n          });\n       }\n    }\n  }\n  \n  Future<void> _signInWithGoogle() async {\n    final signIn = GoogleSignIn.instance;\n\n    if (!signIn.supportsAuthenticate()) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text(\"Este dispositivo não suporta login Google nativo.\")),\n      );\n      return;\n    }\n\n    try {\n      // A chamada a authenticate() vai disparar o listener no initState\n      await signIn.authenticate(); \n      // O listener de auth no FinanceState cuidará da sincronização e navegação.\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text(\"Erro ao autenticar com Google: $e\")),\n      );\n    }\n  }\n\n\n  void _continueAsGuest() {\n    if (_isLoading) return;\n    // Simplesmente navega para o MainScreen.\n    Navigator.of(context).pushReplacement(\n      MaterialPageRoute(builder: (context) => const MainScreen()),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: [\n                const Icon(Icons.account_balance_wallet, size: 80, color: Color(0xFF2A8782)),\n                const SizedBox(height: 16),\n                const Text(\n                  'FamilyFinances',\n                  textAlign: TextAlign.center,\n                  style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),\n                ),\n                const SizedBox(height: 48),\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(labelText: 'Email', border: OutlineInputBorder()),\n                  keyboardType: TextInputType.emailAddress,\n                  validator: (value) => (value == null || value.isEmpty) ? 'Por favor, insira o email' : null,\n                ),\n                const SizedBox(height: 16),\n                TextFormField(\n                  controller: _passwordController,\n                  decoration: const InputDecoration(labelText: 'Senha', border: OutlineInputBorder()),\n                  obscureText: true,\n                  validator: (value) => (value == null || value.length < 6) ? 'A senha deve ter pelo menos 6 caracteres' : null,\n                ),\n                if (_errorMessage != null)\n                  Padding(\n                    padding: const EdgeInsets.only(top: 16.0),\n                    child: Text(\n                      _errorMessage!,\n                      style: TextStyle(color: _isLoading ? Colors.blue : Colors.red),\n                      textAlign: TextAlign.center,\n                    ),\n                  ),\n                const SizedBox(height: 24),\n\n                // Mostra um indicador de loading nos botões\n                if (_isLoading)\n                  const Center(child: CircularProgressIndicator())\n                else ...[\n                  ElevatedButton(\n                    onPressed: _signIn,\n                    style: ElevatedButton.styleFrom(\n                      padding: const EdgeInsets.symmetric(vertical: 16),\n                      backgroundColor: const Color(0xFF2A8782)\n                    ),\n                    child: const Text('Entrar', style: TextStyle(color: Colors.white, fontSize: 16)),\n                  ),\n                  const SizedBox(height: 12),\n                  OutlinedButton(\n                    onPressed: _register,\n                    style: OutlinedButton.styleFrom(\n                       padding: const EdgeInsets.symmetric(vertical: 16),\n                    ),\n                    child: const Text('Registar', style: TextStyle(fontSize: 16)),\n                  ),\n                  const SizedBox(height: 16),\n                  const Divider(),\n                  // NOVO BOTÃO: Continuar sem login\n                  TextButton(\n                    onPressed: _continueAsGuest,\n                    child: const Text(\n                      'Continuar sem login',\n                      style: TextStyle(color: Colors.grey, decoration: TextDecoration.underline),\n                    ),\n                  ),\n                ],\n                const SizedBox(height: 16),\n                SizedBox(height: 20),\nElevatedButton.icon(\n  icon: Image.asset(\n    'assets/google_logo.png',\n    height: 24,\n  ),\n  label: const Text(\"Continuar com Google\"),\n  style: ElevatedButton.styleFrom(\n    backgroundColor: Colors.white,\n    foregroundColor: Colors.black87,\n    minimumSize: const Size(double.infinity, 50),\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(8),\n      side: const BorderSide(color: Colors.grey),\n    ),\n  ),\n  onPressed: _signInWithGoogle,\n),\n\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
        "main_screen.dart": "import 'package:family_finances/screens/add_transaction_screen.dart';\nimport 'package:flutter/material.dart';\nimport 'overview_screen.dart';\nimport 'settings_screen.dart';\n\n\nclass MainScreen extends StatefulWidget {\n  const MainScreen({super.key});\n\n  @override\n  _MainScreenState createState() => _MainScreenState();\n}\n\nclass _MainScreenState extends State<MainScreen> {\n  int _selectedIndex = 0;\n\n  static const List<Widget> _screens = <Widget>[\n    OverviewScreen(),\n    SettingsScreen(),\n  ];\n\n  void _onItemTapped(int index) {\n    setState(() {\n      _selectedIndex = index;\n    });\n  }\n\n  void _openAddTransaction(BuildContext context) {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => const AddTransactionScreen(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _screens.elementAt(_selectedIndex),\n      bottomNavigationBar: Stack(\n        alignment: Alignment.bottomCenter,\n        children: [\n          BottomNavigationBar(\n            items: const [\n              BottomNavigationBarItem(\n                icon: Icon(Icons.home),\n                label: 'Início',\n              ),\n              BottomNavigationBarItem(\n                icon: Icon(Icons.settings),\n                label: 'Configurações',\n              ),\n            ],\n            currentIndex: _selectedIndex,\n            onTap: _onItemTapped,\n          ),\n          Positioned(\n            bottom: 0,\n            left: 0,\n            right: 0,\n            child: Center(\n              child: FloatingActionButton(\n                onPressed: () => _openAddTransaction(context),\n                backgroundColor: const Color(0xFF2A8782),\n                child: const Icon(Icons.add, size: 32, color: Colors.white),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
        "nfce_import_screen.dart": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:family_finances/models/nfce.dart';\nimport 'package:http/http.dart' as http;\n// Para parsear a data\nimport 'package:xml/xml.dart' as xml;\nimport 'dart:async'; // Para TimeoutException\nimport '../models/nfce_item_detail.dart'; // Importa a nova classe\n\n// A classe NfceData foi removida, usamos Nfce diretamente\n\nclass NfceService {\n\n  // Função auxiliar interna para buscar texto de forma segura\n  String _getElementText(xml.XmlElement parent, String elementName, {String defaultValue = ''}) {\n      try {\n        // Usa .firstWhereOrNull (da collection) ou .firstOrNull se disponível diretamente\n        // Alternativa segura: findElements().firstOrNull\n         final element = parent.findElements(elementName).firstOrNull;\n         return element?.innerText.trim() ?? defaultValue;\n      } catch (e) {\n        print(\"Erro ao buscar elemento $elementName: $e\");\n        return defaultValue;\n      }\n  }\n\n  // Função auxiliar para buscar atributo de forma segura\n  String _getAttribute(xml.XmlElement element, String attributeName, {String defaultValue = ''}) {\n    return element.getAttribute(attributeName) ?? defaultValue;\n  }\n\n\n  Future<Nfce> fetchAndParseNfce(String url, String userId) async {\n    print('Iniciando busca da NFC-e: $url');\n    try {\n      // Adiciona um timeout à requisição para evitar travamentos\n      final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 20));\n      print('Resposta recebida: ${response.statusCode}');\n\n      if (response.statusCode == 200) {\n        final document = xml.XmlDocument.parse(response.body);\n\n        // Busca os elementos principais de forma mais segura\n        final nfeElement = document.findAllElements('NFe').firstOrNull;\n        if (nfeElement == null) throw Exception('Elemento <NFe> não encontrado no XML.');\n\n        final infNFeElement = nfeElement.getElement('infNFe');\n        if (infNFeElement == null) throw Exception('Elemento <infNFe> não encontrado no XML.');\n\n        final ideElement = infNFeElement.getElement('ide');\n        if (ideElement == null) throw Exception('Elemento <ide> não encontrado no XML.');\n\n        final emitElement = infNFeElement.getElement('emit');\n        if (emitElement == null) throw Exception('Elemento <emit> não encontrado no XML.');\n\n        final totalElement = infNFeElement.getElement('total')?.getElement('ICMSTot');\n        if (totalElement == null) throw Exception('Elemento <ICMSTot> não encontrado no XML.');\n\n        final infAdicElement = infNFeElement.getElement('infAdic'); // Pode ser nulo\n\n        // --- Extração dos Detalhes da Nota ---\n        final String nfceKey = _getAttribute(infNFeElement, 'Id').replaceAll('NFe', '');\n        final String storeName = _getElementText(emitElement, 'xNome', defaultValue: 'Loja Desconhecida');\n        final String totalValueText = _getElementText(totalElement, 'vNF');\n        final double totalValue = double.tryParse(totalValueText) ?? 0.0;\n        final String dateText = _getElementText(ideElement, 'dhEmi');\n\n        // Parse da data\n        Timestamp date = Timestamp.now(); // Valor padrão\n         try {\n           // Formato ISO 8601 com timezone offset: 2025-09-24T17:46:33-03:00\n            DateTime parsedDate = DateTime.parse(dateText);\n            date = Timestamp.fromDate(parsedDate);\n         } catch(e) {\n           print(\"Erro ao parsear data da NFC-e ('$dateText'): $e. Usando data atual.\");\n         }\n\n         // --- Extração das Informações Adicionais (Impostos) ---\n        String taxInfo = '';\n        if (infAdicElement != null) {\n          taxInfo = _getElementText(infAdicElement, 'infCpl');\n          // Tenta extrair apenas a parte dos tributos\n           final tribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+ Federal.*? R\\$[\\d,\\.]+ Estadual.*?Fonte IBPT');\n           final match = tribRegex.firstMatch(taxInfo);\n           if (match != null) {\n             taxInfo = match.group(0)!; // Pega só a parte dos tributos\n           } else {\n             // Se não encontrar o padrão exato, tenta um padrão mais simples\n             final simpleTribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+');\n             final simpleMatch = simpleTribRegex.firstMatch(taxInfo);\n             taxInfo = simpleMatch?.group(0) ?? ''; // Pega o que encontrar ou deixa vazio\n           }\n        }\n         print('Tax Info extraída: $taxInfo');\n\n        // --- Extração dos Itens ---\n        final productsXml = infNFeElement.findAllElements('det');\n        final List<NfceItemDetail> items = [];\n        print('Encontrados ${productsXml.length} elementos <det>');\n        for (final productElement in productsXml) {\n          final prodElement = productElement.getElement('prod');\n          if (prodElement == null) {\n             print('Elemento <det> sem <prod>, pulando.');\n             continue; // Pula se não houver <prod>\n          }\n\n          final String name = _getElementText(prodElement, 'xProd');\n          final String qtyText = _getElementText(prodElement, 'qCom');\n          final String unitPriceText = _getElementText(prodElement, 'vUnCom');\n          final String totalPriceText = _getElementText(prodElement, 'vProd');\n\n          final double quantity = double.tryParse(qtyText) ?? 0;\n          final double unitPrice = double.tryParse(unitPriceText) ?? 0;\n          final double totalPrice = double.tryParse(totalPriceText) ?? 0;\n\n          print('Item encontrado: $name, Qtd: $quantity, VlUnit: $unitPrice, VlTotal: $totalPrice');\n\n          if (name.isNotEmpty) {\n            items.add(NfceItemDetail(\n              name: name.trim(), // Remove espaços extras\n              quantity: quantity,\n              unitPrice: unitPrice,\n              totalPrice: totalPrice,\n            ));\n          } else {\n             print('Item sem nome (<xProd>) encontrado, pulando.');\n          }\n        }\n\n        if (items.isEmpty && totalValue == 0) {\n           print('Nenhum item ou valor total encontrado no XML.');\n           throw Exception('Nenhum dado relevante (itens ou valor total) encontrado no XML da NFC-e.');\n        }\n\n        print('NFC-e parseada com sucesso. Itens: ${items.length}, Valor: $totalValue');\n        // Cria e retorna o objeto Nfce completo\n        return Nfce(\n          nfceKey: nfceKey,\n          storeName: storeName,\n          totalValue: totalValue,\n          date: date,\n          taxInfo: taxInfo,\n          items: items,\n        );\n      } else {\n        print('Erro na requisição HTTP: ${response.statusCode}');\n        throw Exception('Falha ao carregar a página da NFC-e. Código de status: ${response.statusCode}');\n      }\n    } on TimeoutException {\n       print('Timeout ao buscar NFC-e.');\n       throw Exception('Tempo limite excedido ao buscar dados da NFC-e. Verifique sua conexão.');\n    } catch (e) {\n       print(\"Erro detalhado no fetchAndParseNfce: $e\");\n       // Re-lança a exceção para ser tratada na UI, talvez com uma mensagem mais amigável\n       throw Exception('Ocorreu um erro ao processar a NFC-e: ${e.toString()}');\n    }\n  }\n}\n\n// Extensão para firstOrNull em Iterables (segurança)\nextension FirstOrNullExtension<E> on Iterable<E> {\n  E? get firstOrNull {\n    return isEmpty ? null : first;\n  }\n}\n\n",
        "overview_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:intl/intl.dart';\nimport '../models/finance_state.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\nimport 'add_transaction_screen.dart';\nimport 'transaction_detail_screen.dart';\nimport 'shopping_list_screen.dart';\nimport 'qr_code_scanner_screen.dart';\nimport '../services/nfce_service.dart';\nimport '../models/nfce.dart';\n\nclass OverviewScreen extends StatefulWidget {\n  const OverviewScreen({super.key});\n  @override\n  State<OverviewScreen> createState() => _OverviewScreenState();\n}\n\nclass _OverviewScreenState extends State<OverviewScreen> {\n  late DateTime _startDate;\n  late DateTime _endDate;\n\n  @override\n  void initState() {\n    super.initState();\n    final now = DateTime.now();\n    _startDate = DateTime(now.year, now.month, 1);\n    _endDate = DateTime(now.year, now.month + 1, 0);\n  }\n\n  Future<void> _selectDateRange(BuildContext context) async {\n    final picked = await showDateRangePicker(\n      context: context,\n      firstDate: DateTime(2020),\n      lastDate: DateTime(2100),\n      initialDateRange: DateTimeRange(start: _startDate, end: _endDate),\n      locale: const Locale('pt', 'BR'),\n    );\n    if (picked != null) {\n      setState(() {\n        _startDate = picked.start;\n        _endDate = picked.end;\n      });\n    }\n  }\n\n  void _addTransaction() {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => const AddTransactionScreen(),\n    );\n  }\n\n  void _openDetailsExpense(Expense e) {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => TransactionDetailScreen(expenseToShow: e),\n    );\n  }\n\n  void _openDetailsReceipt(Receipt r) {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => TransactionDetailScreen(receiptToShow: r),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final state = Provider.of<FinanceState>(context);\n\n    final filteredExpenses = state.expenses.where((e) {\n      final d = e.date;\n      return !d.isBefore(_startDate) &&\n          !d.isAfter(DateTime(_endDate.year, _endDate.month, _endDate.day, 23, 59));\n    }).toList();\n\n    final filteredReceipts = state.receipts.where((r) {\n      final d = r.date;\n      return !d.isBefore(_startDate) &&\n          !d.isAfter(DateTime(_endDate.year, _endDate.month, _endDate.day, 23, 59));\n    }).toList();\n\n    final totalR = filteredReceipts.where((r) => !r.isFuture).fold(0.0, (x, y) => x + y.value);\n    final totalD = filteredExpenses.where((e) => !e.isFuture).fold(0.0, (x, y) => x + y.value);\n\n    return Scaffold(\n      appBar: AppBar(\n        title: const Text('FamilyFinances'),\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.settings),\n            onPressed: () => Navigator.pushNamed(context, '/settings'),\n          )\n        ],\n      ),\n      body: SingleChildScrollView(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Row(\n              children: [\n                const Text('Período:'),\n                TextButton(\n                  onPressed: () => _selectDateRange(context),\n                  child: Text(\n                    '${DateFormat('dd/MM/yy').format(_startDate)} - ${DateFormat('dd/MM/yy').format(_endDate)}',\n                  ),\n                ),\n                IconButton(\n                  icon: const Icon(Icons.calendar_month),\n                  onPressed: () => _selectDateRange(context),\n                )\n              ],\n            ),\n            Text(\n              'Saldo: R\\$ ${(totalR - totalD).toStringAsFixed(2)}',\n              style: const TextStyle(fontSize: 22, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 16),\n            const Text('Despesas', style: TextStyle(fontSize: 18)),\n            const SizedBox(height: 8),\n            ...filteredExpenses.map(\n              (e) => ListTile(\n                leading: Icon(e.category.icon, color: Colors.red),\n                title: Text(e.title),\n                subtitle: Text(DateFormat('dd/MM/yyyy').format(e.date)),\n                trailing: Text(\n                  'R\\$ ${e.value.toStringAsFixed(2)}',\n                  style: const TextStyle(color: Colors.red),\n                ),\n                onTap: () => _openDetailsExpense(e),\n              ),\n            ),\n            const Divider(height: 32),\n            const Text('Receitas', style: TextStyle(fontSize: 18)),\n            const SizedBox(height: 8),\n            ...filteredReceipts.map(\n              (r) => ListTile(\n                leading: Icon(r.category.icon, color: Colors.green),\n                title: Text(r.title),\n                subtitle: Text(DateFormat('dd/MM/yyyy').format(r.date)),\n                trailing: Text(\n                  'R\\$ ${r.value.toStringAsFixed(2)}',\n                  style: const TextStyle(color: Colors.green),\n                ),\n                onTap: () => _openDetailsReceipt(r),\n              ),\n            ),\n          ],\n        ),\n      ),\n      floatingActionButton: FloatingActionButton(\n        onPressed: _addTransaction,\n        child: const Icon(Icons.add),\n      ),\n    );\n  }\n}\n",
        "qr_code_scanner_screen.dart": "import 'package:mobile_scanner/mobile_scanner.dart';\nimport 'package:flutter/material.dart';\n\nclass QRCodeScannerScreen extends StatelessWidget {\n  const QRCodeScannerScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Ler QR Code da NFC-e')),\n      body: MobileScanner(\n        controller: MobileScannerController(\n          detectionSpeed: DetectionSpeed.noDuplicates, // Evita detecções repetidas\n          facing: CameraFacing.back,\n        ),\n        onDetect: (capture) {\n          final List<Barcode> barcodes = capture.barcodes;\n          if (barcodes.isNotEmpty) {\n            final String? url = barcodes.first.rawValue;\n            // Garante que o URL não é nulo e que o ecrã ainda está ativo\n            if (url != null && context.mounted) {\n              // Fecha o scanner e devolve o URL como resultado\n              Navigator.of(context).pop(url);\n            }\n          }\n        },\n      ),\n    );\n  }\n}",
        "receipts_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\nimport 'package:provider/provider.dart';\nimport 'package:family_finances/models/receipt_category.dart';\nimport '../models/finance_state.dart';\nimport '../models/receipt.dart';\n\nclass ReceiptsScreen extends StatefulWidget {\n  const ReceiptsScreen({super.key});\n\n  @override\n  State<ReceiptsScreen> createState() => _ReceiptsScreenState();\n}\n\nclass _ReceiptsScreenState extends State<ReceiptsScreen> {\n  final TextEditingController _titleController = TextEditingController();\n  final TextEditingController _valueController = TextEditingController();\n  DateTime _selectedDate = DateTime.now(); // NOVO\n\n  @override\n  Widget build(BuildContext context) {\n    const Color primaryColor = Color(0xFF2A8782);\n    final financeState = Provider.of<FinanceState>(context);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Receitas')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            Text(\n              'R\\$ ${financeState.totalReceitas.toStringAsFixed(2)}',\n              style: const TextStyle(fontSize: 36, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 24),\n            _buildTextField(label: 'Título', hint: 'Título da receita', controller: _titleController),\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Valor', hint: '0,00', controller: _valueController),\n            const SizedBox(height: 16),\n            _buildDatePicker(context), // NOVO\n            const Spacer(),\n            ElevatedButton(\n              onPressed: () {\n                if (_titleController.text.isNotEmpty &&\n                    _valueController.text.isNotEmpty) {\n                  final receipt = Receipt(\n                    title: _titleController.text,\n                    value: double.tryParse(_valueController.text.replaceAll(',', '.')) ?? 0,\n                    date: _selectedDate,\n                    category: ReceiptCategory(name: 'Outros', icon: Icons.category),\n                    isRecurrent: false,\n                  );\n                  Provider.of<FinanceState>(context, listen: false).addReceipt(receipt);\n                  _titleController.clear();\n                  _valueController.clear();\n                  setState(() {\n                    _selectedDate = DateTime.now();\n                  });\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(content: Text('Receita salva!')),\n                  );\n                }\n              },\n              style: ElevatedButton.styleFrom(\n                backgroundColor: primaryColor,\n                padding: const EdgeInsets.symmetric(vertical: 16),\n                shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(8),\n                ),\n              ),\n              child: const Text('Salvar', style: TextStyle(fontSize: 18, color: Colors.white)),\n            ),\n            const SizedBox(height: 24),\n            const Text('Receitas cadastradas', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.grey)),\n            const Divider(),\n            Expanded(\n              child: ListView(\n                children: financeState.receipts\n                    .map((item) => _buildReceiptItem(item.title, item.value.toStringAsFixed(2), item.date))\n                    .toList(),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildTextField({required String label, required String hint, required TextEditingController controller, int maxLines = 1}) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        TextField(\n          controller: controller,\n          maxLines: maxLines,\n          decoration: InputDecoration(\n            hintText: hint,\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n            enabledBorder: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildDatePicker(BuildContext context) {\n    return Row(\n      children: [\n        const Icon(Icons.calendar_today, size: 20),\n        const SizedBox(width: 8),\n        Text('Data: ${DateFormat('dd/MM/yyyy').format(_selectedDate)}'),\n        const SizedBox(width: 8),\n        TextButton(\n          onPressed: () async {\n            final picked = await showDatePicker(\n              context: context,\n              initialDate: _selectedDate,\n              firstDate: DateTime(2000),\n              lastDate: DateTime(2100),\n            );\n            if (picked != null) {\n              setState(() {\n                _selectedDate = picked;\n              });\n            }\n          },\n          child: const Text('Alterar'),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildReceiptItem(String title, String value, DateTime date) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 12.0),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: [\n          Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              Text(title, style: const TextStyle(fontSize: 16)),\n              Text(DateFormat('dd/MM/yyyy').format(date), style: const TextStyle(fontSize: 12, color: Colors.grey)),\n            ],\n          ),\n          Text('R\\$ $value', style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500)),\n        ],\n      ),\n    );\n  }\n}",
        "settings_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport '../models/finance_state.dart';\nimport 'auth_gate.dart';\n\nclass SettingsScreen extends StatelessWidget {\n  const SettingsScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    final state = Provider.of<FinanceState>(context);\n    final user = FirebaseAuth.instance.currentUser;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Configurações')),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          //\n          // Exibe e-mail logado\n          //\n          if (user != null)\n            ListTile(\n              title: Text(user.email ?? ''),\n              subtitle: const Text('Conta logada'),\n            ),\n\n          //\n          // Botão sair\n          //\n          if (user != null)\n            ElevatedButton(\n              onPressed: () async {\n                await FirebaseAuth.instance.signOut();\n                state.forceNotify();\n\n                Navigator.pushAndRemoveUntil(\n                  context,\n                  MaterialPageRoute(builder: (_) => const AuthGate()),\n                  (_) => false,\n                );\n              },\n              child: const Text('Sair'),\n            ),\n\n          //\n          // Botão login/criar conta\n          //\n          if (user == null)\n            ElevatedButton(\n              onPressed: () {\n                Navigator.push(\n                  context,\n                  MaterialPageRoute(builder: (_) => const AuthGate()),\n                );\n              },\n              child: const Text('Login / Criar Conta'),\n            ),\n\n          const Divider(),\n\n          //\n          // Recarregar estado\n          //\n          ListTile(\n            title: const Text(\"Recarregar dados\"),\n            subtitle: const Text(\"Forçar atualização do estado\"),\n            trailing: const Icon(Icons.refresh),\n            onTap: () {\n              state.forceNotify();\n              ScaffoldMessenger.of(context).showSnackBar(\n                const SnackBar(content: Text('Estado atualizado')),\n              );\n            },\n          ),\n        ],\n      ),\n    );\n  }\n}\n",
        "shopping_list_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport '../models/finance_state.dart';\nimport '../models/product.dart';\n\nclass ShoppingListScreen extends StatefulWidget {\n  const ShoppingListScreen({super.key});\n\n  @override\n  State<ShoppingListScreen> createState() => _ShoppingListScreenState();\n}\n\nclass _ShoppingListScreenState extends State<ShoppingListScreen> {\n  final _controller = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    final state = Provider.of<FinanceState>(context);\n    final products = state.shoppingListProducts;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Lista de Compras')),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          TextField(\n            controller: _controller,\n            decoration: const InputDecoration(\n              labelText: 'Novo item',\n              suffixIcon: Icon(Icons.add),\n            ),\n            onSubmitted: (value) async {\n              if (value.trim().isEmpty) return;\n              await state.addProduct(Product(\n                id: null,\n                name: value.trim(),\n                category: state.productCategories.first,\n                isChecked: false,\n              ));\n              _controller.clear();\n            },\n          ),\n          const SizedBox(height: 16),\n          ...products.map(\n            (p) => ListTile(\n              title: Text(p.name),\n              leading: Checkbox(\n                value: p.isChecked,\n                onChanged: (v) => state.toggleProductChecked(p, v ?? false),\n              ),\n              trailing: IconButton(\n                icon: const Icon(Icons.delete),\n                onPressed: () => state.deleteProduct(p.id ?? p.localId.toString()),\n              ),\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}\n",
        "transaction_detail_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\n\nclass TransactionDetailScreen extends StatelessWidget {\n  final Expense? expenseToShow;\n  final Receipt? receiptToShow;\n  const TransactionDetailScreen({super.key, this.expenseToShow, this.receiptToShow});\n\n  @override\n  Widget build(BuildContext context) {\n    final isExpense = expenseToShow != null;\n    final title = isExpense ? expenseToShow!.title : receiptToShow!.title;\n    final value = isExpense ? expenseToShow!.value : receiptToShow!.value;\n    final categoryIcon = isExpense ? expenseToShow!.category.icon : receiptToShow!.category.icon;\n    final date = isExpense ? expenseToShow!.date : receiptToShow!.date;\n    final note = isExpense ? expenseToShow!.note : receiptToShow!.note;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Detalhes')),\n      body: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          children: [\n            Icon(categoryIcon, size: 40),\n            const SizedBox(height: 16),\n            Text(title, style: const TextStyle(fontSize: 22)),\n            const SizedBox(height: 8),\n            Text('R\\$ ${value.toStringAsFixed(2)}'),\n            const SizedBox(height: 8),\n            Text(DateFormat('dd/MM/yyyy').format(date)),\n            const SizedBox(height: 16),\n            Expanded(\n              child: SingleChildScrollView(child: Text(note ?? '')),\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
    },
    "services": {
        "firestore_service.dart": "// lib/services/firestore_service.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\nimport '../models/product.dart';\nimport '../models/product_category.dart';\n\nclass FirestoreService {\n  final String uid;\n  FirestoreService({required this.uid});\n\n  CollectionReference get _usersCollection => FirebaseFirestore.instance.collection('users');\n\n  // withConverter helpers\n  CollectionReference<Map<String, dynamic>> _subcol(String name) =>\n      _usersCollection.doc(uid).collection(name).withConverter<Map<String, dynamic>>(\n        fromFirestore: (snap, _) => snap.data() ?? <String, dynamic>{},\n        toFirestore: (map, _) => map,\n      );\n\n  CollectionReference get _expensesCollection => _usersCollection.doc(uid).collection('expenses');\n  CollectionReference get _receiptsCollection => _usersCollection.doc(uid).collection('receipts');\n  CollectionReference get _productsCollection => _usersCollection.doc(uid).collection('products');\n  CollectionReference get _productCategoriesCollection => _usersCollection.doc(uid).collection('productCategories');\n\n  // Expenses\n  Future<void> addExpense(Expense expense, {String? sharedCollectionId}) =>\n      _expensesCollection.add(expense.toMapForFirestore());\n\n  Future<void> updateExpense(Expense expense) =>\n      _expensesCollection.doc(expense.id).update(expense.toMapForFirestore());\n\n  Future<void> deleteExpense(String id) => _expensesCollection.doc(id).delete();\n\n  Stream<List<Expense>> getExpensesStream() {\n    print(_expensesCollection);\n    return _expensesCollection\n        .orderBy('date', descending: true)\n        .snapshots()\n        .map((snap) => snap.docs.map((doc) {\n              final map = doc.data() as Map<String, dynamic>;\n              // Normalize date if Timestamp\n              if (map['date'] is Timestamp) {\n                map['date'] = (map['date'] as Timestamp).toDate();\n              }\n              map['categoryId'] = map['categoryId'] ?? 'indefinida';\n              map['categoryName'] = map['categoryName'] ?? 'Outros';\n              return Expense.fromMapFromFirestore(map, doc.id);\n            }).toList());\n  }\n\n  // Receipts\n  Future<void> addReceipt(Receipt receipt) =>\n      _receiptsCollection.add(receipt.toMapForFirestore());\n\n  Future<void> updateReceipt(Receipt receipt) =>\n      _receiptsCollection.doc(receipt.id).update(receipt.toMapForFirestore());\n\n  Future<void> deleteReceipt(String id) => _receiptsCollection.doc(id).delete();\n\n  Stream<List<Receipt>> getReceiptsStream() {\n    print(_receiptsCollection);\n    return _receiptsCollection\n        .orderBy('date', descending: true)\n        .snapshots()\n        .map((snap) => snap.docs.map((doc) {\n              final map = doc.data() as Map<String, dynamic>;\n              if (map['date'] is Timestamp) map['date'] = (map['date'] as Timestamp).toDate();\n              map['categoryId'] = map['categoryId'] ?? 'outros';\n              map['categoryName'] = map['categoryName'] ?? 'Outros';\n              return Receipt.fromMapFromFirestore(map, doc.id);\n            }).toList());\n  }\n\n  // Products & categories\n  Future<Map<String, ProductCategory>> _getCategoryMap() async {\n    final snapshot = await _productCategoriesCollection.get();\n    final categories = snapshot.docs.map((doc) {\n      final data = doc.data() as Map<String, dynamic>;\n      // ensure id is set\n      return ProductCategory.fromMapFromFirestore(data, doc.id);\n    }).toList();\n\n    final map = {for (var c in categories) c.id: c};\n    map[ProductCategory.indefinida.id] = ProductCategory.indefinida;\n    return map;\n  }\n\n  Future<void> addProduct(Product product) => _productsCollection.add(product.toMapForFirestore());\n  Future<void> updateProduct(Product product) => _productsCollection.doc(product.id).update(product.toMapForFirestore());\n  Future<void> deleteProduct(String id) => _productsCollection.doc(id).delete();\n\n  Stream<List<Product>> getProductsStream() {\n    return _productsCollection.snapshots().asyncMap((productSnapshot) async {\n      final categoryMap = await _getCategoryMap();\n      final products = productSnapshot.docs.map((doc) {\n        final data = doc.data() as Map<String, dynamic>;\n        final cat = categoryMap[data['categoryId']] ?? ProductCategory.indefinida;\n        return Product.fromMapFromFirestore(data, doc.id);\n      }).toList();\n      return products;\n    });\n  }\n\n  Stream<List<ProductCategory>> getCategoriesStream() {\n    return _productCategoriesCollection\n        .snapshots()\n        .map((snap) => snap.docs.map((doc) {\n              final data = doc.data() as Map<String, dynamic>;\n              return ProductCategory.fromMapFromFirestore(data, doc.id);\n            }).toList());\n  }\n\n  Future<void> addProductCategory(ProductCategory category) =>\n      _productCategoriesCollection.add(category.toMapForFirestore());\n}\n",
        "gemini_service.dart": "import 'dart:convert';\nimport 'dart:async'; // Para StreamSubscription e temporizadores\nimport 'package:http/http.dart' as http;\n\n/// Classe auxiliar para analisar a resposta JSON estruturada da IA.\n/// Não é um modelo do Firestore, é apenas um DTO (Data Transfer Object).\nclass ClassifiedProduct {\n  final String productName;\n  final String categoryName;\n  final int priority;\n\n  ClassifiedProduct({\n    required this.productName,\n    required this.categoryName,\n    required this.priority,\n  });\n\n  factory ClassifiedProduct.fromJson(Map<String, dynamic> json) {\n    return ClassifiedProduct(\n      productName: json['productName'] ?? 'Produto Desconhecido',\n      categoryName: json['categoryName'] ?? 'Indefinida',\n      priority: (json['priority'] as num? ?? 3).toInt(),\n    );\n  }\n}\n\nclass GeminiService {\n  // ATENÇÃO: Obtenha a sua chave de API no Google AI Studio\n  // Execute a app com: flutter run --dart-define=GEMINI_API_KEY=SUA_CHAVE_AQUI\n  static const _apiKey = String.fromEnvironment('GEMINI_API_KEY');\n  final String model = 'gemini-1.5-flash-latest';\n  final String _apiUrl;\n\n  GeminiService() : _apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$_apiKey';\n\n  /// Classifica uma lista de nomes de produtos e atribui-lhes prioridades.\n  Future<List<ClassifiedProduct>> classifyProducts(List<String> productNames, List<String> categories) async {\n    if (_apiKey.isEmpty) {\n      throw Exception('Chave de API do Gemini não configurada. Use --dart-define=GEMINI_API_KEY=SUA_CHAVE');\n    }\n\n    // 1. O Prompt do Sistema: Define as regras para a IA\n    final systemPrompt = \"\"\"\n      Você é um assistente de finanças pessoais especializado em classificar listas de compras no Brasil.\n      Sua tarefa é analisar uma lista de nomes de produtos de uma nota fiscal e atribuir a cada um:\n      1.  Uma categoria da lista fornecida.\n      2.  Uma prioridade de 1 (essencial) a 5 (supérfluo).\n\n      Categorias disponíveis: ${categories.join(', ')}\n      Use a categoria \"Indefinida\" se nenhuma outra se aplicar.\n\n      Níveis de Prioridade:\n      1: Essencial (ex: Arroz, Feijão, Ovos, Papel Higiênico, Sabonete)\n      2: Importante (ex: Frutas, Legumes, Carne, Café, Pão)\n      3: Neutro (ex: Iogurte, Manteiga, Suco, Shampoo, Detergente)\n      4. Dispensável (ex: Refrigerante, Salgadinhos, Biscoitos Recheados)\n      5: Supérfluo/Luxo (ex: Vinho Caro, Chocolate Importado, Decoração)\n\n      Responda APENAS com um objeto JSON contendo um array chamado \"classifications\".\n      NÃO inclua markdown (```json ... ```) ou qualquer outro texto.\n    \"\"\";\n\n    // 2. O Prompt do Utilizador: Os dados a serem processados\n    final userPrompt = \"Classifique os seguintes produtos:\\n${productNames.join('\\n')}\";\n\n    // 3. O Schema da Resposta: Como queremos que a IA devolva os dados\n    final responseSchema = {\n      \"type\": \"OBJECT\",\n      \"properties\": {\n        \"classifications\": {\n          \"type\": \"ARRAY\",\n          \"items\": {\n            \"type\": \"OBJECT\",\n            \"properties\": {\n              \"productName\": {\"type\": \"STRING\"},\n              \"categoryName\": {\"type\": \"STRING\"},\n              \"priority\": {\"type\": \"NUMBER\"}\n            },\n            \"required\": [\"productName\", \"categoryName\", \"priority\"]\n          }\n        }\n      },\n      \"required\": [\"classifications\"]\n    };\n\n    // 4. O Payload da Requisição\n    final payload = {\n      \"systemInstruction\": {\n        \"parts\": [{\"text\": systemPrompt}]\n      },\n      \"contents\": [\n        {\"parts\": [{\"text\": userPrompt}]}\n      ],\n      \"generationConfig\": {\n        \"responseMimeType\": \"application/json\",\n        \"responseSchema\": responseSchema,\n      }\n    };\n\n    // 5. A Chamada de API com Retentativa (Exponential Backoff)\n    int retries = 0;\n    while (retries < 3) { // Tenta até 3 vezes\n      try {\n        final response = await http.post(\n          Uri.parse(_apiUrl),\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(payload),\n        ).timeout(const Duration(seconds: 45));\n\n        if (response.statusCode == 200) {\n          final body = jsonDecode(response.body);\n          final candidate = body['candidates']?[0];\n          \n          if (candidate == null) {\n            throw Exception('Resposta da API inválida: \"candidates\" não encontrado.');\n          }\n\n          final jsonText = candidate['content']?['parts']?[0]?['text'];\n          if (jsonText == null) {\n            throw Exception('Resposta da API inválida: \"text\" não encontrado.');\n          }\n\n          final Map<String, dynamic> result = jsonDecode(jsonText);\n          final List<dynamic> classifications = result['classifications'] ?? [];\n          \n          return classifications\n              .map((item) => ClassifiedProduct.fromJson(item as Map<String, dynamic>))\n              .toList();\n\n        } else if (response.statusCode == 429 || response.statusCode == 503) {\n          // 429: Too Many Requests / 503: Service Unavailable (comum em picos)\n          throw http.ClientException(\"Serviço indisponível ou limite de taxa atingido.\", response.request?.url);\n        } else {\n          // Outros erros\n          final errorBody = jsonDecode(response.body);\n          throw Exception('Erro da API Gemini: ${response.statusCode} - ${errorBody['error']?['message'] ?? response.body}');\n        }\n\n      } catch (e) {\n        retries++;\n        if (e is TimeoutException || e is http.ClientException) {\n          if (retries >= 3) rethrow; // Desiste após a última tentativa\n          final delay = Duration(seconds: 2 * retries); // 2s, 4s\n          print('Erro de rede ou timeout, tentando novamente em $delay... ($e)');\n          await Future.delayed(delay);\n        } else {\n          // Erro de parsing ou outro erro inesperado\n          print('Erro não recuperável no GeminiService: $e');\n          rethrow; // Desiste imediatamente\n        }\n      }\n    }\n    // Se sair do loop (o que não deve acontecer)\n    throw Exception('Falha ao classificar produtos após 3 tentativas.');\n  }\n}\n\n",
        "nfce_service.dart": "import 'dart:async';\n\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:family_finances/models/nfce.dart';\nimport 'package:http/http.dart' as http;\n// Para parsear a data\nimport 'package:xml/xml.dart' as xml;\nimport '../models/nfce_item_detail.dart'; // Importa a nova classe\n\n// A classe NfceData foi removida, usamos NotaFiscal diretamente\n\nclass NfceService {\n\n  // Função auxiliar interna para buscar texto de forma segura\n  String _getElementText(xml.XmlElement parent, String elementName, {String defaultValue = ''}) {\n      try {\n        // Usa .firstOrNull para evitar exceções se o elemento não for encontrado\n        return parent.findElements(elementName).firstOrNull?.innerText ?? defaultValue;\n      } catch (e) {\n        print(\"Erro ao buscar elemento $elementName: $e\");\n        return defaultValue;\n      }\n  }\n\n\n  Future<Nfce> fetchAndParseNfce(String url) async {\n    try {\n      // Adiciona um timeout à requisição para evitar travamentos\n      final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 15));\n\n      if (response.statusCode == 200) {\n        final document = xml.XmlDocument.parse(response.body);\n\n        // Busca os elementos principais de forma mais segura\n        final nfeElement = document.findAllElements('NFe').firstOrNull;\n        if (nfeElement == null) throw Exception('Elemento <NFe> não encontrado no XML.');\n\n        final infNFeElement = nfeElement.getElement('infNFe');\n        if (infNFeElement == null) throw Exception('Elemento <infNFe> não encontrado no XML.');\n\n        final ideElement = infNFeElement.getElement('ide');\n        if (ideElement == null) throw Exception('Elemento <ide> não encontrado no XML.');\n\n        final emitElement = infNFeElement.getElement('emit');\n        if (emitElement == null) throw Exception('Elemento <emit> não encontrado no XML.');\n\n        final totalElement = infNFeElement.getElement('total')?.getElement('ICMSTot');\n        if (totalElement == null) throw Exception('Elemento <ICMSTot> não encontrado no XML.');\n\n        final infAdicElement = infNFeElement.getElement('infAdic'); // Pode ser nulo\n\n        // --- Extração dos Detalhes da Nota ---\n        final String nfceKey = infNFeElement.getAttribute('Id')?.replaceAll('NFe', '') ?? '';\n        final String storeName = _getElementText(emitElement, 'xNome', defaultValue: 'Loja Desconhecida');\n        final String totalValueText = _getElementText(totalElement, 'vNF');\n        final double totalValue = double.tryParse(totalValueText) ?? 0.0;\n        final String dateText = _getElementText(ideElement, 'dhEmi');\n\n        // Parse da data\n        Timestamp date = Timestamp.now(); // Valor padrão\n         try {\n           // Formato ISO 8601 com timezone offset: 2025-09-24T17:46:33-03:00\n            DateTime parsedDate = DateTime.parse(dateText);\n            date = Timestamp.fromDate(parsedDate);\n         } catch(e) {\n           print(\"Erro ao parsear data da NFC-e ('$dateText'): $e. Usando data atual.\");\n         }\n\n         // --- Extração das Informações Adicionais (Impostos) ---\n        String taxInfo = '';\n        if (infAdicElement != null) {\n          taxInfo = _getElementText(infAdicElement, 'infCpl');\n          // Tenta extrair apenas a parte dos tributos\n           final tribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+ Federal.*? R\\$[\\d,\\.]+ Estadual.*?Fonte IBPT');\n           final match = tribRegex.firstMatch(taxInfo);\n           if (match != null) {\n             taxInfo = match.group(0)!; // Pega só a parte dos tributos\n           } else {\n             // Se não encontrar o padrão exato, tenta um padrão mais simples\n             final simpleTribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+');\n             final simpleMatch = simpleTribRegex.firstMatch(taxInfo);\n             taxInfo = simpleMatch?.group(0) ?? ''; // Pega o que encontrar ou deixa vazio\n           }\n        }\n\n        // --- Extração dos Itens ---\n        final productsXml = infNFeElement.findAllElements('det');\n        \n        final List<NfceItemDetail> items = [];\n        for (final product in productsXml) {\n          final prodElement = product.getElement('prod');\n          if (prodElement == null) continue; // Pula se não houver <prod>\n\n          final String name = _getElementText(prodElement, 'xProd');\n          final String qtyText = _getElementText(prodElement, 'qCom');\n          final String unitPriceText = _getElementText(prodElement, 'vUnCom');\n          final String totalPriceText = _getElementText(prodElement, 'vProd');\n\n          final double quantity = double.tryParse(qtyText) ?? 0;\n          final double unitPrice = double.tryParse(unitPriceText) ?? 0;\n          final double totalPrice = double.tryParse(totalPriceText) ?? 0;\n\n          if (name.isNotEmpty) {\n            items.add(NfceItemDetail(\n              name: name.trim(), // Remove espaços extras\n              quantity: quantity,\n              unitPrice: unitPrice,\n              totalPrice: totalPrice,\n            ));\n          }\n        }\n\n        if (items.isEmpty && totalValue == 0) {\n           throw Exception('Nenhum dado relevante (itens ou valor total) encontrado no XML da NFC-e.');\n        }\n\n        // Cria e retorna o objeto NotaFiscal completo\n        return Nfce(\n          nfceKey: nfceKey,\n          storeName: storeName,\n          totalValue: totalValue,\n          date: date,\n          taxInfo: taxInfo,\n          items: items,\n        );\n      } else {\n        throw Exception('Falha ao carregar a página da NFC-e. Código de status: ${response.statusCode}');\n      }\n    } on TimeoutException {\n       throw Exception('Tempo limite excedido ao buscar dados da NFC-e.');\n    } catch (e) {\n       print(\"Erro detalhado no fetchAndParseNfce: $e\");\n       // Re-lança a exceção para ser tratada na UI, talvez com uma mensagem mais amigável\n       throw Exception('Ocorreu um erro ao processar a NFC-e: ${e.toString()}');\n    }\n  }\n}\n\n"
    },
    "styles": {
        "app_colors.dart": "import 'package:flutter/material.dart';\nclass AppColors {\n  static const Color primary = Color(0xFF2A8782);\n  static const Color secondary = Color(0xFFF8F8F8);\n  static const Color background = Color(0xFFFFFFFF);\n  static const Color surface = Color(0xFFFFFFFF);\n  static const Color error = Color(0xFFB00020);\n  static const Color onPrimary = Color(0xFFFFFFFF);\n  static const Color onSecondary = Color(0xFF000000);\n  static const Color onBackground = Color(0xFF000000);\n  static const Color onSurface = Color(0xFF000000);\n  static const Color onError = Color(0xFFFFFFFF);\n}",
        "app_theme.dart": "import 'package:family_finances/styles/app_colors.dart';\nimport 'package:flutter/material.dart';\n\nclass AppTheme{\n  static ColorScheme get appColorScheme => ColorScheme.fromSeed(seedColor: AppColors.primary);\n  static ThemeData get appTheme => ThemeData(\n    colorScheme: appColorScheme,\n        useMaterial3: true,\n    primaryColor: AppColors.primary,\n        scaffoldBackgroundColor: AppColors.background,\n        fontFamily: 'sans-serif',\n        appBarTheme: AppBarTheme(\n          backgroundColor: AppColors.primary,\n          foregroundColor: Colors.white,\n          elevation: 0,\n          titleTextStyle: TextStyle(\n            fontSize: 20,\n            fontWeight: FontWeight.bold,\n            fontFamily: 'sans-serif',\n          ),\n        ),\n        bottomNavigationBarTheme: const BottomNavigationBarThemeData(\n          selectedItemColor: Color(0xFF2A8782),\n          unselectedItemColor: Colors.grey,\n          backgroundColor: Colors.white,\n        ),\n        );\n}",
        "section_style.dart": "import 'package:flutter/material.dart';\n\nclass SectionStyle extends BoxDecoration{\n  SectionStyle() : super(\n    color: Colors.white,\n    borderRadius: BorderRadius.circular(8),\n    \n    boxShadow: [\n      BoxShadow(\n        color: Colors.black.withOpacity(0.1),\n        blurRadius: 4,\n        offset: const Offset(0, 2),\n      ),\n    ],\n  );\n}"
    },
    "utils": {
        "nfce_parser.dart": "String? extractAccessKeyFromUrl(String url) {\n  // A expressão regular procura por uma sequência de 44 dígitos numéricos\n  final RegExp regExp = RegExp(r'(\\d{44})');\n  final match = regExp.firstMatch(url);\n  \n  // Retorna a chave encontrada ou null se não encontrar\n  return match?.group(1);\n}"
    },
    "widgets": {
        "input_card.dart": "import 'package:flutter/material.dart';\nclass InputCard extends StatelessWidget {\n  final Widget child;\n  const InputCard(\n   {super.key, required this.child,});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      elevation: 4,\n      margin: const EdgeInsets.symmetric(vertical: 8.0),\n      child: Padding(\n        padding: const EdgeInsets.all(8.0),\n        child: child,\n      ),\n    );\n  }\n}",
        "row_option.dart": "\nimport 'package:flutter/material.dart';\nclass RowOption extends StatelessWidget {\n  final String title;\n  final IconData iconData;\n  final VoidCallback onTap;\n\n  const RowOption({super.key, \n    required this.title,\n    required this.iconData,\n    required this.onTap,\n  }); \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n        children: [\n      IconButton.filled(\n        color: Colors.white,\n        iconSize: 40,\n        highlightColor: Colors.grey[300],\n        onPressed: onTap, \n        icon: Icon(iconData),\n        ),\n        Text(title),\n        ]\n      );\n  }\n}"
    }
}