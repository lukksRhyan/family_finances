{
    "database_helper.dart": "// lib/database_helper.dart\nimport 'dart:async';\nimport 'package:path/path.dart';\nimport 'package:sqflite/sqflite.dart';\nimport 'models/expense.dart';\nimport 'models/receipt.dart';\nimport 'models/product.dart';\nimport 'models/product_category.dart';\n\nclass DatabaseHelper {\n  static final DatabaseHelper instance = DatabaseHelper._();\n  static Database? _database;\n  DatabaseHelper._();\n\n  Future<Database> get database async {\n    if (_database != null) return _database!;\n    _database = await _init();\n    return _database!;\n  }\n\n  Future<Database> _init() async {\n    final dbPath = await getDatabasesPath();\n    final path = join(dbPath, 'family_finances.db');\n\n    return await openDatabase(path, version: 1, onCreate: (db, version) async {\n      // expenses\n      await db.execute('''\n        CREATE TABLE expenses (\n          localId INTEGER PRIMARY KEY AUTOINCREMENT,\n          id TEXT,\n          title TEXT,\n          value REAL,\n          categoryId TEXT,\n          categoryName TEXT,\n          note TEXT,\n          date TEXT,\n          isRecurrent INTEGER,\n          isInInstallments INTEGER,\n          installmentCount INTEGER,\n          recurrencyType INTEGER,\n          recurrentIntervalDays INTEGER,\n          isShared INTEGER,\n          sharedFromUid TEXT\n        )\n      ''');\n\n      // receipts\n      await db.execute('''\n        CREATE TABLE receipts (\n          localId INTEGER PRIMARY KEY AUTOINCREMENT,\n          id TEXT,\n          title TEXT,\n          value REAL,\n          categoryId TEXT,\n          categoryName TEXT,\n          date TEXT,\n          isRecurrent INTEGER,\n          recurrencyType INTEGER,\n          isShared INTEGER,\n          sharedFromUid TEXT\n        )\n      ''');\n\n      // product categories\n      await db.execute('''\n        CREATE TABLE productCategories (\n          localId INTEGER PRIMARY KEY AUTOINCREMENT,\n          id TEXT,\n          name TEXT,\n          iconCodePoint INTEGER\n        )\n      ''');\n\n      // products\n      await db.execute('''\n        CREATE TABLE products (\n          localId INTEGER PRIMARY KEY AUTOINCREMENT,\n          id TEXT,\n          name TEXT,\n          categoryId TEXT,\n          optionsJson TEXT,\n          isChecked INTEGER,\n          priority INTEGER\n        )\n      ''');\n    });\n  }\n\n  // --- Expenses ---\n  Future<Expense> createExpense(Expense expense) async {\n    final db = await database;\n    final id = await db.insert('expenses', {\n      ...expense.toMapForSqlite(),\n      'id': expense.id,\n    });\n    // Retorna com localId preenchido corretamente\n    return expense.copyWith(id: expense.id, localId: id);\n  }\n\n  Future<List<Expense>> getAllExpenses() async {\n    final db = await database;\n    final rows = await db.query('expenses', orderBy: 'date DESC');\n    return rows.map((r) {\n      // add localId to map for factory\n      final map = Map<String, dynamic>.from(r);\n      map['localId'] = r['localId'];\n      return Expense.fromMapForSqlite(map);\n    }).toList();\n  }\n\n  Future<void> updateExpense(Expense expense) async {\n    final db = await database;\n    await db.update('expenses', expense.toMapForSqlite()..['id'] = expense.id, where: 'localId = ?', whereArgs: [expense.localId]);\n  }\n\n  Future<void> deleteExpense(int localId) async {\n    final db = await database;\n    await db.delete('expenses', where: 'localId = ?', whereArgs: [localId]);\n  }\n\n  Future<void> deleteAllLocalData() async {\n    final db = await database;\n    await db.delete('expenses');\n    await db.delete('receipts');\n    await db.delete('products');\n    await db.delete('productCategories');\n  }\n\n  // --- Receipts ---\n  Future<Receipt> createReceipt(Receipt receipt) async {\n    final db = await database;\n    final id = await db.insert('receipts', {\n      ...receipt.toMapForSqlite(),\n      'id': receipt.id,\n    });\n    return receipt.copyWith(id: receipt.id, localId: id);\n  }\n\n  Future<List<Receipt>> getAllReceipts() async {\n    final db = await database;\n    final rows = await db.query('receipts', orderBy: 'date DESC');\n    return rows.map((r) {\n      final map = Map<String, dynamic>.from(r);\n      map['localId'] = r['localId'];\n      return Receipt.fromMapForSqlite(map);\n    }).toList();\n  }\n\n  Future<void> updateReceipt(Receipt receipt) async {\n    final db = await database;\n    await db.update('receipts', receipt.toMapForSqlite()..['id'] = receipt.id, where: 'localId = ?', whereArgs: [receipt.localId]);\n  }\n\n  Future<void> deleteReceipt(int localId) async {\n    final db = await database;\n    await db.delete('receipts', where: 'localId = ?', whereArgs: [localId]);\n  }\n\n  // --- Product Categories ---\n  Future<List<ProductCategory>> getAllProductCategories() async {\n    final db = await database;\n    final rows = await db.query('productCategories');\n    return rows.map((r) {\n      return ProductCategory.fromMapForSqlite({...r, 'id': r['id']?.toString()});\n    }).toList();\n  }\n\n  Future<void> createProductCategory(ProductCategory category) async {\n    final db = await database;\n    await db.insert('productCategories', {\n      'id': category.id,\n      'name': category.name,\n      'iconCodePoint': category.icon.codePoint,\n    });\n  }\n\n  // --- Products ---\n  Future<Product> createProduct(Product product) async {\n    final db = await database;\n    final id = await db.insert('products', {\n      ...product.toMapForSqlite(),\n      'id': product.id,\n    });\n    return product.copyWith(id: product.id, localId: id);\n  }\n\n  Future<List<Product>> getAllProducts() async {\n    final db = await database;\n    final rows = await db.query('products', orderBy: 'name COLLATE NOCASE ASC');\n    // Category resolution should be done by caller (we can't guess categories here)\n    return rows.map((r) {\n      final map = Map<String, dynamic>.from(r);\n      return Product.fromMapForSqlite(map);\n    }).toList();\n  }\n\n  Future<void> updateProduct(Product product) async {\n    final db = await database;\n    await db.update('products', product.toMapForSqlite()..['id'] = product.id, where: 'localId = ?', whereArgs: [product.localId]);\n  }\n\n  Future<void> deleteProduct(int localId) async {\n    final db = await database;\n    await db.delete('products', where: 'localId = ?', whereArgs: [localId]);\n  }\n}\n",
    "expense_err.txt": "I/VRI[MainActivity]@3e78383( 9614): call setFrameRateCategory for touch hint category=high hint, reason=touch, vri=VRI[MainActivity]@3e78383\nE/flutter ( 9614): [ERROR:flutter/runtime/dart_vm_initializer.cc(40)] Unhandled Exception: type 'Null' is not a subtype of type 'Map<String, dynamic>'\nE/flutter ( 9614): #0      Expense.fromMap (package:family_finances/models/expense.dart:48:56)\nE/flutter ( 9614): #1      new Expense.fromMapFromFirestore (package:family_finances/models/expense.dart:128:80)    \nE/flutter ( 9614): #2      FirestoreService.getExpensesStream.<anonymous closure>.<anonymous closure> (package:family_finances/services/firestore_service.dart:48:30)\nE/flutter ( 9614): #3      MappedListIterable.elementAt (dart:_internal/iterable.dart:442:31)\nE/flutter ( 9614): #4      ListIterator.moveNext (dart:_internal/iterable.dart:371:26)\nE/flutter ( 9614): #5      new _GrowableList._ofEfficientLengthIterable (dart:core-patch/growable_array.dart:194:27)E/flutter ( 9614): #6      new _GrowableList.of (dart:core-patch/growable_array.dart:154:28)\nE/flutter ( 9614): #7      new List.of (dart:core-patch/array_patch.dart:39:18)\nE/flutter ( 9614): #8      ListIterable.toList (dart:_internal/iterable.dart:224:7)\nE/flutter ( 9614): #9      FirestoreService.getExpensesStream.<anonymous closure> (package:family_finances/services/firestore_service.dart:49:16)\nE/flutter ( 9614): #10     _MapStream._handleData (dart:async/stream_pipe.dart:247:31)\nE/flutter ( 9614): #11     _ForwardingStreamSubscription._handleData (dart:async/stream_pipe.dart:184:13)\nE/flutter ( 9614): #12     _RootZone.runUnaryGuarded (dart:async/zone.dart:1778:10)\nE/flutter ( 9614): #13     _BufferingStreamSubscription._sendData (dart:async/stream_impl.dart:381:11)\nE/flutter ( 9614): #14     _BufferingStreamSubscription._add (dart:async/stream_impl.dart:312:7)\nE/flutter ( 9614): #15     _ForwardingStreamSubscription._add (dart:async/stream_pipe.dart:154:11)\nE/flutter ( 9614): #16     _MapStream._handleData (dart:async/stream_pipe.dart:252:10)\nE/flutter ( 9614): #17     _ForwardingStreamSubscription._handleData (dart:async/stream_pipe.dart:184:13)\nE/flutter ( 9614): #18     _RootZone.runUnaryGuarded (dart:async/zone.dart:1778:10)\nE/flutter ( 9614): #19     _BufferingStreamSubscription._sendData (dart:async/stream_impl.dart:381:11)\nE/flutter ( 9614): #20     _DelayedData.perform (dart:async/stream_impl.dart:573:14)\nE/flutter ( 9614): #21     _PendingEvents.handleNext (dart:async/stream_impl.dart:678:11)\nE/flutter ( 9614): #22     _PendingEvents.schedule.<anonymous closure> (dart:async/stream_impl.dart:649:7)\nE/flutter ( 9614): #23     _microtaskLoop (dart:async/schedule_microtask.dart:40:35)\nE/flutter ( 9614): #24     _startMicrotaskLoop (dart:async/schedule_microtask.dart:49:5)\nE/flutter ( 9614):\nI/VRI[MainActivity]@3e78383( 9614): call setFrameRateCategory for touch hint category=no preference, reason=boost timeout, vri=VRI[MainActivity]@3e78383\n",
    "firebase_options.dart": "// File generated by FlutterFire CLI.\n// ignore_for_file: type=lint\nimport 'package:firebase_core/firebase_core.dart' show FirebaseOptions;\nimport 'package:flutter/foundation.dart'\n    show defaultTargetPlatform, kIsWeb, TargetPlatform;\n\n/// Default [FirebaseOptions] for use with your Firebase apps.\n///\n/// Example:\n/// ```dart\n/// import 'firebase_options.dart';\n/// // ...\n/// await Firebase.initializeApp(\n///   options: DefaultFirebaseOptions.currentPlatform,\n/// );\n/// ```\nclass DefaultFirebaseOptions {\n  static FirebaseOptions get currentPlatform {\n    if (kIsWeb) {\n      throw UnsupportedError(\n        'DefaultFirebaseOptions have not been configured for web - '\n        'you can reconfigure this by running the FlutterFire CLI again.',\n      );\n    }\n    switch (defaultTargetPlatform) {\n      case TargetPlatform.android:\n        return android;\n      case TargetPlatform.iOS:\n        return ios;\n      case TargetPlatform.macOS:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for macos - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      case TargetPlatform.windows:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for windows - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      case TargetPlatform.linux:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions have not been configured for linux - '\n          'you can reconfigure this by running the FlutterFire CLI again.',\n        );\n      default:\n        throw UnsupportedError(\n          'DefaultFirebaseOptions are not supported for this platform.',\n        );\n    }\n  }\n\n  static const FirebaseOptions android = FirebaseOptions(\n    apiKey: 'AIzaSyDW_WHoWfmbSa3tip89mmASeaQktaVGPNw',\n    appId: '1:415549226593:android:5fc2f0fa8a1e81d8de7420',\n    messagingSenderId: '415549226593',\n    projectId: 'family-invest-65acc',\n    storageBucket: 'family-invest-65acc.firebasestorage.app',\n  );\n\n  static const FirebaseOptions ios = FirebaseOptions(\n    apiKey: 'AIzaSyCJGSDlrv3NAgbhcYYh4U10RgXrFWS8oqY',\n    appId: '1:415549226593:ios:0b97392de7c5440dde7420',\n    messagingSenderId: '415549226593',\n    projectId: 'family-invest-65acc',\n    storageBucket: 'family-invest-65acc.firebasestorage.app',\n    iosBundleId: 'com.example.familyFinances',\n  );\n\n}",
    "gerar_yaml.py": "import os\nimport json\nfrom pathlib import Path\n\ndef carregar_gitignore(caminho_base):\n    gitignore_path = Path(caminho_base) / \".gitignore\"\n    ignorar = set()\n\n    if gitignore_path.exists():\n        with open(gitignore_path, \"r\", encoding=\"utf-8\") as f:\n            for linha in f:\n                linha = linha.strip()\n                if linha and not linha.startswith(\"#\"):\n                    ignorar.add(linha.rstrip(\"/\"))\n    return ignorar\n\ndef eh_ignorado(caminho_relativo, ignorar):\n    partes = caminho_relativo.parts\n    for ignorado in ignorar:\n        if ignorado in partes or caminho_relativo.match(ignorado):\n            return True\n    return False\n\ndef ler_estrutura(caminho_base, ignorar):\n    estrutura = {}\n\n    for root, dirs, files in os.walk(caminho_base):\n        caminho_relativo = Path(root).relative_to(caminho_base)\n        if eh_ignorado(caminho_relativo, ignorar):\n            dirs[:] = []  # Impede que subpastas sejam exploradas\n            continue\n\n        atual = estrutura\n        for parte in caminho_relativo.parts:\n            atual = atual.setdefault(parte, {})\n\n        for nome_arquivo in files:\n            print(f\"Processando arquivo: {nome_arquivo}\")\n            caminho_arquivo = Path(root) / nome_arquivo\n            rel_path = Path(root).relative_to(caminho_base) / nome_arquivo\n\n            if eh_ignorado(rel_path, ignorar):\n                continue\n\n            try:\n                with open(caminho_arquivo, \"r\", encoding=\"utf-8\") as f:\n                    conteudo = f.read()\n                atual[nome_arquivo] = conteudo\n            except Exception as e:\n                atual[nome_arquivo] = f\"<erro ao ler arquivo: {e}>\"\n    return estrutura\n\ndef salvar_yaml(estrutura, caminho_saida):\n    with open(caminho_saida, \"w\", encoding=\"utf-8\") as f:\n        json.dump(estrutura, f, ensure_ascii=False, indent=4)\n\ndef main():\n    caminho_base = Path(\"D:\\\\rhyan\\\\Fratteer\\\\family_finances\\\\lib\").resolve()\n    ignorar = carregar_gitignore(caminho_base)\n    estrutura = ler_estrutura(caminho_base, ignorar)\n    salvar_yaml(estrutura, caminho_base / \"estrutura.json\")\n    print(\"Arquivo estrutura.yaml gerado com sucesso.\")\n\nif __name__ == \"__main__\":\n    main()\n",
    "main.dart": "import 'dart:io';\nimport 'package:firebase_core/firebase_core.dart'; // 1. Adicionar import do Firebase Core\nimport 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:flutter_localizations/flutter_localizations.dart';\nimport 'package:sqflite_common_ffi/sqflite_ffi.dart';\nimport 'firebase_options.dart'; // 2. Adicionar import das opções geradas\nimport 'models/finance_state.dart';\nimport 'screens/auth_gate.dart';\nimport 'styles/app_theme.dart';\n\n\nvoid main() async {\n  \n  WidgetsFlutterBinding.ensureInitialized();\n\n  await Firebase.initializeApp(\n    options: DefaultFirebaseOptions.currentPlatform,\n  );\n\n  if (Platform.isWindows || Platform.isLinux || Platform.isMacOS) {\n    sqfliteFfiInit();\n    databaseFactory = databaseFactoryFfi;\n  }\n\n  runApp(\n    ChangeNotifierProvider(\n      create: (_) => FinanceState(),\n      child: const FinancialManagerApp(),\n    ),\n  );\n}\n\nclass FinancialManagerApp extends StatelessWidget {\n  const FinancialManagerApp({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: 'Gerenciador Financeiro',\n      localizationsDelegates: const [\n        GlobalMaterialLocalizations.delegate,\n        GlobalWidgetsLocalizations.delegate,\n        GlobalCupertinoLocalizations.delegate,\n      ],\n      supportedLocales: const [Locale('pt', 'BR')],\n      debugShowCheckedModeBanner: false,\n      theme: AppTheme.appTheme,\n      // A aplicação agora começa no AuthGate\n      home: const AuthGate(),\n    );\n  }\n}\n\n",
    "receipt_err.txt": "E/flutter ( 9614): [ERROR:flutter/runtime/dart_vm_initializer.cc(40)] Unhandled Exception: type 'Null' is not a subtype of type 'Map<String, dynamic>'\nE/flutter ( 9614): #0      new Receipt.fromMapFromFirestore (package:family_finances/models/receipt.dart:110:57)\nE/flutter ( 9614): #1      FirestoreService.getReceiptsStream.<anonymous closure>.<anonymous closure> (package:family_finances/services/firestore_service.dart:71:30)\nE/flutter ( 9614): #2      MappedListIterable.elementAt (dart:_internal/iterable.dart:442:31)\nE/flutter ( 9614): #3      ListIterator.moveNext (dart:_internal/iterable.dart:371:26)\nE/flutter ( 9614): #4      new _GrowableList._ofEfficientLengthIterable (dart:core-patch/growable_array.dart:194:27)E/flutter ( 9614): #5      new _GrowableList.of (dart:core-patch/growable_array.dart:154:28)\nE/flutter ( 9614): #6      new List.of (dart:core-patch/array_patch.dart:39:18)\nE/flutter ( 9614): #7      ListIterable.toList (dart:_internal/iterable.dart:224:7)\nE/flutter ( 9614): #8      FirestoreService.getReceiptsStream.<anonymous closure> (package:family_finances/services/firestore_service.dart:72:16)\nE/flutter ( 9614): #9      _MapStream._handleData (dart:async/stream_pipe.dart:247:31)\nE/flutter ( 9614): #10     _ForwardingStreamSubscription._handleData (dart:async/stream_pipe.dart:184:13)\nE/flutter ( 9614): #11     _RootZone.runUnaryGuarded (dart:async/zone.dart:1778:10)\nE/flutter ( 9614): #12     _BufferingStreamSubscription._sendData (dart:async/stream_impl.dart:381:11)\nE/flutter ( 9614): #13     _BufferingStreamSubscription._add (dart:async/stream_impl.dart:312:7)\nE/flutter ( 9614): #14     _ForwardingStreamSubscription._add (dart:async/stream_pipe.dart:154:11)\nE/flutter ( 9614): #15     _MapStream._handleData (dart:async/stream_pipe.dart:252:10)\nE/flutter ( 9614): #16     _ForwardingStreamSubscription._handleData (dart:async/stream_pipe.dart:184:13)\nE/flutter ( 9614): #17     _RootZone.runUnaryGuarded (dart:async/zone.dart:1778:10)\nE/flutter ( 9614): #18     _BufferingStreamSubscription._sendData (dart:async/stream_impl.dart:381:11)\nE/flutter ( 9614): #19     _DelayedData.perform (dart:async/stream_impl.dart:573:14)\nE/flutter ( 9614): #20     _PendingEvents.handleNext (dart:async/stream_impl.dart:678:11)\nE/flutter ( 9614): #21     _PendingEvents.schedule.<anonymous closure> (dart:async/stream_impl.dart:649:7)\nE/flutter ( 9614): #22     _microtaskLoop (dart:async/schedule_microtask.dart:40:35)\nE/flutter ( 9614): #23     _startMicrotaskLoop (dart:async/schedule_microtask.dart:49:5)\nE/flutter ( 9614):\nI/ImeTracker( 9614): com.example.family_finances:c65872b8: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT fromUser false\nI/InputMethodManager_LC( 9614): hsifw() - flag : 0\nI/InputMethodManager_LC( 9614): hsifw() - mService.hideSoftInput\nD/InsetsController( 9614): hide(ime(), fromIme=true)\nI/InsetsController( 9614): setRequestedVisibleTypes: visible=false, mask=ime, host=com.example.family_finances/com.example.family_finances.MainActivity, from=android.view.InsetsController.controlAnimationUnchecked:1498 android.view.InsetsController.applyAnimation:2228 android.view.InsetsController.applyAnimation:2159 android.view.InsetsController.hide:1452 android.view.ViewRootImpl$ViewRootHandler.handleMessageImpl:8063 android.view.ViewRootImpl$ViewRootHandler.handleMessage:7991 android.os.Handler.dispatchMessage:107 android.os.Looper.loopOnce:257 android.os.Looper.loop:342 android.app.ActivityThread.main:9634\nI/InsetsController( 9614): controlAnimationUncheckedInner: Added types=ime, animType=1, host=com.example.family_finances/com.example.family_finances.MainActivity, from=android.view.InsetsController.controlAnimationUnchecked:1502 android.view.InsetsController.applyAnimation:2228 android.view.InsetsController.applyAnimation:2159\nD/InputConnectionAdaptor( 9614): The input method toggled cursor monitoring off\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073cbf87580 mBlastBufferQueue=0xb4000074919bbc00 fn= 305 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/InsetsController( 9614): onStateChanged: host=com.example.family_finances/com.example.family_finances.MainActivity, from=android.view.ViewRootImpl.handleInsetsControlChanged:2888, state=InsetsState: {mDisplayFrame=Rect(0, 0 - 800, 1340), mDisplayCutout=DisplayCutout{insets=Rect(0, 0 - 0, 0) waterfall=Insets{left=0, top=0, right=0, bottom=0} boundingRect={Bounds=[Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0)]} cutoutPathParserInfo={CutoutPathParserInfo{displayWidth=0 displayHeight=0 physicalDisplayWidth=0 physicalDisplayHeight=0 density={0.0} cutoutSpec={} rotation={0} scale={0.0} physicalPixelDisplaySizeRatio={0.0}}} sideOverrides=null}, mRoundedCorners=RoundedCorners{[RoundedCorner{position=TopLeft, radius=9, center=Point(9, 9)}, RoundedCorner{position=TopRight, radius=9, center=Point(791, 9)}, RoundedCorner{position=BottomRight, radius=9, center=Point(791, 1331)}, RoundedCorner{position=BottomLeft, radius=9, center=Point(9, 1331)}]}  mRoundedCornerFrame=Rect(0, 0 - 800, 1340), mPrivacyIndicatorBounds=PrivacyIndicatorBounds {static bounds=Rect(742, 0 - 800, 32) rotation=0}, mDisplayShape=DisplayShape{ spec=-311912193 displayWidth=800 displayHeight=1340 physicalPixelDisplaySizeRatio=1.0 rotation=0 offsetX=0 offsetY=0 scale=1.0}, mSources= { InsetsSource: {b90e0000 mType=statusBars mFrame=[0,0][800,32] mVisible=true mFlags= mSideHint=TOP mBoundingRects=null}, InsetsSource: {b90e0005 mType=mandatorySystemGestures mFrame=[0,0][800,32] mVisible=true mFlags= mSideHint=TOP mBoundingRects=null}, InsetsSource: {b90e0006 mType=tappableElement mFrame=[0,0][800,32] mVisible=true mFlags= mSideHint=TOP mBoundingRects=null}, InsetsSource: {3 mType=ime mFrame=[0,898][800,1340] mVisible=false mFlags= mSideHint=BOTTOM mBoundingRects=null}, InsetsSource: {494d0001 mType=navigationBars mFrame=[0,1276][800,1340] mVisible=true mFlags= mSideHint=BOTTOM mBoundingRects=null}, InsetsSource: {494d0004 mType=systemGestures mFrame=[0,0][0,0] mVisible=true mFlags= mSideHint=NONE mBoundingRects=null}, InsetsSource: {494d0005 mType=mandatorySystemGestures mFrame=[0,1276][800,1340] mVisible=true mFlags= mSideHint=BOTTOM mBoundingRects=null}, InsetsSource: {494d0006 mType=tappableElement mFrame=[0,1276][800,1340] mVisible=true mFlags= mSideHint=BOTTOM mBoundingRects=null}, InsetsSource: {494d0024 mType=systemGestures mFrame=[0,0][0,0] mVisible=true mFlags= mSideHint=NONE mBoundingRects=null} }  \nI/InsetsSourceConsumer( 9614): applyRequestedVisibilityToControl: visible=true, type=navigationBars, host=com.example.family_finances/com.example.family_finances.MainActivity\nI/VRI[MainActivity]@3e78383( 9614): handleResized, frames=ClientWindowFrames{frame=[0,0][800,1340] display=[0,0][800,1340] parentFrame=[0,0][0,0]} displayId=0 dragResizing=false compatScale=1.0 frameChanged=false attachedFrameChanged=false configChanged=false displayChanged=false compatScaleChanged=false dragResizingChanged=false\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ec1a00 mBlastBufferQueue=0xb4000074919bbc00 fn= 306 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ec1700 mBlastBufferQueue=0xb4000074919bbc00 fn= 307 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073cbf86e00 mBlastBufferQueue=0xb4000074919bbc00 fn= 308 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000075ee1cf800 mBlastBufferQueue=0xb4000074919bbc00 fn= 309 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000075259b5400 mBlastBufferQueue=0xb4000074919bbc00 fn= 310 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2a8c800 mBlastBufferQueue=0xb4000074919bbc00 fn= 311 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ebf480 mBlastBufferQueue=0xb4000074919bbc00 fn= 312 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ebf900 mBlastBufferQueue=0xb4000074919bbc00 fn= 313 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2d25e00 mBlastBufferQueue=0xb4000074919bbc00 fn= 314 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ec0f80 mBlastBufferQueue=0xb4000074919bbc00 fn= 315 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ec1100 mBlastBufferQueue=0xb4000074919bbc00 fn= 316 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ec1400 mBlastBufferQueue=0xb4000074919bbc00 fn= 317 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ec1280 mBlastBufferQueue=0xb4000074919bbc00 fn= 318 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ec1880 mBlastBufferQueue=0xb4000074919bbc00 fn= 319 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2ec1a00 mBlastBufferQueue=0xb4000074919bbc00 fn= 320 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073cbf87280 mBlastBufferQueue=0xb4000074919bbc00 fn= 321 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000075ee1cf800 mBlastBufferQueue=0xb4000074919bbc00 fn= 322 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/InsetsController( 9614): cancelAnimation: types=ime, animType=1, host=com.example.family_finances/com.example.family_finances.MainActivity, from=android.view.InsetsController.notifyFinished:1890 android.view.InsetsAnimationControlImpl.applyChangeInsets:307 android.view.InsetsController.lambda$new$3:932\nI/ImeTracker( 9614): com.example.family_finances:9d120203: onRequestHide at ORIGIN_CLIENT reason HIDE_SOFT_INPUT_ON_ANIMATION_STATE_CHANGED fromUser false\nI/InputMethodManager_LC( 9614): notifyImeHidden: IInputMethodManagerGlobalInvoker.hideSoftInput\nI/ImeTracker( 9614): com.example.family_finances:c65872b8: onHidden\nI/VRI[MainActivity]@3e78383( 9614): mWNT: t=0xb4000073d2a8c800 mBlastBufferQueue=0xb4000074919bbc00 fn= 323 HdrRenderState mRenderHdrSdrRatio=1.0 caller= android.view.SyncRtSurfaceTransactionApplier.applyTransaction:96 android.view.SyncRtSurfaceTransactionApplier.lambda$scheduleApply$0:69 android.view.SyncRtSurfaceTransactionApplier.$r8$lambda$afI4fXg3U3-nBZQEDQMiNy-B06s:0\nI/InsetsController( 9614): onStateChanged: host=com.example.family_finances/com.example.family_finances.MainActivity, from=android.view.ViewRootImpl.handleResized:2789, state=InsetsState: {mDisplayFrame=Rect(0, 0 - 800, 1340), mDisplayCutout=DisplayCutout{insets=Rect(0, 0 - 0, 0) waterfall=Insets{left=0, top=0, right=0, bottom=0} boundingRect={Bounds=[Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0)]} cutoutPathParserInfo={CutoutPathParserInfo{displayWidth=0 displayHeight=0 physicalDisplayWidth=0 physicalDisplayHeight=0 density={0.0} cutoutSpec={} \nrotation={0} scale={0.0} physicalPixelDisplaySizeRatio={0.0}}} sideOverrides=null}, mRoundedCorners=RoundedCorners{[RoundedCorner{position=TopLeft, radius=9, center=Point(9, 9)}, RoundedCorner{position=TopRight, radius=9, center=Point(791, 9)}, RoundedCorner{position=BottomRight, radius=9, center=Point(791, 1331)}, RoundedCorner{position=BottomLeft, radius=9, center=Point(9, 1331)}]}  mRoundedCornerFrame=Rect(0, 0 - 800, 1340), mPrivacyIndicatorBounds=PrivacyIndicatorBounds {static bounds=Rect(742, 0 - 800, 32) rotation=0}, mDisplayShape=DisplayShape{ spec=-311912193 displayWidth=800 displayHeight=1340 physicalPixelDisplaySizeRatio=1.0 rotation=0 offsetX=0 offsetY=0 scale=1.0}, mSources= { InsetsSource: {b90e0000 mType=statusBars mFrame=[0,0][800,32] mVisible=true mFlags= mSideHint=TOP mBoundingRects=null}, InsetsSource: {b90e0005 mType=mandatorySystemGestures mFrame=[0,0][800,32] mVisible=true mFlags= mSideHint=TOP mBoundingRects=null}, InsetsSource: {b90e0006 mType=tappableElement mFrame=[0,0][800,32] mVisible=true mFlags= mSideHint=TOP mBoundingRects=null}, InsetsSource: {3 mType=ime mFrame=[0,0][0,0] mVisible=false mFlags= mSideHint=NONE \nmBoundingRects=null}, InsetsSource: {494d0001 mType=navigationBars mFrame=[0,1276][800,1340] mVisible=true mFlags= mSideHint=BOTTOM mBoundingRects=null}, InsetsSource: {494d0004 mType=systemGestures mFrame=[0,0][0,0] mVisible=true mFlags= mSideHint=NONE mBoundingRects=null}, InsetsSource: {494d0005 mType=mandatorySystemGestures mFrame=[0,1276][800,1340] mVisible=true mFlags= mSideHint=BOTTOM mBoundingRects=null}, InsetsSource: {494d0006 mType=tappableElement mFrame=[0,1276][800,1340] mVisible=true mFlags= mSideHint=BOTTOM mBoundingRects=null}, InsetsSource: {494d0024 mType=systemGestures mFrame=[0,0][0,0] mVisible=true mFlags= mSideHint=NONE mBoundingRects=null} }\nI/VRI[MainActivity]@3e78383( 9614): handleResized, frames=ClientWindowFrames{frame=[0,0][800,1340] display=[0,0][800,1340] parentFrame=[0,0][0,0]} displayId=0 dragResizing=false compatScale=1.0 frameChanged=false attachedFrameChanged=false configChanged=false displayChanged=false compatScaleChanged=false dragResizingChanged=false\nI/VRI[MainActivity]@3e78383( 9614): call setFrameRateCategory for touch hint category=no preference, reason=boost timeout, vri=VRI[MainActivity]@3e78383\n",
    "models": {
        "app_categories.dart": "import 'package:flutter/material.dart';\n\nimport 'expense_category.dart';\nimport 'receipt_category.dart';\n\nclass AppCategories {\n  static const List<ExpenseCategory> expenseCategories = [\n    ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n  ];\n\n  static const List<ReceiptCategory> receiptCategories = [\n    ReceiptCategory(name: 'Salário', icon: Icons.monetization_on),\n    ReceiptCategory(name: 'Presente', icon: Icons.card_giftcard),\n    ReceiptCategory(name: 'Investimento', icon: Icons.trending_up),\n    ReceiptCategory(name: 'Outros', icon: Icons.add_circle_outline),\n  ];\n}",
        "expense.dart": "// lib/models/expense.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:flutter/material.dart';\nimport 'expense_category.dart';\n\nclass Expense {\n  final String? id; // Firestore document ID (nullable)\n  final int? localId; // SQLite autoincrement ID (nullable)\n  final String title;\n  final double value;\n  final ExpenseCategory category;\n  final String note;\n  final DateTime date;\n  final bool isRecurrent;\n  final int? recurrencyId;\n  final int? recurrencyType;\n  final int? recurrentIntervalDays;\n  final bool isInInstallments;\n  final int? installmentCount;\n  final bool isShared;\n\n  Expense({\n    this.id,\n    this.localId,\n    required this.title,\n    required this.value,\n    required this.category,\n    required this.note,\n    required this.date,\n    required this.isRecurrent,\n    this.recurrencyId,\n    this.recurrencyType,\n    this.recurrentIntervalDays,\n    required this.isInInstallments,\n    this.installmentCount,\n    this.isShared = false,\n  });\n\n  bool get isFuture => date.isAfter(DateTime.now());\n\n  /// Cria a partir de um mapa do Firestore. `id` é o documentId passado separadamente.\n  static Expense fromMap(Map<String, dynamic> map, {String? id}) {\n    \n    // --- CORREÇÃO AQUI: Verificação de segurança para a categoria ---\n    ExpenseCategory parsedCategory;\n    try {\n      if (map['category'] != null && map['category'] is Map) {\n        parsedCategory = ExpenseCategory.fromMapFromFirestore(Map<String, dynamic>.from(map['category']));\n      } else {\n        // Se for null ou inválido, usa a categoria padrão (Outros)\n        parsedCategory = ExpenseCategory.defaults[0]; \n      }\n    } catch (e) {\n      parsedCategory = ExpenseCategory.defaults[0];\n    }\n    // ----------------------------------------------------------------\n\n    return Expense(\n      id: id,\n      localId: null,\n      title: map['title'] ?? '',\n      value: (map['value'] is num) ? (map['value'] as num).toDouble() : 0.0,\n      category: parsedCategory, // Usa a variável tratada acima\n      note: map['note'] ?? '',\n      date: (map['date'] is Timestamp)\n          ? (map['date'] as Timestamp).toDate()\n          : DateTime.tryParse(map['date']?.toString() ?? '') ?? DateTime.now(),\n      isRecurrent: map['is_recurrent'] ?? map['isRecurrent'] ?? false,\n      recurrencyId: map['recurrency_id'] ?? map['recurrencyId'],\n      recurrencyType: map['recurrency_type'] ?? map['recurrencyType'],\n      recurrentIntervalDays: map['recurrent_interval_days'] ?? map['recurrentIntervalDays'],\n      isInInstallments: map['is_in_installments'] ?? map['isInInstallments'] ?? false,\n      installmentCount: map['installment_count'] ?? map['installmentCount'],\n      isShared: map['isShared'] ?? false,\n    );\n  }\n\n  /// Map usado para enviar para o Firestore\n  Map<String, dynamic> toMap() {\n    return {\n      'title': title,\n      'value': value,\n      'category': category.toMapForFirestore(),\n      'note': note,\n      'date': Timestamp.fromDate(date),\n      'is_recurrent': isRecurrent,\n      'recurrency_id': recurrencyId,\n      'recurrency_type': recurrencyType,\n      'recurrent_interval_days': recurrentIntervalDays,\n      'is_in_installments': isInInstallments,\n      'installment_count': installmentCount,\n      'isShared': isShared,\n    };\n  }\n\n  /// Map para armazenar no SQLite (use as chaves existentes no schema)\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      // 'id' aqui é o Firestore ID (nullable) — não confundir com localId\n      'id': id,\n      'title': title,\n      'value': value,\n      'category': category.toMapForSqlite(), // Isso pode precisar de ajuste dependendo de como o SQLite salva\n      'note': note,\n      'date': date.toIso8601String(),\n      'isRecurrent': isRecurrent ? 1 : 0,\n      'recurrencyId': recurrencyId,\n      'recurrencyType': recurrencyType,\n      'recurrentIntervalDays': recurrentIntervalDays,\n      'isInInstallments': isInInstallments ? 1 : 0,\n      'installmentCount': installmentCount,\n      'isShared': isShared ? 1 : 0,\n      'sharedFromUid': null,\n    };\n  }\n\n  /// Constrói a partir de um row do SQLite (Map resultante do db.query)\n  factory Expense.fromMapForSqlite(Map<String, dynamic> map) {\n    final localId = map['localId'] is int\n        ? map['localId'] as int\n        : (map['localId'] != null ? int.tryParse(map['localId'].toString()) : null);\n\n    return Expense(\n      id: map['id']?.toString(),\n      localId: localId,\n      title: map['title']?.toString() ?? '',\n      value: (map['value'] is num) ? (map['value'] as num).toDouble() : double.tryParse(map['value']?.toString() ?? '') ?? 0.0,\n      // Assumindo que o SQLite retorna os campos da categoria ou um join\n      category: ExpenseCategory.fromMapForSqlite(map['category'] ?? map), \n      note: map['note']?.toString() ?? '',\n      date: DateTime.tryParse(map['date']?.toString() ?? '') ?? DateTime.now(),\n      isRecurrent: (map['isRecurrent'] ?? 0) == 1,\n      recurrencyId: map['recurrencyId'] is int ? map['recurrencyId'] as int : (map['recurrencyId'] != null ? int.tryParse(map['recurrencyId'].toString()) : null),\n      recurrencyType: map['recurrencyType'] is int ? map['recurrencyType'] as int : (map['recurrencyType'] != null ? int.tryParse(map['recurrencyType'].toString()) : null),\n      recurrentIntervalDays: map['recurrentIntervalDays'] is int ? map['recurrentIntervalDays'] as int : (map['recurrentIntervalDays'] != null ? int.tryParse(map['recurrentIntervalDays'].toString()) : null),\n      isInInstallments: (map['isInInstallments'] ?? 0) == 1,\n      installmentCount: map['installmentCount'] is int ? map['installmentCount'] as int : (map['installmentCount'] != null ? int.tryParse(map['installmentCount'].toString()) : null),\n      isShared: (map['isShared'] ?? 0) == 1,\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() => toMap();\n\n  factory Expense.fromMapFromFirestore(Map<String, dynamic> map, String id) => fromMap(map, id: id);\n\n  Expense copyWith({\n    String? id,\n    int? localId,\n    String? title,\n    double? value,\n    ExpenseCategory? category,\n    String? note,\n    DateTime? date,\n    bool? isRecurrent,\n    int? recurrencyId,\n    int? recurrencyType,\n    int? recurrentIntervalDays,\n    bool? isInInstallments,\n    int? installmentCount,\n    bool? isShared,\n  }) {\n    return Expense(\n      id: id ?? this.id,\n      localId: localId ?? this.localId,\n      title: title ?? this.title,\n      value: value ?? this.value,\n      category: category ?? this.category,\n      note: note ?? this.note,\n      date: date ?? this.date,\n      isRecurrent: isRecurrent ?? this.isRecurrent,\n      recurrencyId: recurrencyId ?? this.recurrencyId,\n      recurrencyType: recurrencyType ?? this.recurrencyType,\n      recurrentIntervalDays: recurrentIntervalDays ?? this.recurrentIntervalDays,\n      isInInstallments: isInInstallments ?? this.isInInstallments,\n      installmentCount: installmentCount ?? this.installmentCount,\n      isShared: isShared ?? this.isShared,\n    );\n  }\n}",
        "expense_category.dart": "//lib/models/expense_category.dart\nimport 'package:flutter/material.dart';\n\nclass ExpenseCategory {\n  final String name;\n  final IconData icon;\n\n  const ExpenseCategory({required this.name, required this.icon});\n\n  static List<ExpenseCategory> defaults = [\n    ExpenseCategory(name: 'Outros', icon: Icons.category),\n    ExpenseCategory(name: 'Alimentação', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Casa', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n  ];\n\n  static ExpenseCategory defaultCategory = defaults[0];\n\n  static List<ExpenseCategory> allCategories() => [...defaults];\n\n\n  @override\n  bool operator ==(Object other) {\n    if (identical(this, other)) return true;\n    return other is ExpenseCategory && other.name == name && other.icon == icon;\n  }\n\n  @override\n  int get hashCode => Object.hash(name, icon);\n\n  static ExpenseCategory fromMapFromFirestore(Map<String, dynamic> map) {\n    return ExpenseCategory(\n      name: map['name'] ?? 'Desconhecida',\n      icon: IconData(\n        map['icon'] ?? Icons.label_outline.codePoint,\n        fontFamily: Icons.label_outline.fontFamily,\n      ),\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'icon': icon.codePoint,\n    };\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'name': name,\n      'icon': icon.codePoint,\n    };\n  }\n\n  static ExpenseCategory fromMapForSqlite(Map<String, dynamic> map) {\n    return ExpenseCategory(\n      name: map['name'] ?? 'Desconhecida',\n      icon: IconData(\n        map['icon'] ?? Icons.label_outline.codePoint,\n        fontFamily: Icons.label_outline.fontFamily,\n      ),\n    );\n  }\n  \n\n  \n}",
        "finance_state.dart": "import 'dart:async';\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\n\nimport '../database_helper.dart';\nimport '../services/firestore_service.dart';\nimport '../services/gemini_service.dart';\n\nimport 'expense.dart';\nimport 'receipt.dart';\nimport 'product.dart';\nimport 'product_category.dart';\nimport 'expense_category.dart';\nimport 'nfce.dart';\nimport 'partnership.dart';\n\nclass FinanceState with ChangeNotifier {\n  final DatabaseHelper _databaseHelper = DatabaseHelper.instance;\n  FirestoreService? _firestoreService;\n  late GeminiService _geminiService;\n\n  StreamSubscription<List<Expense>>? _expensesPrivateSub;\n  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _expensesSharedSub;\n\n  StreamSubscription<List<Receipt>>? _receiptsPrivateSub;\n  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _receiptsSharedSub;\n\n  StreamSubscription<List<Product>>? _productsPrivateSub;\n  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _productsSharedSub;\n\n  StreamSubscription<List<ProductCategory>>? _categoriesPrivateSub;\n  StreamSubscription<QuerySnapshot<Map<String, dynamic>>>? _categoriesSharedSub;\n  \n  StreamSubscription<DocumentSnapshot>? _partnershipSnapSub;\n\n  String? _uid;\n  bool _isLoading = true;\n\n  String? _activePartnershipId;\n  String? _activeSharedCollectionId;\n\n  String get currentPartnerId => _activePartnershipId ?? '';\n\n  String? _userName;\n  String? _partnerName;\n  \n  // Getters\n  String? get userName => _userName;\n  String? get partnerName => _partnerName;\n\n  List<Expense> _expensesPrivate = [];\n  List<Expense> _expensesShared = [];\n\n  List<Receipt> _receiptsPrivate = [];\n  List<Receipt> _receiptsShared = [];\n\n  List<Product> _productsPrivate = [];\n  List<Product> _productsShared = [];\n\n  List<ProductCategory> _categoriesPrivate = [];\n  List<ProductCategory> _categoriesShared = [];\n\n  final List<ExpenseCategory> _expenseCategories = [\n    ExpenseCategory(name: 'Compras', icon: Icons.shopping_cart),\n    ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n    ExpenseCategory(name: 'Outros', icon: Icons.category),\n  ];\n\n  FinanceState() {\n    _geminiService = GeminiService();\n    FirebaseAuth.instance.authStateChanges().listen(_handleAuth);\n    _handleAuth(FirebaseAuth.instance.currentUser);\n  }\n\n  bool get isLoggedIn => _uid != null;\n  bool get hasPartnership => _activeSharedCollectionId != null;\n\n  bool get isLoading => _isLoading;\n\n  List<Expense> get expenses {\n    final merged = [..._expensesPrivate, ..._expensesShared];\n    merged.sort((a, b) => b.date.compareTo(a.date));\n    return merged;\n  }\n\n  List<Receipt> get receipts {\n    final merged = [..._receiptsPrivate, ..._receiptsShared];\n    merged.sort((a, b) => b.date.compareTo(a.date));\n    return merged;\n  }\n\n  List<Product> get shoppingListProducts {\n    final merged = [..._productsPrivate, ..._productsShared];\n    merged.sort((a, b) => a.name.toLowerCase().compareTo(b.name.toLowerCase()));\n    return merged;\n  }\n\n  List<ProductCategory> get productCategories {\n    final merged = [\n      ProductCategory.indefinida,\n      ..._categoriesPrivate,\n      ..._categoriesShared\n    ];\n    return merged;\n  }\n\n  List<ExpenseCategory> get expenseCategories => _expenseCategories;\n\n  void _handleAuth(User? user) {\n    if (user != null && _uid != user.uid) {\n      _uid = user.uid;\n      _initializeCloud(user.uid);\n    } else if (user == null && _uid != null) {\n      _uid = null;\n      _clearCloud();\n      _initializeLocal();\n    } else if (user == null && _uid == null) {\n      _initializeLocal();\n    }\n  }\n\n  Future<void> _clearCloud() async {\n    await _expensesPrivateSub?.cancel();\n    await _expensesSharedSub?.cancel();\n    await _receiptsPrivateSub?.cancel();\n    await _receiptsSharedSub?.cancel();\n    await _productsPrivateSub?.cancel();\n    await _productsSharedSub?.cancel();\n    await _categoriesPrivateSub?.cancel();\n    await _categoriesSharedSub?.cancel();\n    await _partnershipSnapSub?.cancel();\n\n    _expensesPrivateSub = null;\n    _expensesSharedSub = null;\n    _receiptsPrivateSub = null;\n    _receiptsSharedSub = null;\n    _productsPrivateSub = null;\n    _productsSharedSub = null;\n    _categoriesPrivateSub = null;\n    _categoriesSharedSub = null;\n    _partnershipSnapSub = null;\n\n    _activePartnershipId = null;\n    _activeSharedCollectionId = null;\n  }\n\n  Future<void> _initializeLocal() async {\n    _isLoading = true;\n    notifyListeners();\n\n    _expensesPrivate = await _databaseHelper.getAllExpenses();\n    _receiptsPrivate = await _databaseHelper.getAllReceipts();\n    _categoriesPrivate = await _databaseHelper.getAllProductCategories();\n    _productsPrivate = await _databaseHelper.getAllProducts();\n\n    _expensesShared = [];\n    _receiptsShared = [];\n    _productsShared = [];\n    _categoriesShared = [];\n\n    _isLoading = false;\n    notifyListeners();\n  }\n\n  void _initializeCloud(String uid) {\n    _isLoading = true;\n    notifyListeners();\n\n    _firestoreService = FirestoreService(uid: uid);\n\n    // 1. Carrega o nome do usuário atual\n    _firestoreService!.getUserName(uid).then((name) {\n      _userName = name;\n      notifyListeners();\n    });\n\n    _partnershipSnapSub = FirebaseFirestore.instance\n        .collection('partnerships')\n        .doc(uid)\n        .snapshots()\n        .listen(_handlePartnershipSnapshot, onError: (_) {});\n\n    _subscribePrivateCollections();\n\n    Future.delayed(const Duration(milliseconds: 300), () {\n      _isLoading = false;\n      notifyListeners();\n    });\n  }\n\n  void _handlePartnershipSnapshot(DocumentSnapshot snap) {\n    if (!snap.exists) {\n      _activePartnershipId = null;\n      _activeSharedCollectionId = null;\n      _partnerName = null; // Limpa nome do parceiro\n      _unsubscribeSharedCollections();\n      _clearShared();\n      notifyListeners();\n      return;\n    }\n\n    final data = snap.data() as Map<String, dynamic>;\n    final sharedId = data['sharedCollectionId'];\n    final partnerId = data['partnerId']; // Pega o ID do parceiro\n    final pid = snap.id;\n\n    if (_activeSharedCollectionId == sharedId) return;\n\n    _activePartnershipId = pid;\n    _activeSharedCollectionId = sharedId;\n\n    // 2. Busca o nome do parceiro se tivermos o ID dele\n    if (partnerId != null && _firestoreService != null) {\n      _firestoreService!.getUserName(partnerId).then((name) {\n        _partnerName = name;\n        notifyListeners();\n      });\n    }\n\n    _subscribeSharedCollections();\n  }\n\n  void _subscribePrivateCollections() {\n    _expensesPrivateSub = _firestoreService!.getExpensesStream().listen((d) {\n      _expensesPrivate = d;\n      notifyListeners();\n    });\n\n    _receiptsPrivateSub = _firestoreService!.getReceiptsStream().listen((d) {\n      _receiptsPrivate = d;\n      notifyListeners();\n    });\n\n    _productsPrivateSub = _firestoreService!.getProductsStream().listen((d) {\n      _productsPrivate = d;\n      notifyListeners();\n    });\n\n    _categoriesPrivateSub =\n        _firestoreService!.getCategoriesStream().listen((d) {\n      _categoriesPrivate = d;\n      notifyListeners();\n    });\n  }\n\n  void _subscribeSharedCollections() {\n    if (_activeSharedCollectionId == null) return;\n\n    final base = FirebaseFirestore.instance\n        .collection('partnerships')\n        .doc(_activePartnershipId)\n        .collection('shared');\n\n    _expensesSharedSub = base\n        .doc('expenses')\n        .collection('items')\n        .snapshots()\n        .listen((snap) {\n      _expensesShared = snap.docs\n          .map((doc) =>\n              Expense.fromMapFromFirestore(doc.data(), doc.id))\n          .toList();\n      notifyListeners();\n    });\n\n    _receiptsSharedSub = base\n        .doc('receipts')\n        .collection('items')\n        .snapshots()\n        .listen((snap) {\n      _receiptsShared = snap.docs\n          .map((doc) =>\n              Receipt.fromMapFromFirestore(doc.data(), doc.id))\n          .toList();\n      notifyListeners();\n    });\n\n    _productsSharedSub = base\n        .doc('products')\n        .collection('items')\n        .snapshots()\n        .listen((snap) {\n      _productsShared = snap.docs\n          .map((doc) =>\n              Product.fromMapFromFirestore(doc.data(), doc.id))\n          .toList();\n      notifyListeners();\n    });\n\n    _categoriesSharedSub = base\n        .doc('productCategories')\n        .collection('items')\n        .snapshots()\n        .listen((snap) {\n      _categoriesShared = snap.docs\n          .map((doc) => ProductCategory.fromMapFromFirestore(\n              doc.data(), doc.id))\n          .toList();\n      notifyListeners();\n    });\n  }\n\n  void _unsubscribeSharedCollections() async {\n    await _expensesSharedSub?.cancel();\n    await _receiptsSharedSub?.cancel();\n    await _productsSharedSub?.cancel();\n    await _categoriesSharedSub?.cancel();\n\n    _expensesSharedSub = null;\n    _receiptsSharedSub = null;\n    _productsSharedSub = null;\n    _categoriesSharedSub = null;\n  }\n\n  void _clearShared() {\n    _expensesShared = [];\n    _receiptsShared = [];\n    _productsShared = [];\n    _categoriesShared = [];\n  }\n\n  Future<void> addExpense(Expense e) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('expenses')\n          .collection('items');\n      await base.add(e.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.addExpense(e);\n    } else {\n      final newE = await _databaseHelper.createExpense(e);\n      _expensesPrivate.insert(0, newE.copyWith(localId: newE.localId));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateExpense(Expense e) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('expenses')\n          .collection('items');\n      await base.doc(e.id).update(e.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.updateExpense(e);\n    } else {\n      await _databaseHelper.updateExpense(e);\n      _expensesPrivate = await _databaseHelper.getAllExpenses();\n      notifyListeners();\n    }\n  }\n\n  Future<void> deleteExpense(String id) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('expenses')\n          .collection('items');\n      await base.doc(id).delete();\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.deleteExpense(id);\n    } else {\n      final lid = int.tryParse(id);\n      if (lid == null) return;\n      await _databaseHelper.deleteExpense(lid);\n      _expensesPrivate.removeWhere((e) => e.localId == lid);\n      notifyListeners();\n    }\n  }\n\n  Future<void> addReceipt(Receipt r) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('receipts')\n          .collection('items');\n      await base.add(r.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.addReceipt(r);\n    } else {\n      final newR = await _databaseHelper.createReceipt(r);\n      _receiptsPrivate.insert(0, newR.copyWith(localId: newR.localId));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateReceipt(Receipt r) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('receipts')\n          .collection('items');\n      await base.doc(r.id).update(r.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.updateReceipt(r);\n    } else {\n      await _databaseHelper.updateReceipt(r);\n      _receiptsPrivate = await _databaseHelper.getAllReceipts();\n      notifyListeners();\n    }\n  }\n\n  Future<void> deleteReceipt(String id) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('receipts')\n          .collection('items');\n      await base.doc(id).delete();\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.deleteReceipt(id);\n    } else {\n      final lid = int.tryParse(id);\n      if (lid == null) return;\n      await _databaseHelper.deleteReceipt(lid);\n      _receiptsPrivate.removeWhere((e) => e.localId == lid);\n      notifyListeners();\n    }\n  }\n\n  Future<void> addProduct(Product p) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('products')\n          .collection('items');\n      await base.add(p.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.addProduct(p);\n    } else {\n      final newP = await _databaseHelper.createProduct(p);\n      _productsPrivate.add(newP.copyWith(localId: newP.localId));\n      notifyListeners();\n    }\n  }\n\n  Future<void> updateProduct(Product p) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('products')\n          .collection('items');\n      await base.doc(p.id).update(p.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.updateProduct(p);\n    } else {\n      await _databaseHelper.updateProduct(p);\n      _productsPrivate = await _databaseHelper.getAllProducts();\n      notifyListeners();\n    }\n  }\n\n  Future<void> deleteProduct(String id) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('products')\n          .collection('items');\n      await base.doc(id).delete();\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.deleteProduct(id);\n    } else {\n      final lid = int.tryParse(id);\n      if (lid == null) return;\n      await _databaseHelper.deleteProduct(lid);\n      _productsPrivate.removeWhere((p) => p.localId == lid);\n      notifyListeners();\n    }\n  }\n\n  Future<void> toggleProductChecked(Product p, bool val) async {\n    final updated = p.copyWith(isChecked: val);\n\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('products')\n          .collection('items');\n      await base.doc(p.id).update(updated.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.updateProduct(updated);\n    } else {\n      await _databaseHelper.updateProduct(updated);\n      final idx =\n          _productsPrivate.indexWhere((e) => e.localId == updated.localId);\n      if (idx != -1) {\n        _productsPrivate[idx] = updated;\n      }\n      notifyListeners();\n    }\n  }\n\n  Future<void> addProductCategory(ProductCategory c) async {\n    if (hasPartnership) {\n      final base = FirebaseFirestore.instance\n          .collection('partnerships')\n          .doc(_activePartnershipId)\n          .collection('shared')\n          .doc('productCategories')\n          .collection('items');\n      await base.add(c.toMapForFirestore());\n    } else if (isLoggedIn && _firestoreService != null) {\n      await _firestoreService!.addProductCategory(c);\n    } else {\n      await _databaseHelper.createProductCategory(c);\n      _categoriesPrivate.add(c);\n      notifyListeners();\n    }\n  }\n\n  Future<void> processNfceItems(Nfce nfce) async {}\n\n  double get totalReceitas =>\n      receipts.fold(0.0, (s, x) => s + x.value);\n\n  double get totalDespesas =>\n      expenses.fold(0.0, (s, x) => s + x.value);\n\n  double get totalReceitasAtuais =>\n      receipts.where((x) => !x.isFuture).fold(0.0, (s, x) => s + x.value);\n\n  double get totalDespesasAtuais =>\n      expenses.where((x) => !x.isFuture).fold(0.0, (s, x) => s + x.value);\n\n  double get saldoAtual => totalReceitasAtuais - totalDespesasAtuais;\n\n  void forceNotify() => notifyListeners();\n\n  Future<void> updateDisplayName(String newName) async {\n    if (_firestoreService != null) {\n      await _firestoreService!.updateUserName(newName);\n      _userName = newName;\n      notifyListeners();\n    }\n  }\n}\n",
        "nfce.dart": "// lib/models/nfce.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'nfce_item_detail.dart';\n\nclass Nfce {\n  final String? id;\n  final String nfceKey;\n  final String storeName;\n  final double totalValue;\n  final Timestamp date;\n  final String taxInfo;\n  final List<NfceItemDetail> items;\n\n  Nfce({\n    this.id,\n    required this.nfceKey,\n    required this.storeName,\n    required this.totalValue,\n    required this.date,\n    required this.taxInfo,\n    required this.items,\n  });\n\n  Map<String, dynamic> toMap() {\n    return {\n      'nfceKey': nfceKey,\n      'storeName': storeName,\n      'totalValue': totalValue,\n      'date': date,\n      'taxInfo': taxInfo,\n      'items': items.map((e) => e.toMap()).toList(),\n    };\n  }\n\n  factory Nfce.fromMap(Map<String, dynamic> map, String id) {\n    final itemsList = (map['items'] as List? ?? [])\n        .map((e) => NfceItemDetail.fromMap(e))\n        .toList();\n\n    return Nfce(\n      id: id,\n      nfceKey: map['nfceKey'],\n      storeName: map['storeName'],\n      totalValue: (map['totalValue'] as num).toDouble(),\n      date: map['date'] ?? Timestamp.now(),\n      taxInfo: map['taxInfo'],\n      items: itemsList,\n    );\n  }\n}\n",
        "nfce_item_detail.dart": "// lib/models/nfce_item_detail.dart\nclass NfceItemDetail {\n  final String name;\n  final double quantity;\n  final double unitPrice;\n  final double totalPrice;\n\n  NfceItemDetail({\n    required this.name,\n    required this.quantity,\n    required this.unitPrice,\n    required this.totalPrice,\n  });\n\n  Map<String, dynamic> toMap() {\n    return {\n      'name': name,\n      'quantity': quantity,\n      'unitPrice': unitPrice,\n      'totalPrice': totalPrice,\n    };\n  }\n\n  factory NfceItemDetail.fromMap(Map<String, dynamic> map) {\n    return NfceItemDetail(\n      name: map['name'],\n      quantity: (map['quantity'] as num).toDouble(),\n      unitPrice: (map['unitPrice'] as num).toDouble(),\n      totalPrice: (map['totalPrice'] as num).toDouble(),\n    );\n  }\n}\n",
        "partnership.dart": "// lib/models/partnership.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nclass Partnership {\n  final String id;\n  final String user1Id;\n  final String user2Id;\n  final String sharedCollectionId;\n\n  Partnership({\n    required this.id,\n    required this.user1Id,\n    required this.user2Id,\n    required this.sharedCollectionId,\n  });\n\n  static String createId(String a, String b) =>\n      (a.compareTo(b) < 0) ? '$a _ $b' : '$b _ $a';\n\n  factory Partnership.fromMap(Map<String, dynamic> map, String id) {\n    return Partnership(\n      id: id,\n      user1Id: map['user1Id'],\n      user2Id: map['user2Id'],\n      sharedCollectionId: map['sharedCollectionId'],\n    );\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'user1Id': user1Id,\n      'user2Id': user2Id,\n      'sharedCollectionId': sharedCollectionId,\n      'createdAt': Timestamp.now(),\n    };\n  }\n}\n\nclass PartnershipInvite {\n  final String id;\n  final String senderId;\n  final String receiverId;\n  final Timestamp sentAt;\n\n  PartnershipInvite({\n    required this.id,\n    required this.senderId,\n    required this.receiverId,\n    required this.sentAt,\n  });\n\n  factory PartnershipInvite.fromMap(Map<String, dynamic> map, String id) {\n    return PartnershipInvite(\n      id: id,\n      senderId: map['senderId'],\n      receiverId: map['receiverId'],\n      sentAt: map['sentAt'] ?? Timestamp.now(),\n    );\n  }\n\n  Map<String, dynamic> toMap() {\n    return {\n      'senderId': senderId,\n      'receiverId': receiverId,\n      'sentAt': sentAt,\n    };\n  }\n}\n",
        "product.dart": "// lib/models/product.dart\nimport 'dart:convert';\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nimport 'product_category.dart';\nimport 'product_option.dart';\n\nclass Product {\n  final String? id;\n  final int? localId;\n  final String name;\n  final ProductCategory category;\n  final List<ProductOption> options;\n  final bool isChecked;\n  final int? priority;\n\n  String get nameLower => name.toLowerCase();\n@override\nbool operator ==(Object other) {\n  if (identical(this, other)) return true;\n\n  return other is Product &&\n      nameLower == other.nameLower;\n}\n \n  Product({\n    this.id,\n    this.localId,\n    required this.name,\n    required this.category,\n    this.options = const [],\n    this.isChecked = false,\n    this.priority,\n  });\n\n  Product copyWith({\n    String? id,\n    int? localId,\n    String? name,\n    ProductCategory? category,\n    List<ProductOption>? options,\n    bool? isChecked,\n    int? priority,\n  }) {\n    return Product(\n      id: id ?? this.id,\n      localId: localId ?? this.localId,\n      name: name ?? this.name,\n      category: category ?? this.category,\n      options: options ?? List<ProductOption>.from(this.options),\n      isChecked: isChecked ?? this.isChecked,\n      priority: priority ?? this.priority,\n    );\n    }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'category': category.toMapForFirestore(),\n      'options': options.map((o) => o.toMap()).toList(),\n      'isChecked': isChecked,\n      'priority': priority,\n    };\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': id,\n      'name': name,\n      'category': category.toMapForSqlite(),\n      'optionsJson': ProductOption.encode(options),\n      'isChecked': isChecked ? 1 : 0,\n      'priority': priority,\n    };\n  }\n\n  factory Product.fromMapFromFirestore(\n      Map<String, dynamic> map,\n      String id,\n      ) {\n    final List options = map['options'] ?? [];\n    final parsed = options.map((o) => ProductOption.fromMap(o)).toList();\n\n    return Product(\n      id: id,\n      name: map['name'] ?? '',\n      category: ProductCategory.fromMapFromFirestore(map['category'], map['category'][\"id\"] ?? \"undefined\"),\n      options: List<ProductOption>.from(parsed),\n      isChecked: map['isChecked'] ?? false,\n      priority: map['priority'],\n    );\n  }\n\n  factory Product.fromMapForSqlite(Map<String, dynamic> map) {\n    return Product(\n      id: map['id']?.toString(),\n      localId: map['localId'] is int ? map['localId'] : int.tryParse(map['localId'].toString()),\n      name: map['name'],\n      category: ProductCategory.fromMapForSqlite(map['category']),\n      options: ProductOption.decode(map['optionsJson']),\n      isChecked: map['isChecked'] == 1,\n      priority: map['priority'],\n    );\n  }\n  \n  @override\n  int get hashCode => name.hashCode;\n  \n}\n",
        "product_category.dart": "// lib/models/product_category.dart\nimport 'package:flutter/material.dart';\n\nclass ProductCategory {\n  final String id;\n  final String name;\n  final IconData icon;\n  final int? defaultPriority;\n\n  const ProductCategory({\n    required this.id,\n    required this.name,\n    required this.icon,\n    this.defaultPriority,\n  });\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'iconCodePoint': icon.codePoint,\n      'iconFontFamily': icon.fontFamily,\n      'defaultPriority': defaultPriority,\n    };\n  }\n\n  factory ProductCategory.fromMapFromFirestore(Map<String, dynamic> map, String id) {\n    return ProductCategory(\n      id: id,\n      name: map['name'],\n      icon: IconData(\n        map['iconCodePoint'],\n        fontFamily: map['iconFontFamily'],\n      ),\n      defaultPriority: map['defaultPriority'],\n    );\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': id,\n      'name': name,\n      'iconCodePoint': icon.codePoint,\n      'iconFontFamily': icon.fontFamily,\n      'defaultPriority': defaultPriority,\n    };\n  }\n\n  factory ProductCategory.fromMapForSqlite(Map<String, dynamic> map) {\n    return ProductCategory(\n      id: map['id'],\n      name: map['name'],\n      icon: IconData(\n        map['iconCodePoint'],\n        fontFamily: map['iconFontFamily'],\n      ),\n      defaultPriority: map['defaultPriority'],\n    );\n  }\n\n  static const indefinida = ProductCategory(\n    id: 'undefined',\n    name: 'Indefinida',\n    icon: Icons.label_outline,\n    defaultPriority: 3,\n  );\n\n  static const alimentacao = ProductCategory(\n    id: 'food',\n    name: 'Alimentação',\n    icon: Icons.fastfood,\n    defaultPriority: 1,\n  );\n\n  static const casa = ProductCategory(\n    id: 'home',\n    name: 'Casa',\n    icon: Icons.home,\n    defaultPriority: 2,\n  );\n}\n",
        "product_option.dart": "// lib/models/product_option.dart\nimport 'dart:convert';\nimport 'package:cloud_firestore/cloud_firestore.dart';\n\nclass ProductOption {\n  final String brand;\n  final String storeName;\n  final double price;\n  final String quantity;\n  final Timestamp purchaseDate;\n\n  ProductOption({\n    required this.brand,\n    required this.storeName,\n    required this.price,\n    required this.quantity,\n    required this.purchaseDate,\n  });\n\n  Map<String, dynamic> toMap() {\n    return {\n      'brand': brand,\n      'storeName': storeName,\n      'price': price,\n      'quantity': quantity,\n      'purchaseDate': purchaseDate,\n    };\n  }\n\n  factory ProductOption.fromMap(Map<String, dynamic> map) {\n    return ProductOption(\n      brand: map['brand'],\n      storeName: map['storeName'],\n      price: (map['price'] as num).toDouble(),\n      quantity: map['quantity'],\n      purchaseDate: map['purchaseDate'] ?? Timestamp.now(),\n    );\n  }\n\n  static String encode(List<ProductOption> list) =>\n      jsonEncode(list.map((o) => o.toMap()).toList());\n\n  static List<ProductOption> decode(String? jsonStr) {\n    if (jsonStr == null || jsonStr.isEmpty) return [];\n    final raw = jsonDecode(jsonStr);\n    return raw.map<ProductOption>((o) => ProductOption.fromMap(o)).toList();\n  }\n}\n",
        "receipt.dart": "// lib/models/receipt.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'receipt_category.dart';\n\nclass Receipt {\n  final String? id;\n  final int? localId;\n  final String title;\n  final double value;\n  final DateTime date;\n  final bool isRecurrent;\n  final int? recurrencyType;\n  final bool isShared;\n  final String? sharedFromUid;\n  final ReceiptCategory category;\n  final String? note;\n\n  Receipt({\n    this.id,\n    this.localId,\n    required this.title,\n    required this.value,\n    required this.date,\n    this.isRecurrent = false,\n    this.recurrencyType,\n    this.isShared = false,\n    this.sharedFromUid,\n    required this.category,\n    this.note\n  });\n\n  bool get isFuture => date.isAfter(DateTime.now());\n\n  Receipt copyWith({\n    String? id,\n    int? localId,\n    String? title,\n    double? value,\n    DateTime? date,\n    bool? isRecurrent,\n    int? recurrencyType,\n    bool? isShared,\n    String? sharedFromUid,\n    ReceiptCategory? category,\n    String? note\n  }) {\n    return Receipt(\n      id: id ?? this.id,\n      localId: localId ?? this.localId,\n      title: title ?? this.title,\n      value: value ?? this.value,\n      date: date ?? this.date,\n      isRecurrent: isRecurrent ?? this.isRecurrent,\n      recurrencyType: recurrencyType ?? this.recurrencyType,\n      isShared: isShared ?? this.isShared,\n      sharedFromUid: sharedFromUid ?? this.sharedFromUid,\n      category: category ?? this.category,\n      note: note ?? this.note\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'title': title,\n      'value': value,\n      'date': Timestamp.fromDate(date),\n      'isRecurrent': isRecurrent,\n      'recurrencyType': recurrencyType,\n      'isShared': isShared,\n      'sharedFromUid': sharedFromUid,\n      'category': category.toMapForFirestore(),\n      'note': note\n    };\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'id': id,\n      'title': title,\n      'value': value,\n      'date': date.toIso8601String(),\n      'isRecurrent': isRecurrent ? 1 : 0,\n      'recurrencyType': recurrencyType,\n      'isShared': isShared ? 1 : 0,\n      'sharedFromUid': sharedFromUid,\n      'category': category.toMapForSqlite(),\n      'note':note\n    };\n  }\n\n  factory Receipt.fromMapFromFirestore(Map<String, dynamic> map, String id) {\n    DateTime parsedDate;\n    if (map['date'] is Timestamp) {\n      parsedDate = (map['date'] as Timestamp).toDate();\n    } else {\n      parsedDate = DateTime.tryParse(map['date']?.toString() ?? '') ?? DateTime.now();\n    }\n\n    // --- CORREÇÃO AQUI: Verificação de segurança para a categoria ---\n    ReceiptCategory parsedCategory;\n    try {\n      if (map['category'] != null && map['category'] is Map) {\n        parsedCategory = ReceiptCategory.fromMapFromFirestore(Map<String, dynamic>.from(map['category']));\n      } else {\n        parsedCategory = ReceiptCategory.defaults[0];\n      }\n    } catch (e) {\n      parsedCategory = ReceiptCategory.defaults[0];\n    }\n    // ----------------------------------------------------------------\n\n    return Receipt(\n      id: id,\n      localId: null,\n      title: map['title'] ?? '',\n      value: (map['value'] is num) ? (map['value'] as num).toDouble() : double.tryParse(map['value']?.toString() ?? '') ?? 0.0,\n      date: parsedDate,\n      isRecurrent: map['isRecurrent'] ?? false,\n      recurrencyType: map['recurrencyType'] as int?,\n      isShared: map['isShared'] ?? false,\n      sharedFromUid: map['sharedFromUid']?.toString(),\n      category: parsedCategory, // Usa a variável tratada\n      note: map['note']\n    );\n  }\n\n  factory Receipt.fromMapForSqlite(Map<String, dynamic> map) {\n    final localId = map['localId'] is int\n        ? map['localId'] as int\n        : (map['localId'] != null ? int.tryParse(map['localId'].toString()) : null);\n\n    return Receipt(\n      id: map['id']?.toString(),\n      localId: localId,\n      title: map['title'] ?? '',\n      value: (map['value'] is num) ? (map['value'] as num).toDouble() : double.tryParse(map['value']?.toString() ?? '') ?? 0.0,\n      date: DateTime.tryParse(map['date']?.toString() ?? '') ?? DateTime.now(),\n      isRecurrent: (map['isRecurrent'] ?? 0) == 1,\n      recurrencyType: map['recurrencyType'] is int ? map['recurrencyType'] as int : (map['recurrencyType'] != null ? int.tryParse(map['recurrencyType'].toString()) : null),\n      isShared: (map['isShared'] ?? 0) == 1,\n      sharedFromUid: map['sharedFromUid']?.toString(),\n      category: ReceiptCategory.fromMapForSqlite(map['category'] ?? map),\n      note: map['note']\n    );\n  }\n}",
        "receipt_category.dart": "// lib/models/receipt_category.dart\nimport 'package:flutter/material.dart';\n\nclass ReceiptCategory {\n  final String name;\n  final IconData icon;\n\n  const ReceiptCategory({required this.name, required this.icon});\n\n  static const defaults = [\n    ReceiptCategory(name: 'Salário', icon: Icons.monetization_on),\n    ReceiptCategory(name: 'Presente', icon: Icons.card_giftcard),\n    ReceiptCategory(name: 'Investimento', icon: Icons.trending_up),\n    ReceiptCategory(name: 'Outros', icon: Icons.add_circle_outline),\n  ];\n  \n  static ReceiptCategory defaultCategory = defaults[0];\n\n\n  static List<ReceiptCategory> allCategories() => [...defaults];\n\n  static ReceiptCategory fromMapFromFirestore(Map<String, dynamic> map) {\n    return ReceiptCategory(\n      name: map['name'] ?? 'Desconhecida',\n      icon: IconData(\n        map['icon'] ?? Icons.label_outline.codePoint,\n        fontFamily: Icons.label_outline.fontFamily,\n      ),\n    );\n  }\n\n  Map<String, dynamic> toMapForFirestore() {\n    return {\n      'name': name,\n      'icon': icon.codePoint,\n    };\n  }\n\n  Map<String, dynamic> toMapForSqlite() {\n    return {\n      'name': name,\n      'icon': icon.codePoint,\n    };\n  }\n\n  static ReceiptCategory fromMapForSqlite(Map<String, dynamic> map) {\n    return ReceiptCategory(\n      name: map['name'],\n      icon: IconData(\n        map['icon'],\n        fontFamily: Icons.label_outline.fontFamily,\n      ),\n    );\n  }\n}\n",
        "transaction.dart": "// lib/models/transaction.dart\nimport 'package:flutter/material.dart';\n\nabstract class TransactionModel {\n  String? get id;\n  String get title;\n  double get value;\n  DateTime get date;\n  bool get isRecurrent;\n\n  String get categoryName;\n  IconData get categoryIcon;\n\n  bool get isExpense;\n\n  Map<String, dynamic> toMapForFirestore();\n  Map<String, dynamic> toMapForSqlite();\n}\n"
    },
    "screens": {
        "add_transaction_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:intl/intl.dart';\n\nimport 'package:family_finances/styles/app_colors.dart';\nimport 'package:family_finances/styles/section_style.dart';\n\nimport '../models/finance_state.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\nimport '../models/expense_category.dart';\nimport '../models/receipt_category.dart';\n\n// Imports adicionados para a funcionalidade de QR Code\nimport 'qr_code_scanner_screen.dart';\nimport '../services/nfce_service.dart';\n\nenum RecurrencyType { monthly, weekly, custom }\n\nclass AddTransactionScreen extends StatefulWidget {\n  final Expense? expenseToEdit;\n  final Receipt? receiptToEdit;\n\n  const AddTransactionScreen({\n    super.key,\n    this.expenseToEdit,\n    this.receiptToEdit,\n  });\n\n  @override\n  State<AddTransactionScreen> createState() => _AddTransactionScreenState();\n}\n\nclass _AddTransactionScreenState extends State<AddTransactionScreen> {\n  final _titleController = TextEditingController();\n  final _valueController = TextEditingController();\n  final _noteController = TextEditingController();\n  final _installmentCountController = TextEditingController();\n  final _intervalController = TextEditingController();\n  final _installmentValueController = TextEditingController();\n\n  bool _isExpense = true;\n  bool _isInInstallments = false;\n  bool _isRecurrent = false;\n  bool _isShared = false;\n  \n  // Variável para controlar o loading da leitura da nota\n  bool _isLoadingNfce = false;\n\n  RecurrencyType? _recurrencyType;\n  DateTime _selectedDate = DateTime.now();\n\n  int _selectedDayOfMonth = DateTime.now().day;\n  int _selectedDayOfWeek = DateTime.now().weekday;\n\n  ExpenseCategory? _selectedCategory;\n\n  final List<ExpenseCategory> _categories = [\n    ExpenseCategory(name: \"Comida\", icon: Icons.fastfood),\n    ExpenseCategory(name: \"Moradia\", icon: Icons.home),\n    ExpenseCategory(name: \"Transporte\", icon: Icons.directions_car),\n    ExpenseCategory(name: \"Lazer\", icon: Icons.sports_esports),\n    ExpenseCategory(name: \"Compras\", icon: Icons.shopping_cart),\n    ExpenseCategory(name: \"Saúde\", icon: Icons.local_hospital),\n    ExpenseCategory(name: \"Educação\", icon: Icons.school),\n    ExpenseCategory(name: \"Outros\", icon: Icons.category),\n  ];\n\n  @override\n  void initState() {\n    super.initState();\n\n    // Atualiza automaticamente valor da parcela\n    _valueController.addListener(_updateInstallmentValue);\n    _installmentCountController.addListener(_updateInstallmentValue);\n\n    // PRÉ-PREENCHIMENTO EM MODO EDIÇÃO\n    if (widget.expenseToEdit != null) {\n      final e = widget.expenseToEdit!;\n\n      _isExpense = true;\n      _titleController.text = e.title;\n      _valueController.text = e.value.toString();\n      _noteController.text = e.note;\n      _selectedCategory = e.category;\n      _selectedDate = e.date;\n\n      _isInInstallments = e.isInInstallments;\n      if (_isInInstallments) {\n        _installmentCountController.text = e.installmentCount?.toString() ?? \"1\";\n      }\n\n      _isRecurrent = e.isRecurrent;\n      if (_isRecurrent) {\n        _recurrencyType = RecurrencyType.values[e.recurrencyType!];\n        if (_recurrencyType == RecurrencyType.custom) {\n          _intervalController.text = e.recurrentIntervalDays?.toString() ?? \"\";\n        }\n      }\n\n      _isShared = e.isShared;\n    } else if (widget.receiptToEdit != null) {\n      final r = widget.receiptToEdit!;\n      _isExpense = false;\n      _titleController.text = r.title;\n      _valueController.text = r.value.toString();\n      _selectedDate = r.date;\n      _noteController.text = r.note ?? \"\";\n      _isRecurrent = r.isRecurrent;\n    }\n  }\n\n  @override\n  void dispose() {\n    _valueController.dispose();\n    _noteController.dispose();\n    _installmentValueController.dispose();\n    _intervalController.dispose();\n    _titleController.dispose();\n    super.dispose();\n  }\n\n  // ===============================================\n  // CÁLCULO DO VALOR DAS PARCELAS\n  // ===============================================\n  void _updateInstallmentValue() {\n    final total = double.tryParse(_valueController.text.replaceAll(\",\", \".\")) ?? 0;\n    final count = int.tryParse(_installmentCountController.text) ?? 1;\n\n    final result = count > 0 ? (total / count) : 0;\n    _installmentValueController.text = result.toStringAsFixed(2);\n    // setState não é necessário aqui se for só para atualizar o controller, \n    // mas se afetar UI reativa, mantenha.\n    if (mounted) setState(() {});\n  }\n\n  // ===============================================\n  // LÓGICA DE LEITURA DE NFC-E\n  // ===============================================\n  Future<void> _scanAndLoadNfce() async {\n    // 1. Navega para a tela de scanner e aguarda o resultado (URL)\n    final String? url = await Navigator.push(\n      context,\n      MaterialPageRoute(builder: (_) => const QRCodeScannerScreen()),\n    );\n\n    if (url == null || url.isEmpty) return;\n\n    setState(() {\n      _isLoadingNfce = true;\n    });\n\n    try {\n      // 2. Chama o serviço para processar a URL\n      final nfceService = NfceService();\n      final nfceData = await nfceService.fetchAndParseNfce(url);\n\n      // 3. Atualiza os campos da tela com os dados da nota\n      setState(() {\n        _titleController.text = nfceData.storeName;\n        _valueController.text = nfceData.totalValue.toStringAsFixed(2);\n        _selectedDate = nfceData.date.toDate();\n        \n        // Tenta categorizar automaticamente como \"Compras\" ou \"Comida\" se possível\n        // ou mantém a seleção atual\n        if (_selectedCategory == null) {\n             final lowerName = nfceData.storeName.toLowerCase();\n             if (lowerName.contains(\"mercado\") || lowerName.contains(\"atacad\") || lowerName.contains(\"super\")) {\n                _selectedCategory = _categories.firstWhere((c) => c.name == \"Compras\", orElse: () => _categories.last);\n             } else if (lowerName.contains(\"restaurante\") || lowerName.contains(\"lanchonete\")) {\n                _selectedCategory = _categories.firstWhere((c) => c.name == \"Comida\", orElse: () => _categories.last);\n             }\n        }\n\n        // Preenche a nota com os itens para referência\n        final itemsList = nfceData.items.map((i) => \"- ${i.name} (${i.quantity}x)\").join(\"\\n\");\n        _noteController.text = \"Importado via NFC-e:\\n$itemsList\";\n      });\n\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text(\"Nota importada com sucesso!\")),\n      );\n\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text(\"Erro ao ler nota: $e\")),\n      );\n    } finally {\n      setState(() {\n        _isLoadingNfce = false;\n      });\n    }\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    final finance = Provider.of<FinanceState>(context, listen: false);\n    final hasPartner = finance.hasPartnership;\n\n    return Scaffold(\n      backgroundColor: AppColors.secondary,\n      appBar: AppBar(\n        elevation: 0,\n        backgroundColor: AppColors.primary,\n        foregroundColor: AppColors.onPrimary,\n        title: Text(\n          widget.expenseToEdit == null && widget.receiptToEdit == null\n              ? \"Nova Transação\"\n              : \"Editar Transação\",\n        ),\n      ),\n\n      body: _isLoadingNfce \n        ? const Center(child: Column(\n            mainAxisAlignment: MainAxisAlignment.center,\n            children: [\n              CircularProgressIndicator(),\n              SizedBox(height: 16),\n              Text(\"Importando dados da nota fiscal...\"),\n            ],\n          ))\n        : SingleChildScrollView(\n        padding: const EdgeInsets.all(18),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n\n            // =======================================================\n            // TIPO (Despesa / Receita / Compartilhado)\n            // =======================================================\n            Center(\n              child: Wrap(\n                spacing: 10,\n                children: [\n                  ChoiceChip(\n                    label: const Text(\"Despesa\"),\n                    selected: _isExpense,\n                    selectedColor: Colors.red.shade200,\n                    onSelected: (_) => setState(() => _isExpense = true),\n                  ),\n\n                  ChoiceChip(\n                    label: const Text(\"Receita\"),\n                    selected: !_isExpense,\n                    selectedColor: Colors.green.shade200,\n                    onSelected: (_) => setState(() => _isExpense = false),\n                  ),\n\n                  if (hasPartner)\n                    ChoiceChip(\n                      label: Text(_isShared ? \"Compartilhado\" : \"Privado\"),\n                      selected: _isShared,\n                      selectedColor: Colors.blue.shade200,\n                      onSelected: (_) => setState(() => _isShared = !_isShared),\n                    ),\n                ],\n              ),\n            ),\n\n            const SizedBox(height: 16),\n\n            // =======================================================\n            // BOTÃO DE QR CODE (Aparece apenas para Despesas)\n            // =======================================================\n            if (_isExpense) \n              Center(\n                child: Padding(\n                  padding: const EdgeInsets.only(bottom: 16.0),\n                  child: ElevatedButton.icon(\n                    onPressed: _scanAndLoadNfce,\n                    icon: const Icon(Icons.qr_code_scanner),\n                    label: const Text(\"Ler NFC-e (QR Code)\"),\n                    style: ElevatedButton.styleFrom(\n                      backgroundColor: Colors.white,\n                      foregroundColor: Colors.black87,\n                      elevation: 2,\n                      side: BorderSide(color: Colors.grey.shade300),\n                      shape: RoundedRectangleBorder(\n                        borderRadius: BorderRadius.circular(8),\n                      ),\n                    ),\n                  ),\n                ),\n              ),\n\n            _buildInput(\"Título\", \"Ex: Mercado\", _titleController),\n            const SizedBox(height: 16),\n            _buildInput(\"Valor\", \"0,00\", _valueController, keyboard: TextInputType.number),\n\n            const SizedBox(height: 20),\n\n            // =======================================================\n            // PARCELADO / RECORRENTE\n            // =======================================================\n            _buildSwitchRow(),\n\n            if (_isInInstallments) _buildInstallmentsCard(),\n            if (_isRecurrent) _buildRecurrencyCard(),\n\n            if (_isExpense) const SizedBox(height: 16),\n            if (_isExpense) _buildCategorySelector(),\n\n            const SizedBox(height: 16),\n            _buildInput(\"Nota (opcional)\", \"Adicionar nota...\", _noteController, maxLines: 3),\n\n            const SizedBox(height: 20),\n            _buildDatePicker(),\n\n            const SizedBox(height: 40),\n            _buildSaveButton(finance),\n          ],\n        ),\n      ),\n    );\n  }\n\n  // ===============================================\n  // INPUT MODERNO\n  // ===============================================\n  Widget _buildInput(\n    String label,\n    String hint,\n    TextEditingController controller, {int maxLines = 1,\n    TextInputType keyboard = TextInputType.text,\n  }) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label,\n            style: const TextStyle(\n              fontWeight: FontWeight.bold,\n              fontSize: 16,\n            )),\n        const SizedBox(height: 8),\n        TextField(\n          controller: controller,\n          maxLines: maxLines,\n          keyboardType:keyboard ,\n          decoration: InputDecoration(\n            hintText: hint,\n            filled: true,\n            fillColor: Colors.white,\n            contentPadding: const EdgeInsets.symmetric(horizontal: 16, vertical: 14),\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(12),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n            enabledBorder: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(12),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  // ===============================================\n  // PARCELADO & RECORRENTE\n  // ===============================================\n  Widget _buildSwitchRow() {\n    return Row(\n      children: [\n        Checkbox(\n          value: _isInInstallments,\n          onChanged: (v) {\n            setState(() {\n              _isInInstallments = v ?? false;\n              if (_isInInstallments) _isRecurrent = false;\n            });\n          },\n        ),\n        const Text(\"Parcelado\"),\n\n        const SizedBox(width: 24),\n\n        Checkbox(\n          value: _isRecurrent,\n          onChanged: (v) {\n            setState(() {\n              _isRecurrent = v ?? false;\n              if (_isRecurrent) _isInInstallments = false;\n            });\n          },\n        ),\n        const Text(\"Recorrente\"),\n      ],\n    );\n  }\n\n  // ===============================================\n  // CARD DE PARCELAMENTO\n  // ===============================================\n  Widget _buildInstallmentsCard() {\n    final total = double.tryParse(_valueController.text.replaceAll(\",\", \".\")) ?? 0;\n    final count = int.tryParse(_installmentCountController.text) ?? 1;\n    final installment = count > 0 ? total / count : 0;\n\n    return Container(\n      decoration: SectionStyle(),\n      padding: const EdgeInsets.all(16),\n      margin: const EdgeInsets.symmetric(vertical: 8),\n      child: Row(\n        children: [\n          Expanded(\n            child: Column(\n              children: [\n                const Text(\"Parcelas\"),\n                const SizedBox(height: 6),\n                TextField(\n                  controller: _installmentCountController,\n                  keyboardType: TextInputType.number,\n                  textAlign: TextAlign.center,\n                  decoration: const InputDecoration(\n                    border: OutlineInputBorder(),\n                    contentPadding: EdgeInsets.symmetric(vertical: 10),\n                  ),\n                ),\n              ],\n            ),\n          ),\n          const SizedBox(width: 20),\n          Expanded(\n            child: Column(\n              children: [\n                const Text(\"Valor da parcela\"),\n                const SizedBox(height: 6),\n                Text(\n                  \"R\\$ ${installment.toStringAsFixed(2).replaceAll('.', ',')}\",\n                  style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n                ),\n              ],\n            ),\n          )\n        ],\n      ),\n    );\n  }\n\n  // ===============================================\n  // CARD DE RECORRÊNCIA\n  // ===============================================\n  Widget _buildRecurrencyCard() {\n    return Container(\n      decoration: SectionStyle(),\n      padding: const EdgeInsets.all(16),\n      margin: const EdgeInsets.symmetric(vertical: 8),\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          const Text(\"Tipo de Recorrência\", style: TextStyle(fontWeight: FontWeight.bold)),\n          const SizedBox(height: 12),\n\n          Wrap(\n            spacing: 8,\n            children: [\n              ChoiceChip(\n                label: const Text(\"Mensal\"),\n                selected: _recurrencyType == RecurrencyType.monthly,\n                onSelected: (_) => setState(() => _recurrencyType = RecurrencyType.monthly),\n              ),\n              ChoiceChip(\n                label: const Text(\"Semanal\"),\n                selected: _recurrencyType == RecurrencyType.weekly,\n                onSelected: (_) => setState(() => _recurrencyType = RecurrencyType.weekly),\n              ),\n              ChoiceChip(\n                label: const Text(\"Customizado\"),\n                selected: _recurrencyType == RecurrencyType.custom,\n                onSelected: (_) => setState(() => _recurrencyType = RecurrencyType.custom),\n              ),\n            ],\n          ),\n\n          if (_recurrencyType == RecurrencyType.monthly)\n            _buildDaySelector(\"Dia do mês\", 31, _selectedDayOfMonth,\n                (v) => setState(() => _selectedDayOfMonth = v)),\n\n          if (_recurrencyType == RecurrencyType.weekly)\n            _buildDaySelector(\"Dia da semana\", 7, _selectedDayOfWeek,\n                (v) => setState(() => _selectedDayOfWeek = v)),\n\n          if (_recurrencyType == RecurrencyType.custom)\n            _buildInput(\"Intervalo (dias)\", \"30\", _intervalController),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildDaySelector(\n      String label, int max, int current, Function(int) onChange) {\n    final days = List.generate(max, (i) => i + 1);\n\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        const SizedBox(height: 18),\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold)),\n        const SizedBox(height: 8),\n        DropdownButtonFormField<int>(\n          value: current,\n          items: days.map((d) {\n            return DropdownMenuItem(\n              value: d,\n              child: Text(max == 7\n                  ? [\"Seg\", \"Ter\", \"Qua\", \"Qui\", \"Sex\", \"Sáb\", \"Dom\"][d - 1]\n                  : d.toString()),\n            );\n          }).toList(),\n          decoration: InputDecoration(\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(12),\n            ),\n          ),\n          onChanged: (v) => onChange(v!),\n        ),\n      ],\n    );\n  }\n\n  // ===============================================\n  // SELETOR DE CATEGORIA\n  // ===============================================\n  Widget _buildCategorySelector() {\n    return DropdownButtonFormField<ExpenseCategory>(\n      value: _selectedCategory,\n      items: _categories\n          .map((cat) => DropdownMenuItem(\n                value: cat,\n                child: Row(\n                  children: [\n                    Icon(cat.icon, color: Colors.grey),\n                    const SizedBox(width: 10),\n                    Text(cat.name),\n                  ],\n                ),\n              ))\n          .toList(),\n      onChanged: (cat) => setState(() => _selectedCategory = cat),\n      decoration: InputDecoration(\n        filled: true,\n        fillColor: Colors.white,\n        border: OutlineInputBorder(\n          borderRadius: BorderRadius.circular(12),\n        ),\n      ),\n      hint: const Text(\"Selecione a categoria\"),\n    );\n  }\n\n  // ===============================================\n  // DATE PICKER\n  // ===============================================\n  Widget _buildDatePicker() {\n    return Row(\n      children: [\n        const Icon(Icons.calendar_today, size: 20),\n        const SizedBox(width: 10),\n        Text(\"Data: ${DateFormat('dd/MM/yyyy').format(_selectedDate)}\"),\n        const SizedBox(width: 10),\n        TextButton(\n          onPressed: () async {\n            final picked = await showDatePicker(\n              context: context,\n              firstDate: DateTime(2010),\n              lastDate: DateTime(2100),\n              initialDate: _selectedDate,\n            );\n            if (picked != null) setState(() => _selectedDate = picked);\n          },\n          child: const Text(\"Alterar\"),\n        )\n      ],\n    );\n  }\n\n  // ===============================================\n  // SALVAR\n  // ===============================================\n  Widget _buildSaveButton(FinanceState state) {\n    return ElevatedButton(\n      style: ElevatedButton.styleFrom(\n        backgroundColor: AppColors.primary,\n        foregroundColor: AppColors.onPrimary,\n        padding: const EdgeInsets.symmetric(vertical: 16),\n        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),\n      ),\n      onPressed: () async {\n        if (_titleController.text.isEmpty ||\n            _valueController.text.isEmpty ||\n            (_isExpense && _selectedCategory == null)) {\n          \n          // Feedback se faltar dados\n          ScaffoldMessenger.of(context).showSnackBar(\n            const SnackBar(content: Text(\"Preencha os campos obrigatórios (Título, Valor, Categoria)\")),\n          );\n          return;\n        }\n\n        final value = double.tryParse(_valueController.text.replaceAll(\",\", \".\")) ?? 0;\n\n        if (_isExpense) {\n          final exp = Expense(\n            id: widget.expenseToEdit?.id,\n            title: _titleController.text,\n            value: value,\n            note: _noteController.text,\n            category: _selectedCategory!,\n            date: _selectedDate,\n            isInInstallments: _isInInstallments,\n            installmentCount: _isInInstallments\n                ? int.tryParse(_installmentCountController.text)\n                : null,\n            isRecurrent: _isRecurrent,\n            recurrencyType: _recurrencyType?.index,\n            recurrentIntervalDays: _recurrencyType == RecurrencyType.custom\n                ? int.tryParse(_intervalController.text)\n                : null,\n            isShared: _isShared,\n            recurrencyId: widget.expenseToEdit?.recurrencyId,\n          );\n\n          widget.expenseToEdit == null\n              ? await state.addExpense(exp)\n              : await state.updateExpense(exp);\n        } else {\n          final rec = Receipt(\n            id: widget.receiptToEdit?.id,\n            title: _titleController.text,\n            value: value,\n            category: ReceiptCategory(name: \"Outros\", icon: Icons.category),\n            note: _noteController.text,\n            date: _selectedDate,\n            isRecurrent: _isRecurrent,\n            recurrencyType: _recurrencyType?.index,\n            isShared: _isShared,\n          );\n\n          widget.receiptToEdit == null\n              ? await state.addReceipt(rec)\n              : await state.updateReceipt(rec);\n        }\n\n        if (mounted) Navigator.pop(context);\n      },\n      child: const Text(\"Salvar\", style: TextStyle(fontSize: 18)),\n    );\n  }\n}",
        "auth_gate.dart": "import 'package:flutter/material.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'overview_screen.dart';\nimport 'login_screen.dart';\n\nclass AuthGate extends StatelessWidget {\n  const AuthGate({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return StreamBuilder<User?>(\n      stream: FirebaseAuth.instance.authStateChanges(),\n      builder: (_, snap) {\n        if (!snap.hasData) return const LoginScreen();\n        return const OverviewScreen();\n      },\n    );\n  }\n}\n",
        "expense_category_screen.dart": "import 'package:flutter/material.dart';\nimport '../models/expense_category.dart';\n\nclass AddExpenseWithCategoryScreen extends StatefulWidget {\n  const AddExpenseWithCategoryScreen({super.key});\n\n  @override\n  State<AddExpenseWithCategoryScreen> createState() => _AddExpenseWithCategoryScreenState();\n}\n\nclass _AddExpenseWithCategoryScreenState extends State<AddExpenseWithCategoryScreen> {\n  final TextEditingController _titleController = TextEditingController(); // NOVO\n  final TextEditingController _valueController = TextEditingController();\n  final TextEditingController _noteController = TextEditingController();\n\n  final List<ExpenseCategory> _basic_categories = [\n    ExpenseCategory(name: 'Comida', icon: Icons.fastfood),\n    ExpenseCategory(name: 'Moradia', icon: Icons.home),\n    ExpenseCategory(name: 'Transporte', icon: Icons.directions_car),\n    ExpenseCategory(name: 'Lazer', icon: Icons.sports_esports),\n  ];\n  final List<ExpenseCategory> _custom_categories = [];\n  ExpenseCategory? _selectedCategory;\n\n  void _addCategory(ExpenseCategory category) {\n    setState(() {\n      _basic_categories.add(category);\n      _selectedCategory = category;\n    });\n  }\n\n  void _showAddCategoryDialog(BuildContext context) {\n    final TextEditingController nameController = TextEditingController();\n    IconData? selectedIcon;\n    final icons = [\n      Icons.fastfood, Icons.home, Icons.directions_car, Icons.sports_esports,\n      Icons.shopping_cart, Icons.local_hospital, Icons.school\n    ];\n\n    showDialog(\n      context: context,\n      builder: (context) => StatefulBuilder(\n        builder: (context, setStateDialog) => AlertDialog(\n          title: const Text('Nova categoria'),\n          content: Column(\n            mainAxisSize: MainAxisSize.min,\n            children: [\n              TextField(\n                controller: nameController,\n                decoration: const InputDecoration(labelText: 'Nome'),\n              ),\n              const SizedBox(height: 16),\n              Wrap(\n                spacing: 8,\n                children: icons.map((icon) => GestureDetector(\n                  onTap: () {\n                    setStateDialog(() {\n                      selectedIcon = icon;\n                    });\n                  },\n                  child: Container(\n                    decoration: BoxDecoration(\n                      border: Border.all(\n                        color: selectedIcon == icon ? Colors.teal : Colors.transparent,\n                        width: 2,\n                      ),\n                      borderRadius: BorderRadius.circular(8),\n                    ),\n                    padding: const EdgeInsets.all(8),\n                    child: Icon(icon, size: 32),\n                  ),\n                )).toList(),\n              ),\n            ],\n          ),\n          actions: [\n            TextButton(\n              onPressed: () => Navigator.of(context).pop(),\n              child: const Text('Cancelar'),\n            ),\n            ElevatedButton(\n              onPressed: () {\n                if (nameController.text.isNotEmpty && selectedIcon != null) {\n                  _addCategory(ExpenseCategory(name: nameController.text, icon: selectedIcon!));\n                  Navigator.of(context).pop();\n                }\n              },\n              child: const Text('Salvar'),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    const Color primaryColor = Color(0xFF2A8782);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Adicionar Gasto')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            _buildTextField(label: 'Título', hint: 'Descrição do gasto', controller: _titleController), // NOVO\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Valor', hint: '0,00', controller: _valueController),\n            const SizedBox(height: 16),\n            _buildCategorySelector(context),\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Nota', hint: 'Adicionar nota', controller: _noteController, maxLines: 3),\n            const Spacer(),\n            ElevatedButton(\n              onPressed: () {\n                // Aqui você pode salvar o gasto, incluindo o título\n                // Remova ou comente a linha abaixo:\n                // Navigator.of(context).pop();\n              },\n              style: ElevatedButton.styleFrom(\n                backgroundColor: primaryColor,\n                padding: const EdgeInsets.symmetric(vertical: 16),\n                shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(8),\n                ),\n              ),\n              child: const Text('Salvar gasto', style: TextStyle(fontSize: 18, color: Colors.white)),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildTextField({required String label, required String hint, required TextEditingController controller, int maxLines = 1}) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        TextField(\n          controller: controller,\n          maxLines: maxLines,\n          decoration: InputDecoration(\n            hintText: hint,\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n            enabledBorder: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildCategorySelector(BuildContext context) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        const Text('Categoria', style: TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        DropdownButtonFormField<ExpenseCategory>(\n          initialValue: _selectedCategory,\n          items: [\n            ..._basic_categories.map((cat) => DropdownMenuItem(\n              value: cat,\n              child: Row(\n                children: [\n                  Icon(cat.icon, color: Colors.grey),\n                  const SizedBox(width: 8),\n                  Text(cat.name),\n                ],\n              ),\n            )),\n            DropdownMenuItem(\n              value: null,\n              child: Row(\n                children: const [\n                  Icon(Icons.add, color: Colors.grey),\n                  SizedBox(width: 8),\n                  Text('Nova categoria'),\n                ],\n              ),\n            ),\n          ],\n          onChanged: (cat) {\n            if (cat == null) {\n              _showAddCategoryDialog(context);\n            } else {\n              setState(() {\n                _selectedCategory = cat;\n              });\n            }\n          },\n          decoration: InputDecoration(\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n}",
        "login_screen.dart": "import 'package:firebase_auth/firebase_auth.dart';\nimport 'package:flutter/material.dart';\nimport 'package:google_sign_in/google_sign_in.dart';\nimport 'package:provider/provider.dart';\nimport '../models/finance_state.dart';\nimport 'main_screen.dart';\n\nclass LoginScreen extends StatefulWidget {\n  const LoginScreen({super.key});\n\n  @override\n  State<LoginScreen> createState() => _LoginScreenState();\n}\n\nclass _LoginScreenState extends State<LoginScreen> {\n  final _emailController = TextEditingController();\n  final _passwordController = TextEditingController();\n  final _formKey = GlobalKey<FormState>();\n  String? _errorMessage;\n  bool _isLoading = false; // Estado de loading para a sincronização\n\n  @override\n  void initState() {\n    super.initState();\n\n    final GoogleSignIn signIn = GoogleSignIn.instance;\n\n    // Inicialização do Google Sign In.\n    // O listener abaixo lida com a autenticação e o Firebase AuthStateChanges no FinanceState\n    // se encarrega de carregar/sincronizar os dados após o login bem-sucedido.\n    signIn.initialize(\n      clientId: null,\n      serverClientId: null\n    ).then((_){\n        signIn.authenticationEvents.listen((event) async{\n            if(event case GoogleSignInAuthenticationEventSignIn(: final user)){\n              final auth = await user.authentication;\n              final credential = GoogleAuthProvider.credential(\n                idToken: auth.idToken,\n              );\n              // Faz o login no Firebase. Isso dispara o listener do FinanceState.\n              await FirebaseAuth.instance.signInWithCredential(credential);\n            }\n        });\n    });\n  }\n\n\n  // Função de sincronização (mantida, mas agora só é chamada se o login falhar\n  // e o usuário precisar de uma retentativa de sync, embora a chamada principal\n  // venha do FinanceState).\n  Future<void> _syncLocalData(String newUid) async {\n    final financeState = Provider.of<FinanceState>(context, listen: false);\n    \n    // Verifica se o utilizador estava em modo local antes de tentar sincronizar\n    if (financeState.isLoggedIn) {\n      return; // Já está logado, não precisa sincronizar\n    }\n\n    // VERIFICAÇÃO \"MOUNTED\"\n    if (mounted) {\n      setState(() {\n        _isLoading = true;\n        _errorMessage = \"Sincronizando dados locais para a nuvem...\";\n      });\n    }\n\n    try {\n      // Chamada real da sincronização\n      // O AuthGate tratará da navegação após o estado de auth mudar\n    } catch (e) {\n      // VERIFICAÇÃO \"MOUNTED\"\n      if (mounted) {\n        setState(() {\n          _errorMessage = \"Erro ao sincronizar: $e. Faça login novamente mais tarde para tentar de novo.\";\n        });\n      }\n    } finally {\n      // VERIFICAÇÃO \"MOUNTED\"\n      if (mounted) {\n        setState(() => _isLoading = false);\n      }\n    }\n  }\n\n  Future<void> _signIn() async {\n    if (!_formKey.currentState!.validate() || _isLoading) return;\n    try {\n      if (mounted) {\n        setState(() {\n           _isLoading = true;\n           _errorMessage = null;\n        });\n      }\n      \n      // 1. Faz o login no Firebase. \n      // O listener de auth no FinanceState cuidará da sincronização e navegação\n      await FirebaseAuth.instance.signInWithEmailAndPassword(\n        email: _emailController.text,\n        password: _passwordController.text,\n      );\n\n      // 2. Não precisamos mais da lógica de sincronização aqui.\n      // O FinanceState agora ouve a mudança de estado de autenticação e inicia a sincronização automaticamente.\n\n    } on FirebaseAuthException catch (e) {\n      if(mounted){\n        setState(() {\n          _isLoading = false;\n          _errorMessage = e.message ?? \"Ocorreu um erro.\";\n        });\n      }\n    }\n  }\n\n  Future<void> _register() async {\n    if (!_formKey.currentState!.validate() || _isLoading) return;\n    try {\n      if (mounted) {\n        setState(() {\n           _isLoading = true;\n           _errorMessage = null;\n        });\n      }\n\n      // 1. Cria o utilizador no Firebase.\n      // O listener de auth no FinanceState cuidará da sincronização e navegação\n      await FirebaseAuth.instance.createUserWithEmailAndPassword(\n        email: _emailController.text,\n        password: _passwordController.text,\n      );\n      \n      // 2. Não precisamos mais da lógica de sincronização aqui.\n      // O FinanceState agora ouve a mudança de estado de autenticação e inicia a sincronização automaticamente.\n\n    } on FirebaseAuthException catch (e) {\n       if(mounted){\n          setState(() {\n            _isLoading = false;\n            _errorMessage = e.message ?? \"Ocorreu um erro.\";\n          });\n       }\n    }\n  }\n  \n  Future<void> _signInWithGoogle() async {\n    final signIn = GoogleSignIn.instance;\n\n    if (!signIn.supportsAuthenticate()) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text(\"Este dispositivo não suporta login Google nativo.\")),\n      );\n      return;\n    }\n\n    try {\n      // A chamada a authenticate() vai disparar o listener no initState\n      await signIn.authenticate(); \n      // O listener de auth no FinanceState cuidará da sincronização e navegação.\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text(\"Erro ao autenticar com Google: $e\")),\n      );\n    }\n  }\n\n\n  void _continueAsGuest() {\n    if (_isLoading) return;\n    // Simplesmente navega para o MainScreen.\n    Navigator.of(context).pushReplacement(\n      MaterialPageRoute(builder: (context) => const MainScreen()),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: Center(\n        child: SingleChildScrollView(\n          padding: const EdgeInsets.all(24.0),\n          child: Form(\n            key: _formKey,\n            child: Column(\n              mainAxisAlignment: MainAxisAlignment.center,\n              crossAxisAlignment: CrossAxisAlignment.stretch,\n              children: [\n                const Icon(Icons.account_balance_wallet, size: 80, color: Color(0xFF2A8782)),\n                const SizedBox(height: 16),\n                const Text(\n                  'FamilyFinances',\n                  textAlign: TextAlign.center,\n                  style: TextStyle(fontSize: 28, fontWeight: FontWeight.bold),\n                ),\n                const SizedBox(height: 48),\n                TextFormField(\n                  controller: _emailController,\n                  decoration: const InputDecoration(labelText: 'Email', border: OutlineInputBorder()),\n                  keyboardType: TextInputType.emailAddress,\n                  validator: (value) => (value == null || value.isEmpty) ? 'Por favor, insira o email' : null,\n                ),\n                const SizedBox(height: 16),\n                TextFormField(\n                  controller: _passwordController,\n                  decoration: const InputDecoration(labelText: 'Senha', border: OutlineInputBorder()),\n                  obscureText: true,\n                  validator: (value) => (value == null || value.length < 6) ? 'A senha deve ter pelo menos 6 caracteres' : null,\n                ),\n                if (_errorMessage != null)\n                  Padding(\n                    padding: const EdgeInsets.only(top: 16.0),\n                    child: Text(\n                      _errorMessage!,\n                      style: TextStyle(color: _isLoading ? Colors.blue : Colors.red),\n                      textAlign: TextAlign.center,\n                    ),\n                  ),\n                const SizedBox(height: 24),\n\n                // Mostra um indicador de loading nos botões\n                if (_isLoading)\n                  const Center(child: CircularProgressIndicator())\n                else ...[\n                  ElevatedButton(\n                    onPressed: _signIn,\n                    style: ElevatedButton.styleFrom(\n                      padding: const EdgeInsets.symmetric(vertical: 16),\n                      backgroundColor: const Color(0xFF2A8782)\n                    ),\n                    child: const Text('Entrar', style: TextStyle(color: Colors.white, fontSize: 16)),\n                  ),\n                  const SizedBox(height: 12),\n                  OutlinedButton(\n                    onPressed: _register,\n                    style: OutlinedButton.styleFrom(\n                       padding: const EdgeInsets.symmetric(vertical: 16),\n                    ),\n                    child: const Text('Registar', style: TextStyle(fontSize: 16)),\n                  ),\n                  const SizedBox(height: 16),\n                  const Divider(),\n                  // NOVO BOTÃO: Continuar sem login\n                  TextButton(\n                    onPressed: _continueAsGuest,\n                    child: const Text(\n                      'Continuar sem login',\n                      style: TextStyle(color: Colors.grey, decoration: TextDecoration.underline),\n                    ),\n                  ),\n                ],\n                const SizedBox(height: 16),\n                SizedBox(height: 20),\nElevatedButton.icon(\n  icon: Image.asset(\n    'assets/google_logo.png',\n    height: 24,\n  ),\n  label: const Text(\"Continuar com Google\"),\n  style: ElevatedButton.styleFrom(\n    backgroundColor: Colors.white,\n    foregroundColor: Colors.black87,\n    minimumSize: const Size(double.infinity, 50),\n    shape: RoundedRectangleBorder(\n      borderRadius: BorderRadius.circular(8),\n      side: const BorderSide(color: Colors.grey),\n    ),\n  ),\n  onPressed: _signInWithGoogle,\n),\n\n              ],\n            ),\n          ),\n        ),\n      ),\n    );\n  }\n}",
        "main_screen.dart": "import 'package:family_finances/screens/add_transaction_screen.dart';\nimport 'package:flutter/material.dart';\nimport 'overview_screen.dart';\nimport 'settings_screen.dart';\n\n\nclass MainScreen extends StatefulWidget {\n  const MainScreen({super.key});\n\n  @override\n  _MainScreenState createState() => _MainScreenState();\n}\n\nclass _MainScreenState extends State<MainScreen> {\n  int _selectedIndex = 0;\n\n  static const List<Widget> _screens = <Widget>[\n    OverviewScreen(),\n    SettingsScreen(),\n  ];\n\n  void _onItemTapped(int index) {\n    setState(() {\n      _selectedIndex = index;\n    });\n  }\n\n  void _openAddTransaction(BuildContext context) {\n    showModalBottomSheet(\n      context: context,\n      isScrollControlled: true,\n      builder: (_) => const AddTransactionScreen(),\n    );\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      body: _screens.elementAt(_selectedIndex),\n      bottomNavigationBar: Stack(\n        alignment: Alignment.bottomCenter,\n        children: [\n          BottomNavigationBar(\n            items: const [\n              BottomNavigationBarItem(\n                icon: Icon(Icons.home),\n                label: 'Início',\n              ),\n              BottomNavigationBarItem(\n                icon: Icon(Icons.settings),\n                label: 'Configurações',\n              ),\n            ],\n            currentIndex: _selectedIndex,\n            onTap: _onItemTapped,\n          ),\n          Positioned(\n            bottom: 0,\n            left: 0,\n            right: 0,\n            child: Center(\n              child: FloatingActionButton(\n                onPressed: () => _openAddTransaction(context),\n                backgroundColor: const Color(0xFF2A8782),\n                child: const Icon(Icons.add, size: 32, color: Colors.white),\n              ),\n            ),\n          ),\n        ],\n      ),\n    );\n  }\n}",
        "nfce_import_screen.dart": "import 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:family_finances/models/nfce.dart';\nimport 'package:http/http.dart' as http;\n// Para parsear a data\nimport 'package:xml/xml.dart' as xml;\nimport 'dart:async'; // Para TimeoutException\nimport '../models/nfce_item_detail.dart'; // Importa a nova classe\n\n// A classe NfceData foi removida, usamos Nfce diretamente\n\nclass NfceService {\n\n  // Função auxiliar interna para buscar texto de forma segura\n  String _getElementText(xml.XmlElement parent, String elementName, {String defaultValue = ''}) {\n      try {\n        // Usa .firstWhereOrNull (da collection) ou .firstOrNull se disponível diretamente\n        // Alternativa segura: findElements().firstOrNull\n         final element = parent.findElements(elementName).firstOrNull;\n         return element?.innerText.trim() ?? defaultValue;\n      } catch (e) {\n        print(\"Erro ao buscar elemento $elementName: $e\");\n        return defaultValue;\n      }\n  }\n\n  // Função auxiliar para buscar atributo de forma segura\n  String _getAttribute(xml.XmlElement element, String attributeName, {String defaultValue = ''}) {\n    return element.getAttribute(attributeName) ?? defaultValue;\n  }\n\n\n  Future<Nfce> fetchAndParseNfce(String url, String userId) async {\n    print('Iniciando busca da NFC-e: $url');\n    try {\n      // Adiciona um timeout à requisição para evitar travamentos\n      final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 20));\n      print('Resposta recebida: ${response.statusCode}');\n\n      if (response.statusCode == 200) {\n        final document = xml.XmlDocument.parse(response.body);\n\n        // Busca os elementos principais de forma mais segura\n        final nfeElement = document.findAllElements('NFe').firstOrNull;\n        if (nfeElement == null) throw Exception('Elemento <NFe> não encontrado no XML.');\n\n        final infNFeElement = nfeElement.getElement('infNFe');\n        if (infNFeElement == null) throw Exception('Elemento <infNFe> não encontrado no XML.');\n\n        final ideElement = infNFeElement.getElement('ide');\n        if (ideElement == null) throw Exception('Elemento <ide> não encontrado no XML.');\n\n        final emitElement = infNFeElement.getElement('emit');\n        if (emitElement == null) throw Exception('Elemento <emit> não encontrado no XML.');\n\n        final totalElement = infNFeElement.getElement('total')?.getElement('ICMSTot');\n        if (totalElement == null) throw Exception('Elemento <ICMSTot> não encontrado no XML.');\n\n        final infAdicElement = infNFeElement.getElement('infAdic'); // Pode ser nulo\n\n        // --- Extração dos Detalhes da Nota ---\n        final String nfceKey = _getAttribute(infNFeElement, 'Id').replaceAll('NFe', '');\n        final String storeName = _getElementText(emitElement, 'xNome', defaultValue: 'Loja Desconhecida');\n        final String totalValueText = _getElementText(totalElement, 'vNF');\n        final double totalValue = double.tryParse(totalValueText) ?? 0.0;\n        final String dateText = _getElementText(ideElement, 'dhEmi');\n\n        // Parse da data\n        Timestamp date = Timestamp.now(); // Valor padrão\n         try {\n           // Formato ISO 8601 com timezone offset: 2025-09-24T17:46:33-03:00\n            DateTime parsedDate = DateTime.parse(dateText);\n            date = Timestamp.fromDate(parsedDate);\n         } catch(e) {\n           print(\"Erro ao parsear data da NFC-e ('$dateText'): $e. Usando data atual.\");\n         }\n\n         // --- Extração das Informações Adicionais (Impostos) ---\n        String taxInfo = '';\n        if (infAdicElement != null) {\n          taxInfo = _getElementText(infAdicElement, 'infCpl');\n          // Tenta extrair apenas a parte dos tributos\n           final tribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+ Federal.*? R\\$[\\d,\\.]+ Estadual.*?Fonte IBPT');\n           final match = tribRegex.firstMatch(taxInfo);\n           if (match != null) {\n             taxInfo = match.group(0)!; // Pega só a parte dos tributos\n           } else {\n             // Se não encontrar o padrão exato, tenta um padrão mais simples\n             final simpleTribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+');\n             final simpleMatch = simpleTribRegex.firstMatch(taxInfo);\n             taxInfo = simpleMatch?.group(0) ?? ''; // Pega o que encontrar ou deixa vazio\n           }\n        }\n         print('Tax Info extraída: $taxInfo');\n\n        // --- Extração dos Itens ---\n        final productsXml = infNFeElement.findAllElements('det');\n        final List<NfceItemDetail> items = [];\n        print('Encontrados ${productsXml.length} elementos <det>');\n        for (final productElement in productsXml) {\n          final prodElement = productElement.getElement('prod');\n          if (prodElement == null) {\n             print('Elemento <det> sem <prod>, pulando.');\n             continue; // Pula se não houver <prod>\n          }\n\n          final String name = _getElementText(prodElement, 'xProd');\n          final String qtyText = _getElementText(prodElement, 'qCom');\n          final String unitPriceText = _getElementText(prodElement, 'vUnCom');\n          final String totalPriceText = _getElementText(prodElement, 'vProd');\n\n          final double quantity = double.tryParse(qtyText) ?? 0;\n          final double unitPrice = double.tryParse(unitPriceText) ?? 0;\n          final double totalPrice = double.tryParse(totalPriceText) ?? 0;\n\n          print('Item encontrado: $name, Qtd: $quantity, VlUnit: $unitPrice, VlTotal: $totalPrice');\n\n          if (name.isNotEmpty) {\n            items.add(NfceItemDetail(\n              name: name.trim(), // Remove espaços extras\n              quantity: quantity,\n              unitPrice: unitPrice,\n              totalPrice: totalPrice,\n            ));\n          } else {\n             print('Item sem nome (<xProd>) encontrado, pulando.');\n          }\n        }\n\n        if (items.isEmpty && totalValue == 0) {\n           print('Nenhum item ou valor total encontrado no XML.');\n           throw Exception('Nenhum dado relevante (itens ou valor total) encontrado no XML da NFC-e.');\n        }\n\n        print('NFC-e parseada com sucesso. Itens: ${items.length}, Valor: $totalValue');\n        // Cria e retorna o objeto Nfce completo\n        return Nfce(\n          nfceKey: nfceKey,\n          storeName: storeName,\n          totalValue: totalValue,\n          date: date,\n          taxInfo: taxInfo,\n          items: items,\n        );\n      } else {\n        print('Erro na requisição HTTP: ${response.statusCode}');\n        throw Exception('Falha ao carregar a página da NFC-e. Código de status: ${response.statusCode}');\n      }\n    } on TimeoutException {\n       print('Timeout ao buscar NFC-e.');\n       throw Exception('Tempo limite excedido ao buscar dados da NFC-e. Verifique sua conexão.');\n    } catch (e) {\n       print(\"Erro detalhado no fetchAndParseNfce: $e\");\n       // Re-lança a exceção para ser tratada na UI, talvez com uma mensagem mais amigável\n       throw Exception('Ocorreu um erro ao processar a NFC-e: ${e.toString()}');\n    }\n  }\n}\n\n// Extensão para firstOrNull em Iterables (segurança)\nextension FirstOrNullExtension<E> on Iterable<E> {\n  E? get firstOrNull {\n    return isEmpty ? null : first;\n  }\n}\n\n",
        "overview_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport 'package:intl/intl.dart';\n\nimport '../models/finance_state.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\n\nimport '../styles/app_colors.dart';\nimport 'add_transaction_screen.dart';\n// 1. Importar a tela de configurações\nimport 'settings_screen.dart';\n\nclass OverviewScreen extends StatefulWidget {\n  const OverviewScreen({super.key});\n\n  @override\n  State<OverviewScreen> createState() => _OverviewScreenState();\n}\n\nclass _OverviewScreenState extends State<OverviewScreen> {\n  String _filter = \"all\";\n  \n  // 2. Criar a chave para controlar o Scaffold e abrir a gaveta\n  final GlobalKey<ScaffoldState> _scaffoldKey = GlobalKey<ScaffoldState>();\n\n  @override\n  Widget build(BuildContext context) {\n    final finance = Provider.of<FinanceState>(context);\n\n    final expenses = finance.expenses;\n    final receipts = finance.receipts;\n\n    final allTransactions = [\n      ...expenses.map((e) => _TransactionItem.expense(e)),\n      ...receipts.map((r) => _TransactionItem.receipt(r)),\n    ]..sort((a, b) => b.date.compareTo(a.date));\n\n    final visible = _filter == \"all\"\n        ? allTransactions\n        : allTransactions.where((t) => t.type == _filter).toList();\n\n    final totalExpenses = expenses.fold(0.0, (sum, e) => sum + e.value);\n    final totalReceipts = receipts.fold(0.0, (sum, r) => sum + r.value);\n    final balance = totalReceipts - totalExpenses;\n\n    return Scaffold(\n      key: _scaffoldKey, // 3. Atribuir a chave ao Scaffold\n      backgroundColor: AppColors.secondary,\n      \n      // 4. Definir o endDrawer (Gaveta da direita)\n      endDrawer: const SizedBox(\n        // Define uma largura para a gaveta não ocupar 100% da tela\n        width: 300, \n        child: SettingsScreen(), \n      ),\n\n      appBar: AppBar(\n        backgroundColor: AppColors.primary,\n        foregroundColor: AppColors.onPrimary,\n        title: const Text(\"Visão Geral\"),\n        centerTitle: true,\n        // 5. Adicionar o botão de ação para abrir a gaveta\n        actions: [\n          IconButton(\n            icon: const Icon(Icons.settings),\n            onPressed: () {\n              // Abre a gaveta da direita (endDrawer)\n              _scaffoldKey.currentState?.openEndDrawer();\n            },\n          ),\n        ],\n      ),\n\n      floatingActionButton: FloatingActionButton.extended(\n        backgroundColor: AppColors.primary,\n        foregroundColor: AppColors.onPrimary,\n        icon: const Icon(Icons.add),\n        label: const Text(\"Adicionar\"),\n        onPressed: () => _openAddTransaction(context),\n      ),\n\n      body: Column(\n        children: [\n          _buildHeader(balance, totalExpenses, totalReceipts),\n          const SizedBox(height: 10),\n          _buildFilterChips(),\n          const SizedBox(height: 10),\n          Expanded(\n            child: visible.isEmpty\n                ? _buildEmpty()\n                : ListView.builder(\n                    padding: const EdgeInsets.all(12),\n                    itemCount: visible.length,\n                    itemBuilder: (_, i) => _buildTransactionTile(visible[i]),\n                  ),\n          ),\n        ],\n      ),\n    );\n  }\n\n  // =============================================================================================\n  // HEADER\n  // =============================================================================================\n  Widget _buildHeader(double balance, double expenses, double receipts) {\n    return Container(\n      width: double.infinity,\n      padding: const EdgeInsets.all(20),\n      color: AppColors.primary,\n      child: Column(\n        crossAxisAlignment: CrossAxisAlignment.start,\n        children: [\n          Text(\n            \"Saldo Atual\",\n            style: TextStyle(\n              color: AppColors.onPrimary.withOpacity(0.8),\n              fontSize: 14,\n            ),\n          ),\n          const SizedBox(height: 5),\n          Text(\n            \"R\\$ ${balance.toStringAsFixed(2).replaceAll('.', ',')}\",\n            style: const TextStyle(\n              fontSize: 32,\n              fontWeight: FontWeight.bold,\n              color: AppColors.onPrimary,\n            ),\n          ),\n          const SizedBox(height: 20),\n          Row(\n            children: [\n              _buildSummaryTile(\n                \"Receitas\",\n                receipts,\n                Icons.arrow_upward,\n                Colors.green.shade300,\n              ),\n              const SizedBox(width: 16),\n              _buildSummaryTile(\n                \"Despesas\",\n                expenses,\n                Icons.arrow_downward,\n                Colors.red.shade300,\n              ),\n            ],\n          )\n        ],\n      ),\n    );\n  }\n\n  Widget _buildSummaryTile(\n      String label, double value, IconData icon, Color color) {\n    return Expanded(\n      child: Container(\n        padding: const EdgeInsets.all(14),\n        decoration: BoxDecoration(\n          color: AppColors.surface,\n          borderRadius: BorderRadius.circular(12),\n        ),\n        child: Row(\n          children: [\n            CircleAvatar(\n              radius: 18,\n              backgroundColor: color,\n              child: Icon(icon, color: Colors.white),\n            ),\n            const SizedBox(width: 10),\n            Column(\n              crossAxisAlignment: CrossAxisAlignment.start,\n              children: [\n                Text(label, style: const TextStyle(fontSize: 12)),\n                Text(\n                  \"R\\$ ${value.toStringAsFixed(2).replaceAll('.', ',')}\",\n                  style: const TextStyle(\n                      fontSize: 16, fontWeight: FontWeight.bold),\n                ),\n              ],\n            )\n          ],\n        ),\n      ),\n    );\n  }\n\n  // =============================================================================================\n  // FILTER CHIPS\n  // =============================================================================================\n  Widget _buildFilterChips() {\n    return Padding(\n      padding: const EdgeInsets.symmetric(horizontal: 14),\n      child: Row(\n        children: [\n          _chip(\"Todos\", \"all\"),\n          const SizedBox(width: 12),\n          _chip(\"Despesas\", \"expense\"),\n          const SizedBox(width: 12),\n          _chip(\"Receitas\", \"receipt\"),\n        ],\n      ),\n    );\n  }\n\n  Widget _chip(String label, String key) {\n    final selected = _filter == key;\n    return ChoiceChip(\n      selected: selected,\n      selectedColor: AppColors.primary,\n      backgroundColor: Colors.grey.shade300,\n      label: Text(\n        label,\n        style: TextStyle(\n          color: selected ? AppColors.onPrimary : Colors.black87,\n        ),\n      ),\n      onSelected: (_) => setState(() => _filter = key),\n    );\n  }\n\n  // =============================================================================================\n  // EMPTY STATE\n  // =============================================================================================\n  Widget _buildEmpty() {\n    return Center(\n      child: Text(\n        \"Nenhuma transação ainda\",\n        style: TextStyle(\n          color: Colors.grey.shade700,\n          fontSize: 16,\n        ),\n      ),\n    );\n  }\n\n  // =============================================================================================\n  // LIST TILE (CARD)\n  // =============================================================================================\n  Widget _buildTransactionTile(_TransactionItem t) {\n    final isExpense = t.type == \"expense\";\n\n    return GestureDetector(\n      onTap: () => _openAddTransaction(context, edit: t),\n      child: Container(\n        margin: const EdgeInsets.only(bottom: 12),\n        padding: const EdgeInsets.all(14),\n        decoration: BoxDecoration(\n          color: AppColors.surface,\n          borderRadius: BorderRadius.circular(12),\n          boxShadow: [\n            BoxShadow(\n              color: Colors.black12.withOpacity(0.06),\n              blurRadius: 4,\n              offset: const Offset(0, 2),\n            )\n          ],\n        ),\n        child: Row(\n          children: [\n            // ÍCONE\n            CircleAvatar(\n              radius: 22,\n              backgroundColor:\n                  isExpense ? Colors.red.shade100 : Colors.green.shade100,\n              child: Icon(\n                isExpense\n                    ? t.expense!.category.icon\n                    : t.receipt!.category.icon,\n                color: Colors.black87,\n              ),\n            ),\n            const SizedBox(width: 14),\n\n            // CONTEÚDO CENTRAL\n            Expanded(\n              child: Column(\n                crossAxisAlignment: CrossAxisAlignment.start,\n                children: [\n                  Text(\n                    t.title,\n                    style: const TextStyle(\n                      fontWeight: FontWeight.w600,\n                      fontSize: 16,\n                    ),\n                  ),\n                  const SizedBox(height: 4),\n                  Row(\n                    children: [\n                      Text(\n                        DateFormat(\"dd MMM\").format(t.date),\n                        style: TextStyle(\n                            fontSize: 12, color: Colors.grey.shade700),\n                      ),\n                      const SizedBox(width: 8),\n                      ..._buildBadges(t),\n                    ],\n                  )\n                ],\n              ),\n            ),\n\n            // VALOR\n            Text(\n              (isExpense ? \"-\" : \"+\") +\n                  \" R\\$ ${t.value.toStringAsFixed(2).replaceAll('.', ',')}\",\n              style: TextStyle(\n                color: isExpense ? Colors.red : Colors.green.shade700,\n                fontSize: 16,\n                fontWeight: FontWeight.bold,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  List<Widget> _buildBadges(_TransactionItem t) {\n    final List<Widget> badges = [];\n\n    if (t.isShared) badges.add(_badge(\"Compartilhado\", Colors.blue));\n\n    if (t.isInInstallments) {\n      badges.add(_badge(\"${t.installmentCount}x\", Colors.orange));\n    }\n\n    if (t.isRecurrent) {\n      badges.add(_badge(\"Recorrente\", Colors.purple));\n    }\n\n    return badges;\n  }\n\n  Widget _badge(String text, Color color) {\n    return Container(\n      margin: const EdgeInsets.only(left: 6),\n      padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),\n      decoration: BoxDecoration(\n        color: color.withOpacity(0.18),\n        borderRadius: BorderRadius.circular(6),\n      ),\n      child: Text(\n        text,\n        style: TextStyle(\n          color: Colors.black45,\n          fontSize: 10,\n          fontWeight: FontWeight.bold,\n        ),\n      ),\n    );\n  }\n\n  // =============================================================================================\n  // NAVIGATION\n  // =============================================================================================\n  void _openAddTransaction(BuildContext context,\n      { _TransactionItem? edit }) {\n    Navigator.push(\n      context,\n      MaterialPageRoute(\n        builder: (_) => AddTransactionScreen(\n          expenseToEdit: edit?.expense,\n          receiptToEdit: edit?.receipt,\n        ),\n      ),\n    );\n  }\n}\n\n\n// =============================================================================================\n// INTERNAL WRAPPER MODEL (para unificar despesas e receitas)\n// =============================================================================================\nclass _TransactionItem {\n  final String type; // \"expense\" | \"receipt\"\n  final DateTime date;\n  final double value;\n  final String title;\n\n  final Expense? expense;\n  final Receipt? receipt;\n\n  bool get isRecurrent =>\n      expense?.isRecurrent == true || receipt?.isRecurrent == true;\n\n  bool get isShared =>\n      expense?.isShared == true || receipt?.isShared == true;\n\n  bool get isInInstallments => expense?.isInInstallments == true;\n\n  int? get installmentCount => expense?.installmentCount;\n\n  _TransactionItem.expense(Expense e)\n      : type = \"expense\",\n        date = e.date,\n        value = e.value,\n        title = e.title,\n        expense = e,\n        receipt = null;\n\n  _TransactionItem.receipt(Receipt r)\n      : type = \"receipt\",\n        date = r.date,\n        value = r.value,\n        title = r.title,\n        expense = null,\n        receipt = r;\n}",
        "qr_code_scanner_screen.dart": "import 'package:mobile_scanner/mobile_scanner.dart';\nimport 'package:flutter/material.dart';\n\nclass QRCodeScannerScreen extends StatelessWidget {\n  const QRCodeScannerScreen({super.key});\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(title: const Text('Ler QR Code da NFC-e')),\n      body: MobileScanner(\n        controller: MobileScannerController(\n          detectionSpeed: DetectionSpeed.noDuplicates, // Evita detecções repetidas\n          facing: CameraFacing.back,\n        ),\n        onDetect: (capture) {\n          final List<Barcode> barcodes = capture.barcodes;\n          if (barcodes.isNotEmpty) {\n            final String? url = barcodes.first.rawValue;\n            // Garante que o URL não é nulo e que o ecrã ainda está ativo\n            if (url != null && context.mounted) {\n              // Fecha o scanner e devolve o URL como resultado\n              Navigator.of(context).pop(url);\n            }\n          }\n        },\n      ),\n    );\n  }\n}",
        "receipts_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\nimport 'package:provider/provider.dart';\nimport 'package:family_finances/models/receipt_category.dart';\nimport '../models/finance_state.dart';\nimport '../models/receipt.dart';\n\nclass ReceiptsScreen extends StatefulWidget {\n  const ReceiptsScreen({super.key});\n\n  @override\n  State<ReceiptsScreen> createState() => _ReceiptsScreenState();\n}\n\nclass _ReceiptsScreenState extends State<ReceiptsScreen> {\n  final TextEditingController _titleController = TextEditingController();\n  final TextEditingController _valueController = TextEditingController();\n  DateTime _selectedDate = DateTime.now(); // NOVO\n\n  @override\n  Widget build(BuildContext context) {\n    const Color primaryColor = Color(0xFF2A8782);\n    final financeState = Provider.of<FinanceState>(context);\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Receitas')),\n      body: Padding(\n        padding: const EdgeInsets.all(16.0),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.stretch,\n          children: [\n            Text(\n              'R\\$ ${financeState.totalReceitas.toStringAsFixed(2)}',\n              style: const TextStyle(fontSize: 36, fontWeight: FontWeight.bold),\n            ),\n            const SizedBox(height: 24),\n            _buildTextField(label: 'Título', hint: 'Título da receita', controller: _titleController),\n            const SizedBox(height: 16),\n            _buildTextField(label: 'Valor', hint: '0,00', controller: _valueController),\n            const SizedBox(height: 16),\n            _buildDatePicker(context), // NOVO\n            const Spacer(),\n            ElevatedButton(\n              onPressed: () {\n                if (_titleController.text.isNotEmpty &&\n                    _valueController.text.isNotEmpty) {\n                  final receipt = Receipt(\n                    title: _titleController.text,\n                    value: double.tryParse(_valueController.text.replaceAll(',', '.')) ?? 0,\n                    date: _selectedDate,\n                    category: ReceiptCategory(name: 'Outros', icon: Icons.category),\n                    isRecurrent: false,\n                  );\n                  Provider.of<FinanceState>(context, listen: false).addReceipt(receipt);\n                  _titleController.clear();\n                  _valueController.clear();\n                  setState(() {\n                    _selectedDate = DateTime.now();\n                  });\n                  ScaffoldMessenger.of(context).showSnackBar(\n                    const SnackBar(content: Text('Receita salva!')),\n                  );\n                }\n              },\n              style: ElevatedButton.styleFrom(\n                backgroundColor: primaryColor,\n                padding: const EdgeInsets.symmetric(vertical: 16),\n                shape: RoundedRectangleBorder(\n                  borderRadius: BorderRadius.circular(8),\n                ),\n              ),\n              child: const Text('Salvar', style: TextStyle(fontSize: 18, color: Colors.white)),\n            ),\n            const SizedBox(height: 24),\n            const Text('Receitas cadastradas', style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold, color: Colors.grey)),\n            const Divider(),\n            Expanded(\n              child: ListView(\n                children: financeState.receipts\n                    .map((item) => _buildReceiptItem(item.title, item.value.toStringAsFixed(2), item.date))\n                    .toList(),\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n\n  Widget _buildTextField({required String label, required String hint, required TextEditingController controller, int maxLines = 1}) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Text(label, style: const TextStyle(fontWeight: FontWeight.bold, fontSize: 16)),\n        const SizedBox(height: 8),\n        TextField(\n          controller: controller,\n          maxLines: maxLines,\n          decoration: InputDecoration(\n            hintText: hint,\n            filled: true,\n            fillColor: Colors.white,\n            border: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n            enabledBorder: OutlineInputBorder(\n              borderRadius: BorderRadius.circular(8),\n              borderSide: BorderSide(color: Colors.grey.shade300),\n            ),\n          ),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildDatePicker(BuildContext context) {\n    return Row(\n      children: [\n        const Icon(Icons.calendar_today, size: 20),\n        const SizedBox(width: 8),\n        Text('Data: ${DateFormat('dd/MM/yyyy').format(_selectedDate)}'),\n        const SizedBox(width: 8),\n        TextButton(\n          onPressed: () async {\n            final picked = await showDatePicker(\n              context: context,\n              initialDate: _selectedDate,\n              firstDate: DateTime(2000),\n              lastDate: DateTime(2100),\n            );\n            if (picked != null) {\n              setState(() {\n                _selectedDate = picked;\n              });\n            }\n          },\n          child: const Text('Alterar'),\n        ),\n      ],\n    );\n  }\n\n  Widget _buildReceiptItem(String title, String value, DateTime date) {\n    return Padding(\n      padding: const EdgeInsets.symmetric(vertical: 12.0),\n      child: Row(\n        mainAxisAlignment: MainAxisAlignment.spaceBetween,\n        children: [\n          Column(\n            crossAxisAlignment: CrossAxisAlignment.start,\n            children: [\n              Text(title, style: const TextStyle(fontSize: 16)),\n              Text(DateFormat('dd/MM/yyyy').format(date), style: const TextStyle(fontSize: 12, color: Colors.grey)),\n            ],\n          ),\n          Text('R\\$ $value', style: const TextStyle(fontSize: 16, fontWeight: FontWeight.w500)),\n        ],\n      ),\n    );\n  }\n}",
        "settings_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:flutter/services.dart';\nimport 'package:provider/provider.dart';\nimport 'package:firebase_auth/firebase_auth.dart';\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:qr_flutter/qr_flutter.dart';\n\nimport '../models/finance_state.dart';\nimport 'auth_gate.dart';\nimport '../styles/app_colors.dart';\nimport 'qr_code_scanner_screen.dart';\n\nclass SettingsScreen extends StatefulWidget {\n  const SettingsScreen({super.key});\n\n  @override\n  State<SettingsScreen> createState() => _SettingsScreenState();\n}\n\nclass _SettingsScreenState extends State<SettingsScreen> {\n  final TextEditingController _partnerIdController = TextEditingController();\n  final TextEditingController _nameController = TextEditingController(); // NOVO: Controller do nome\n  bool _isLoading = false;\n  bool _isEditingName = false; // Controle de edição do nome\n\n  @override\n  void initState() {\n    super.initState();\n    // Preenche o nome atual ao iniciar\n    final state = Provider.of<FinanceState>(context, listen: false);\n    if (state.userName != null) {\n      _nameController.text = state.userName!;\n    }\n  }\n\n  @override\n  void dispose() {\n    _partnerIdController.dispose();\n    _nameController.dispose();\n    super.dispose();\n  }\n\n  Future<void> _saveName() async {\n    if (_nameController.text.trim().isEmpty) return;\n    \n    setState(() => _isLoading = true);\n    try {\n      await Provider.of<FinanceState>(context, listen: false)\n          .updateDisplayName(_nameController.text.trim());\n      \n      if (mounted) {\n         setState(() => _isEditingName = false);\n         ScaffoldMessenger.of(context).showSnackBar(\n          const SnackBar(content: Text('Nome atualizado!')),\n        );\n      }\n    } catch (e) {\n      if (mounted) {\n        ScaffoldMessenger.of(context).showSnackBar(\n          SnackBar(content: Text('Erro ao salvar nome: $e')),\n        );\n      }\n    } finally {\n      if (mounted) setState(() => _isLoading = false);\n    }\n  }\n\n  // ==============================================================================\n  // LÓGICA DE PAREAMENTO\n  // ==============================================================================\n  Future<void> _pairWithUser(String myUid, String partnerUid) async {\n    if (partnerUid.isEmpty) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Insira o código do parceiro')),\n      );\n      return;\n    }\n\n    // Remove espaços em branco acidentais\n    final cleanPartnerUid = partnerUid.trim();\n\n    if (myUid == cleanPartnerUid) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Você não pode parear consigo mesmo')),\n      );\n      return;\n    }\n\n    setState(() => _isLoading = true);\n\n    try {\n      // Gera um ID único para a coleção compartilhada (ordem alfabética para consistência)\n      final List<String> ids = [myUid, cleanPartnerUid];\n      ids.sort();\n      final String sharedCollectionId = \"${ids[0]}_${ids[1]}_shared\";\n\n      final batch = FirebaseFirestore.instance.batch();\n\n      // 1. Define o vínculo para o MEU usuário\n      final myDocRef = FirebaseFirestore.instance.collection('partnerships').doc(myUid);\n      batch.set(myDocRef, {\n        'partnerId': cleanPartnerUid,\n        'sharedCollectionId': sharedCollectionId,\n        'connectedAt': FieldValue.serverTimestamp(),\n      });\n\n      // 2. Define o vínculo para o usuário PARCEIRO\n      final partnerDocRef = FirebaseFirestore.instance.collection('partnerships').doc(cleanPartnerUid);\n      batch.set(partnerDocRef, {\n        'partnerId': myUid,\n        'sharedCollectionId': sharedCollectionId,\n        'connectedAt': FieldValue.serverTimestamp(),\n      });\n\n      await batch.commit();\n\n      ScaffoldMessenger.of(context).showSnackBar(\n        const SnackBar(content: Text('Conta vinculada com sucesso!')),\n      );\n      _partnerIdController.clear();\n      \n      if (mounted) {\n        Provider.of<FinanceState>(context, listen: false).forceNotify();\n      }\n\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Erro ao vincular: $e')),\n      );\n      print(e);\n    } finally {\n      if (mounted) setState(() => _isLoading = false);\n    }\n  }\n\n  Future<void> _unpairUser(String myUid) async {\n    final confirm = await showDialog<bool>(\n      context: context,\n      builder: (ctx) => AlertDialog(\n        title: const Text(\"Desconectar?\"),\n        content: const Text(\n            \"Isso removerá o acesso aos dados compartilhados. Os dados não serão apagados, apenas o vínculo.\"),\n        actions: [\n          TextButton(onPressed: () => Navigator.pop(ctx, false), child: const Text(\"Cancelar\")),\n          TextButton(onPressed: () => Navigator.pop(ctx, true), child: const Text(\"Desconectar\")),\n        ],\n      ),\n    );\n\n    if (confirm != true) return;\n\n    setState(() => _isLoading = true);\n\n    try {\n      final myDocSnap = await FirebaseFirestore.instance.collection('partnerships').doc(myUid).get();\n      \n      if (myDocSnap.exists) {\n        final data = myDocSnap.data();\n        final partnerId = data?['partnerId'];\n\n        final batch = FirebaseFirestore.instance.batch();\n        batch.delete(FirebaseFirestore.instance.collection('partnerships').doc(myUid));\n\n        if (partnerId != null) {\n          batch.delete(FirebaseFirestore.instance.collection('partnerships').doc(partnerId));\n        }\n\n        await batch.commit();\n      }\n\n      if (mounted) {\n        Provider.of<FinanceState>(context, listen: false).forceNotify();\n      }\n\n    } catch (e) {\n      ScaffoldMessenger.of(context).showSnackBar(\n        SnackBar(content: Text('Erro ao desconectar: $e')),\n      );\n    } finally {\n      if (mounted) setState(() => _isLoading = false);\n    }\n  }\n\n  void _copyToClipboard(String text) {\n    Clipboard.setData(ClipboardData(text: text));\n    ScaffoldMessenger.of(context).showSnackBar(\n      const SnackBar(content: Text('Código copiado!'), duration: Duration(seconds: 1)),\n    );\n  }\n\n  // CORREÇÃO IMPORTANTE: Agora chama o pareamento automaticamente\n  Future<void> _scanPartnerQrCode(String myUid) async {\n    final String? code = await Navigator.push(\n      context,\n      MaterialPageRoute(builder: (_) => const QRCodeScannerScreen()),\n    );\n\n    if (code != null && code.isNotEmpty && mounted) {\n      setState(() {\n        _partnerIdController.text = code;\n      });\n      \n      // Chama a função de pareamento automaticamente\n      await _pairWithUser(myUid, code);\n    }\n  }\n\n  void _showMyQrCode(BuildContext context, String uid) {\n    showDialog(\n      context: context,\n      builder: (ctx) => AlertDialog(\n        title: const Center(child: Text(\"Seu Código QR\")),\n        content: Column(\n          mainAxisSize: MainAxisSize.min,\n          children: [\n            SizedBox(\n              height: 200,\n              width: 200,\n              child: QrImageView(\n                data: uid,\n                version: QrVersions.auto,\n                size: 200.0,\n                backgroundColor: Colors.white,\n              ),\n            ),\n            const SizedBox(height: 16),\n            const Text(\n              \"Peça para seu parceiro escanear este código no app dele.\",\n              textAlign: TextAlign.center,\n              style: TextStyle(fontSize: 12, color: Colors.grey),\n            ),\n          ],\n        ),\n        actions: [\n          TextButton(\n            onPressed: () => Navigator.pop(ctx),\n            child: const Text(\"Fechar\"),\n          ),\n        ],\n      ),\n    );\n  }\n\n  // ==============================================================================\n  // UI\n  // ==============================================================================\n  @override\n  Widget build(BuildContext context) {\n    final state = Provider.of<FinanceState>(context);\n    final user = FirebaseAuth.instance.currentUser;\n    final hasPartnership = state.hasPartnership;\n    \n    // Atualiza controller se o nome mudar externamente e não estiver editando\n    if (!_isEditingName && state.userName != null && _nameController.text != state.userName) {\n      _nameController.text = state.userName!;\n    }\n\n    return Scaffold(\n      backgroundColor: AppColors.secondary,\n      appBar: AppBar(\n        title: const Text('Configurações'),\n        backgroundColor: AppColors.primary,\n        foregroundColor: AppColors.onPrimary,\n      ),\n      body: _isLoading \n        ? const Center(child: CircularProgressIndicator())\n        : ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          // -------------------------------------------------------\n          // PERFIL\n          // -------------------------------------------------------\n          if (user != null)\n            _buildSectionCard(\n              title: \"Perfil\",\n              children: [\n                Padding(\n                  padding: const EdgeInsets.all(16.0),\n                  child: Row(\n                    children: [\n                      CircleAvatar(\n                        radius: 30,\n                        backgroundColor: AppColors.primary.withOpacity(0.2),\n                        child: const Icon(Icons.person, color: AppColors.primary, size: 30),\n                      ),\n                      const SizedBox(width: 16),\n                      Expanded(\n                        child: Column(\n                          crossAxisAlignment: CrossAxisAlignment.start,\n                          children: [\n                            // EDITOR DE NOME\n                            if (_isEditingName)\n                              Row(\n                                children: [\n                                  Expanded(\n                                    child: TextField(\n                                      controller: _nameController,\n                                      autofocus: true,\n                                      decoration: const InputDecoration(\n                                        hintText: \"Seu nome\",\n                                        isDense: true,\n                                      ),\n                                    ),\n                                  ),\n                                  IconButton(\n                                    icon: const Icon(Icons.check, color: Colors.green),\n                                    onPressed: _saveName,\n                                  ),\n                                  IconButton(\n                                    icon: const Icon(Icons.close, color: Colors.red),\n                                    onPressed: () {\n                                      setState(() {\n                                        _isEditingName = false;\n                                        _nameController.text = state.userName ?? '';\n                                      });\n                                    },\n                                  ),\n                                ],\n                              )\n                            else\n                              Row(\n                                children: [\n                                  Text(\n                                    state.userName ?? 'Nome',\n                                    style: const TextStyle(fontSize: 18, fontWeight: FontWeight.bold),\n                                  ),\n                                  IconButton(\n                                    icon: const Icon(Icons.edit, size: 16, color: Colors.grey),\n                                    onPressed: () => setState(() => _isEditingName = true),\n                                  )\n                                ],\n                              ),\n                            \n                            Text(user.email ?? '', style: TextStyle(color: Colors.grey[600], fontSize: 12)),\n                          ],\n                        ),\n                      ),\n                    ],\n                  ),\n                ),\n                const Divider(height: 1),\n                ListTile(\n                  leading: const Icon(Icons.logout, color: Colors.red),\n                  title: const Text('Sair da Conta', style: TextStyle(color: Colors.red)),\n                  onTap: () async {\n                    await FirebaseAuth.instance.signOut();\n                    state.forceNotify();\n                    if (context.mounted) {\n                      Navigator.pushAndRemoveUntil(\n                        context,\n                        MaterialPageRoute(builder: (_) => const AuthGate()),\n                        (_) => false,\n                      );\n                    }\n                  },\n                ),\n              ],\n            ),\n\n          const SizedBox(height: 20),\n\n          // -------------------------------------------------------\n          // PAREAMENTO FAMILIAR\n          // -------------------------------------------------------\n          if (user != null)\n            _buildSectionCard(\n              title: \"Pareamento Familiar\",\n              children: [\n                if (hasPartnership) ...[\n                  // ESTADO: PAREADO\n                  Container(\n                    width: double.infinity,\n                    padding: const EdgeInsets.all(16),\n                    color: Colors.green.shade50,\n                    child: Column(\n                      children: [\n                        const Icon(Icons.check_circle, color: Colors.green, size: 40),\n                        const SizedBox(height: 8),\n                        Text(\n                          state.partnerName != null \n                             ? \"Conectado com ${state.partnerName}\" \n                             : \"Você está conectado!\",\n                          style: const TextStyle(fontWeight: FontWeight.bold, color: Colors.green, fontSize: 16),\n                        ),\n                        const SizedBox(height: 4),\n                        Text(\n                          \"ID: ${state.currentPartnerId.substring(0, 8)}...\",\n                          style: const TextStyle(fontSize: 12, color: Colors.black54),\n                        ),\n                      ],\n                    ),\n                  ),\n                  Padding(\n                    padding: const EdgeInsets.all(16.0),\n                    child: OutlinedButton.icon(\n                      onPressed: () => _unpairUser(user.uid),\n                      icon: const Icon(Icons.link_off),\n                      label: const Text(\"Desconectar Parceria\"),\n                      style: OutlinedButton.styleFrom(foregroundColor: Colors.red),\n                    ),\n                  ),\n                ] else ...[\n                  // ESTADO: NÃO PAREADO\n                  const Padding(\n                    padding: EdgeInsets.fromLTRB(16, 16, 16, 8),\n                    child: Text(\n                      \"Conecte-se com seu parceiro(a) para sincronizar despesas.\",\n                      style: TextStyle(color: Colors.grey),\n                    ),\n                  ),\n                  \n                  // Mostrar Meu Código\n                  ListTile(\n                    title: const Text(\"Seu Código\"),\n                    subtitle: Text(\n                      user.uid,\n                      style: const TextStyle(fontFamily: 'monospace', fontWeight: FontWeight.bold, fontSize: 12),\n                      overflow: TextOverflow.ellipsis,\n                    ),\n                    trailing: Row(\n                      mainAxisSize: MainAxisSize.min,\n                      children: [\n                        IconButton(\n                          icon: const Icon(Icons.qr_code, color: AppColors.primary),\n                          tooltip: \"Mostrar QR Code\",\n                          onPressed: () => _showMyQrCode(context, user.uid),\n                        ),\n                        IconButton(\n                          icon: const Icon(Icons.copy),\n                          tooltip: \"Copiar ID\",\n                          onPressed: () => _copyToClipboard(user.uid),\n                        ),\n                      ],\n                    ),\n                  ),\n                  \n                  const Divider(),\n                  \n                  // Inserir Código do Parceiro\n                  Padding(\n                    padding: const EdgeInsets.all(16),\n                    child: Column(\n                      crossAxisAlignment: CrossAxisAlignment.stretch,\n                      children: [\n                        TextField(\n                          controller: _partnerIdController,\n                          decoration: InputDecoration(\n                            labelText: \"Código do Parceiro\",\n                            hintText: \"Cole ou escaneie\",\n                            border: const OutlineInputBorder(),\n                            prefixIcon: const Icon(Icons.link),\n                            // Botão para abrir scanner\n                            suffixIcon: IconButton(\n                              icon: const Icon(Icons.qr_code_scanner),\n                              onPressed: () => _scanPartnerQrCode(user.uid),\n                              tooltip: \"Ler QR Code\",\n                            ),\n                          ),\n                        ),\n                        const SizedBox(height: 12),\n                        ElevatedButton(\n                          onPressed: () => _pairWithUser(user.uid, _partnerIdController.text.trim()),\n                          style: ElevatedButton.styleFrom(\n                            backgroundColor: AppColors.primary,\n                            foregroundColor: Colors.white,\n                            padding: const EdgeInsets.symmetric(vertical: 14),\n                          ),\n                          child: const Text(\"Conectar Manualmente\"),\n                        ),\n                      ],\n                    ),\n                  ),\n                ],\n              ],\n            ),\n\n          if (user == null)\n            _buildSectionCard(\n              title: \"Acesso\",\n              children: [\n                const Padding(\n                  padding: EdgeInsets.all(16.0),\n                  child: Text(\"Faça login para salvar seus dados na nuvem e compartilhar com a família.\"),\n                ),\n                Padding(\n                  padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),\n                  child: ElevatedButton(\n                    onPressed: () {\n                      Navigator.push(\n                        context,\n                        MaterialPageRoute(builder: (_) => const AuthGate()),\n                      );\n                    },\n                    child: const Text('Login / Criar Conta'),\n                  ),\n                ),\n              ],\n            ),\n        ],\n      ),\n    );\n  }\n\n  Widget _buildSectionCard({required String title, required List<Widget> children}) {\n    return Column(\n      crossAxisAlignment: CrossAxisAlignment.start,\n      children: [\n        Padding(\n          padding: const EdgeInsets.only(left: 4, bottom: 8),\n          child: Text(\n            title.toUpperCase(),\n            style: TextStyle(\n              color: Colors.grey.shade600,\n              fontWeight: FontWeight.bold,\n              fontSize: 12,\n              letterSpacing: 1.2,\n            ),\n          ),\n        ),\n        Container(\n          decoration: BoxDecoration(\n            color: Colors.white,\n            borderRadius: BorderRadius.circular(12),\n            boxShadow: [\n              BoxShadow(\n                color: Colors.black.withOpacity(0.05),\n                blurRadius: 5,\n                offset: const Offset(0, 2),\n              )\n            ],\n          ),\n          child: Column(\n            children: children,\n          ),\n        ),\n      ],\n    );\n  }\n}",
        "shopping_list_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:provider/provider.dart';\nimport '../models/finance_state.dart';\nimport '../models/product.dart';\n\nclass ShoppingListScreen extends StatefulWidget {\n  const ShoppingListScreen({super.key});\n\n  @override\n  State<ShoppingListScreen> createState() => _ShoppingListScreenState();\n}\n\nclass _ShoppingListScreenState extends State<ShoppingListScreen> {\n  final _controller = TextEditingController();\n\n  @override\n  Widget build(BuildContext context) {\n    final state = Provider.of<FinanceState>(context);\n    final products = state.shoppingListProducts;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Lista de Compras')),\n      body: ListView(\n        padding: const EdgeInsets.all(16),\n        children: [\n          TextField(\n            controller: _controller,\n            decoration: const InputDecoration(\n              labelText: 'Novo item',\n              suffixIcon: Icon(Icons.add),\n            ),\n            onSubmitted: (value) async {\n              if (value.trim().isEmpty) return;\n              await state.addProduct(Product(\n                id: null,\n                name: value.trim(),\n                category: state.productCategories.first,\n                isChecked: false,\n              ));\n              _controller.clear();\n            },\n          ),\n          const SizedBox(height: 16),\n          ...products.map(\n            (p) => ListTile(\n              title: Text(p.name),\n              leading: Checkbox(\n                value: p.isChecked,\n                onChanged: (v) => state.toggleProductChecked(p, v ?? false),\n              ),\n              trailing: IconButton(\n                icon: const Icon(Icons.delete),\n                onPressed: () => state.deleteProduct(p.id ?? p.localId.toString()),\n              ),\n            ),\n          )\n        ],\n      ),\n    );\n  }\n}\n",
        "transaction_detail_screen.dart": "import 'package:flutter/material.dart';\nimport 'package:intl/intl.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\n\nclass TransactionDetailScreen extends StatelessWidget {\n  final Expense? expenseToShow;\n  final Receipt? receiptToShow;\n  const TransactionDetailScreen({super.key, this.expenseToShow, this.receiptToShow});\n\n  @override\n  Widget build(BuildContext context) {\n    final isExpense = expenseToShow != null;\n    final title = isExpense ? expenseToShow!.title : receiptToShow!.title;\n    final value = isExpense ? expenseToShow!.value : receiptToShow!.value;\n    final categoryIcon = isExpense ? expenseToShow!.category.icon : receiptToShow!.category.icon;\n    final date = isExpense ? expenseToShow!.date : receiptToShow!.date;\n    final note = isExpense ? expenseToShow!.note : receiptToShow!.note;\n\n    return Scaffold(\n      appBar: AppBar(title: const Text('Detalhes')),\n      body: Padding(\n        padding: const EdgeInsets.all(16),\n        child: Column(\n          children: [\n            Icon(categoryIcon, size: 40),\n            const SizedBox(height: 16),\n            Text(title, style: const TextStyle(fontSize: 22)),\n            const SizedBox(height: 8),\n            Text('R\\$ ${value.toStringAsFixed(2)}'),\n            const SizedBox(height: 8),\n            Text(DateFormat('dd/MM/yyyy').format(date)),\n            const SizedBox(height: 16),\n            Expanded(\n              child: SingleChildScrollView(child: Text(note ?? '')),\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}\n"
    },
    "services": {
        "firestore_service.dart": "// lib/services/firestore_service.dart\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport '../models/expense.dart';\nimport '../models/receipt.dart';\nimport '../models/product.dart';\nimport '../models/product_category.dart';\n\nclass FirestoreService {\n  final String uid;\n  FirestoreService({required this.uid});\n\n  CollectionReference get _usersCollection => FirebaseFirestore.instance.collection('users');\n\n  // withConverter helpers\n  CollectionReference<Map<String, dynamic>> _subcol(String name) =>\n      _usersCollection.doc(uid).collection(name).withConverter<Map<String, dynamic>>(\n        fromFirestore: (snap, _) => snap.data() ?? <String, dynamic>{},\n        toFirestore: (map, _) => map,\n      );\n\n  CollectionReference get _expensesCollection => _usersCollection.doc(uid).collection('expenses');\n  CollectionReference get _receiptsCollection => _usersCollection.doc(uid).collection('receipts');\n  CollectionReference get _productsCollection => _usersCollection.doc(uid).collection('products');\n  CollectionReference get _productCategoriesCollection => _usersCollection.doc(uid).collection('productCategories');\n\n  // Expenses\n  Future<void> addExpense(Expense expense, {String? sharedCollectionId}) =>\n      _expensesCollection.add(expense.toMapForFirestore());\n\n  Future<void> updateExpense(Expense expense) =>\n      _expensesCollection.doc(expense.id).update(expense.toMapForFirestore());\n\n  Future<void> deleteExpense(String id) => _expensesCollection.doc(id).delete();\n\n  Stream<List<Expense>> getExpensesStream() {\n    print(_expensesCollection);\n    return _expensesCollection\n        .orderBy('date', descending: true)\n        .snapshots()\n        .map((snap) => snap.docs.map((doc) {\n              final map = doc.data() as Map<String, dynamic>;\n              // Normalize date if Timestamp\n              if (map['date'] is Timestamp) {\n                map['date'] = (map['date'] as Timestamp).toDate();\n              }\n              map['categoryId'] = map['categoryId'] ?? 'indefinida';\n              map['categoryName'] = map['categoryName'] ?? 'Outros';\n              return Expense.fromMapFromFirestore(map, doc.id);\n            }).toList());\n  }\n\n  // Receipts\n  Future<void> addReceipt(Receipt receipt) =>\n      _receiptsCollection.add(receipt.toMapForFirestore());\n\n  Future<void> updateReceipt(Receipt receipt) =>\n      _receiptsCollection.doc(receipt.id).update(receipt.toMapForFirestore());\n\n  Future<void> deleteReceipt(String id) => _receiptsCollection.doc(id).delete();\n\n  Stream<List<Receipt>> getReceiptsStream() {\n    print(_receiptsCollection);\n    return _receiptsCollection\n        .orderBy('date', descending: true)\n        .snapshots()\n        .map((snap) => snap.docs.map((doc) {\n              final map = doc.data() as Map<String, dynamic>;\n              if (map['date'] is Timestamp) map['date'] = (map['date'] as Timestamp).toDate();\n              map['categoryId'] = map['categoryId'] ?? 'outros';\n              map['categoryName'] = map['categoryName'] ?? 'Outros';\n              return Receipt.fromMapFromFirestore(map, doc.id);\n            }).toList());\n  }\n\n  // Products & categories\n  Future<Map<String, ProductCategory>> _getCategoryMap() async {\n    final snapshot = await _productCategoriesCollection.get();\n    final categories = snapshot.docs.map((doc) {\n      final data = doc.data() as Map<String, dynamic>;\n      // ensure id is set\n      return ProductCategory.fromMapFromFirestore(data, doc.id);\n    }).toList();\n\n    final map = {for (var c in categories) c.id: c};\n    map[ProductCategory.indefinida.id] = ProductCategory.indefinida;\n    return map;\n  }\n\n  Future<void> addProduct(Product product) => _productsCollection.add(product.toMapForFirestore());\n  Future<void> updateProduct(Product product) => _productsCollection.doc(product.id).update(product.toMapForFirestore());\n  Future<void> deleteProduct(String id) => _productsCollection.doc(id).delete();\n\n  Stream<List<Product>> getProductsStream() {\n    return _productsCollection.snapshots().asyncMap((productSnapshot) async {\n      final categoryMap = await _getCategoryMap();\n      final products = productSnapshot.docs.map((doc) {\n        final data = doc.data() as Map<String, dynamic>;\n        final cat = categoryMap[data['categoryId']] ?? ProductCategory.indefinida;\n        return Product.fromMapFromFirestore(data, doc.id);\n      }).toList();\n      return products;\n    });\n  }\n\n  Stream<List<ProductCategory>> getCategoriesStream() {\n    return _productCategoriesCollection\n        .snapshots()\n        .map((snap) => snap.docs.map((doc) {\n              final data = doc.data() as Map<String, dynamic>;\n              return ProductCategory.fromMapFromFirestore(data, doc.id);\n            }).toList());\n  }\n\n  Future<void> addProductCategory(ProductCategory category) =>\n      _productCategoriesCollection.add(category.toMapForFirestore());\n\n  Future<void> updateUserName(String name) async {\n    // Usamos set com merge para criar o documento se ele não existir\n    await _usersCollection.doc(uid).set({\n      'displayName': name,\n    }, SetOptions(merge: true));\n  }\n\n  Future<String?> getUserName(String targetUid) async {\n    try {\n      final doc = await _usersCollection.doc(targetUid).get();\n      if (doc.exists && doc.data() != null) {\n        final data = doc.data() as Map<String, dynamic>;\n        return data['displayName'] as String?;\n      }\n    } catch (e) {\n      print('Erro ao buscar nome: $e');\n    }\n    return null;\n  }\n}\n",
        "gemini_service.dart": "import 'dart:convert';\nimport 'dart:async'; // Para StreamSubscription e temporizadores\nimport 'package:http/http.dart' as http;\n\n/// Classe auxiliar para analisar a resposta JSON estruturada da IA.\n/// Não é um modelo do Firestore, é apenas um DTO (Data Transfer Object).\nclass ClassifiedProduct {\n  final String productName;\n  final String categoryName;\n  final int priority;\n\n  ClassifiedProduct({\n    required this.productName,\n    required this.categoryName,\n    required this.priority,\n  });\n\n  factory ClassifiedProduct.fromJson(Map<String, dynamic> json) {\n    return ClassifiedProduct(\n      productName: json['productName'] ?? 'Produto Desconhecido',\n      categoryName: json['categoryName'] ?? 'Indefinida',\n      priority: (json['priority'] as num? ?? 3).toInt(),\n    );\n  }\n}\n\nclass GeminiService {\n  // ATENÇÃO: Obtenha a sua chave de API no Google AI Studio\n  // Execute a app com: flutter run --dart-define=GEMINI_API_KEY=SUA_CHAVE_AQUI\n  static const _apiKey = String.fromEnvironment('GEMINI_API_KEY');\n  final String model = 'gemini-1.5-flash-latest';\n  final String _apiUrl;\n\n  GeminiService() : _apiUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$_apiKey';\n\n  /// Classifica uma lista de nomes de produtos e atribui-lhes prioridades.\n  Future<List<ClassifiedProduct>> classifyProducts(List<String> productNames, List<String> categories) async {\n    if (_apiKey.isEmpty) {\n      throw Exception('Chave de API do Gemini não configurada. Use --dart-define=GEMINI_API_KEY=SUA_CHAVE');\n    }\n\n    // 1. O Prompt do Sistema: Define as regras para a IA\n    final systemPrompt = \"\"\"\n      Você é um assistente de finanças pessoais especializado em classificar listas de compras no Brasil.\n      Sua tarefa é analisar uma lista de nomes de produtos de uma nota fiscal e atribuir a cada um:\n      1.  Uma categoria da lista fornecida.\n      2.  Uma prioridade de 1 (essencial) a 5 (supérfluo).\n\n      Categorias disponíveis: ${categories.join(', ')}\n      Use a categoria \"Indefinida\" se nenhuma outra se aplicar.\n\n      Níveis de Prioridade:\n      1: Essencial (ex: Arroz, Feijão, Ovos, Papel Higiênico, Sabonete)\n      2: Importante (ex: Frutas, Legumes, Carne, Café, Pão)\n      3: Neutro (ex: Iogurte, Manteiga, Suco, Shampoo, Detergente)\n      4. Dispensável (ex: Refrigerante, Salgadinhos, Biscoitos Recheados)\n      5: Supérfluo/Luxo (ex: Vinho Caro, Chocolate Importado, Decoração)\n\n      Responda APENAS com um objeto JSON contendo um array chamado \"classifications\".\n      NÃO inclua markdown (```json ... ```) ou qualquer outro texto.\n    \"\"\";\n\n    // 2. O Prompt do Utilizador: Os dados a serem processados\n    final userPrompt = \"Classifique os seguintes produtos:\\n${productNames.join('\\n')}\";\n\n    // 3. O Schema da Resposta: Como queremos que a IA devolva os dados\n    final responseSchema = {\n      \"type\": \"OBJECT\",\n      \"properties\": {\n        \"classifications\": {\n          \"type\": \"ARRAY\",\n          \"items\": {\n            \"type\": \"OBJECT\",\n            \"properties\": {\n              \"productName\": {\"type\": \"STRING\"},\n              \"categoryName\": {\"type\": \"STRING\"},\n              \"priority\": {\"type\": \"NUMBER\"}\n            },\n            \"required\": [\"productName\", \"categoryName\", \"priority\"]\n          }\n        }\n      },\n      \"required\": [\"classifications\"]\n    };\n\n    // 4. O Payload da Requisição\n    final payload = {\n      \"systemInstruction\": {\n        \"parts\": [{\"text\": systemPrompt}]\n      },\n      \"contents\": [\n        {\"parts\": [{\"text\": userPrompt}]}\n      ],\n      \"generationConfig\": {\n        \"responseMimeType\": \"application/json\",\n        \"responseSchema\": responseSchema,\n      }\n    };\n\n    // 5. A Chamada de API com Retentativa (Exponential Backoff)\n    int retries = 0;\n    while (retries < 3) { // Tenta até 3 vezes\n      try {\n        final response = await http.post(\n          Uri.parse(_apiUrl),\n          headers: {'Content-Type': 'application/json'},\n          body: jsonEncode(payload),\n        ).timeout(const Duration(seconds: 45));\n\n        if (response.statusCode == 200) {\n          final body = jsonDecode(response.body);\n          final candidate = body['candidates']?[0];\n          \n          if (candidate == null) {\n            throw Exception('Resposta da API inválida: \"candidates\" não encontrado.');\n          }\n\n          final jsonText = candidate['content']?['parts']?[0]?['text'];\n          if (jsonText == null) {\n            throw Exception('Resposta da API inválida: \"text\" não encontrado.');\n          }\n\n          final Map<String, dynamic> result = jsonDecode(jsonText);\n          final List<dynamic> classifications = result['classifications'] ?? [];\n          \n          return classifications\n              .map((item) => ClassifiedProduct.fromJson(item as Map<String, dynamic>))\n              .toList();\n\n        } else if (response.statusCode == 429 || response.statusCode == 503) {\n          // 429: Too Many Requests / 503: Service Unavailable (comum em picos)\n          throw http.ClientException(\"Serviço indisponível ou limite de taxa atingido.\", response.request?.url);\n        } else {\n          // Outros erros\n          final errorBody = jsonDecode(response.body);\n          throw Exception('Erro da API Gemini: ${response.statusCode} - ${errorBody['error']?['message'] ?? response.body}');\n        }\n\n      } catch (e) {\n        retries++;\n        if (e is TimeoutException || e is http.ClientException) {\n          if (retries >= 3) rethrow; // Desiste após a última tentativa\n          final delay = Duration(seconds: 2 * retries); // 2s, 4s\n          print('Erro de rede ou timeout, tentando novamente em $delay... ($e)');\n          await Future.delayed(delay);\n        } else {\n          // Erro de parsing ou outro erro inesperado\n          print('Erro não recuperável no GeminiService: $e');\n          rethrow; // Desiste imediatamente\n        }\n      }\n    }\n    // Se sair do loop (o que não deve acontecer)\n    throw Exception('Falha ao classificar produtos após 3 tentativas.');\n  }\n}\n\n",
        "nfce_service.dart": "import 'dart:async';\n\nimport 'package:cloud_firestore/cloud_firestore.dart';\nimport 'package:family_finances/models/nfce.dart';\nimport 'package:http/http.dart' as http;\n// Para parsear a data\nimport 'package:xml/xml.dart' as xml;\nimport '../models/nfce_item_detail.dart'; // Importa a nova classe\n\n// A classe NfceData foi removida, usamos NotaFiscal diretamente\n\nclass NfceService {\n\n  // Função auxiliar interna para buscar texto de forma segura\n  String _getElementText(xml.XmlElement parent, String elementName, {String defaultValue = ''}) {\n      try {\n        // Usa .firstOrNull para evitar exceções se o elemento não for encontrado\n        return parent.findElements(elementName).firstOrNull?.innerText ?? defaultValue;\n      } catch (e) {\n        print(\"Erro ao buscar elemento $elementName: $e\");\n        return defaultValue;\n      }\n  }\n\n\n  Future<Nfce> fetchAndParseNfce(String url) async {\n    try {\n      // Adiciona um timeout à requisição para evitar travamentos\n      final response = await http.get(Uri.parse(url)).timeout(const Duration(seconds: 15));\n\n      if (response.statusCode == 200) {\n        final document = xml.XmlDocument.parse(response.body);\n\n        // Busca os elementos principais de forma mais segura\n        final nfeElement = document.findAllElements('NFe').firstOrNull;\n        if (nfeElement == null) throw Exception('Elemento <NFe> não encontrado no XML.');\n\n        final infNFeElement = nfeElement.getElement('infNFe');\n        if (infNFeElement == null) throw Exception('Elemento <infNFe> não encontrado no XML.');\n\n        final ideElement = infNFeElement.getElement('ide');\n        if (ideElement == null) throw Exception('Elemento <ide> não encontrado no XML.');\n\n        final emitElement = infNFeElement.getElement('emit');\n        if (emitElement == null) throw Exception('Elemento <emit> não encontrado no XML.');\n\n        final totalElement = infNFeElement.getElement('total')?.getElement('ICMSTot');\n        if (totalElement == null) throw Exception('Elemento <ICMSTot> não encontrado no XML.');\n\n        final infAdicElement = infNFeElement.getElement('infAdic'); // Pode ser nulo\n\n        // --- Extração dos Detalhes da Nota ---\n        final String nfceKey = infNFeElement.getAttribute('Id')?.replaceAll('NFe', '') ?? '';\n        final String storeName = _getElementText(emitElement, 'xNome', defaultValue: 'Loja Desconhecida');\n        final String totalValueText = _getElementText(totalElement, 'vNF');\n        final double totalValue = double.tryParse(totalValueText) ?? 0.0;\n        final String dateText = _getElementText(ideElement, 'dhEmi');\n\n        // Parse da data\n        Timestamp date = Timestamp.now(); // Valor padrão\n         try {\n           // Formato ISO 8601 com timezone offset: 2025-09-24T17:46:33-03:00\n            DateTime parsedDate = DateTime.parse(dateText);\n            date = Timestamp.fromDate(parsedDate);\n         } catch(e) {\n           print(\"Erro ao parsear data da NFC-e ('$dateText'): $e. Usando data atual.\");\n         }\n\n         // --- Extração das Informações Adicionais (Impostos) ---\n        String taxInfo = '';\n        if (infAdicElement != null) {\n          taxInfo = _getElementText(infAdicElement, 'infCpl');\n          // Tenta extrair apenas a parte dos tributos\n           final tribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+ Federal.*? R\\$[\\d,\\.]+ Estadual.*?Fonte IBPT');\n           final match = tribRegex.firstMatch(taxInfo);\n           if (match != null) {\n             taxInfo = match.group(0)!; // Pega só a parte dos tributos\n           } else {\n             // Se não encontrar o padrão exato, tenta um padrão mais simples\n             final simpleTribRegex = RegExp(r'Trib.*? aprox: R\\$[\\d,\\.]+');\n             final simpleMatch = simpleTribRegex.firstMatch(taxInfo);\n             taxInfo = simpleMatch?.group(0) ?? ''; // Pega o que encontrar ou deixa vazio\n           }\n        }\n\n        // --- Extração dos Itens ---\n        final productsXml = infNFeElement.findAllElements('det');\n        \n        final List<NfceItemDetail> items = [];\n        for (final product in productsXml) {\n          final prodElement = product.getElement('prod');\n          if (prodElement == null) continue; // Pula se não houver <prod>\n\n          final String name = _getElementText(prodElement, 'xProd');\n          final String qtyText = _getElementText(prodElement, 'qCom');\n          final String unitPriceText = _getElementText(prodElement, 'vUnCom');\n          final String totalPriceText = _getElementText(prodElement, 'vProd');\n\n          final double quantity = double.tryParse(qtyText) ?? 0;\n          final double unitPrice = double.tryParse(unitPriceText) ?? 0;\n          final double totalPrice = double.tryParse(totalPriceText) ?? 0;\n\n          if (name.isNotEmpty) {\n            items.add(NfceItemDetail(\n              name: name.trim(), // Remove espaços extras\n              quantity: quantity,\n              unitPrice: unitPrice,\n              totalPrice: totalPrice,\n            ));\n          }\n        }\n\n        if (items.isEmpty && totalValue == 0) {\n           throw Exception('Nenhum dado relevante (itens ou valor total) encontrado no XML da NFC-e.');\n        }\n\n        // Cria e retorna o objeto NotaFiscal completo\n        return Nfce(\n          nfceKey: nfceKey,\n          storeName: storeName,\n          totalValue: totalValue,\n          date: date,\n          taxInfo: taxInfo,\n          items: items,\n        );\n      } else {\n        throw Exception('Falha ao carregar a página da NFC-e. Código de status: ${response.statusCode}');\n      }\n    } on TimeoutException {\n       throw Exception('Tempo limite excedido ao buscar dados da NFC-e.');\n    } catch (e) {\n       print(\"Erro detalhado no fetchAndParseNfce: $e\");\n       // Re-lança a exceção para ser tratada na UI, talvez com uma mensagem mais amigável\n       throw Exception('Ocorreu um erro ao processar a NFC-e: ${e.toString()}');\n    }\n  }\n}\n\n"
    },
    "styles": {
        "app_colors.dart": "import 'package:flutter/material.dart';\nclass AppColors {\n  static const Color primary = Color(0xFF2A8782);\n  static const Color secondary = Color(0xFFF8F8F8);\n  static const Color background = Color(0xFFFFFFFF);\n  static const Color surface = Color(0xFFFFFFFF);\n  static const Color error = Color(0xFFB00020);\n  static const Color onPrimary = Color(0xFFFFFFFF);\n  static const Color onSecondary = Color(0xFF000000);\n  static const Color onBackground = Color(0xFF000000);\n  static const Color onSurface = Color(0xFF000000);\n  static const Color onError = Color(0xFFFFFFFF);\n}",
        "app_theme.dart": "import 'package:family_finances/styles/app_colors.dart';\nimport 'package:flutter/material.dart';\n\nclass AppTheme{\n  static ColorScheme get appColorScheme => ColorScheme.fromSeed(seedColor: AppColors.primary);\n  static ThemeData get appTheme => ThemeData(\n    colorScheme: appColorScheme,\n        useMaterial3: true,\n    primaryColor: AppColors.primary,\n        scaffoldBackgroundColor: AppColors.background,\n        fontFamily: 'sans-serif',\n        appBarTheme: AppBarTheme(\n          backgroundColor: AppColors.primary,\n          foregroundColor: Colors.white,\n          elevation: 0,\n          titleTextStyle: TextStyle(\n            fontSize: 20,\n            fontWeight: FontWeight.bold,\n            fontFamily: 'sans-serif',\n          ),\n        ),\n        bottomNavigationBarTheme: const BottomNavigationBarThemeData(\n          selectedItemColor: Color(0xFF2A8782),\n          unselectedItemColor: Colors.grey,\n          backgroundColor: Colors.white,\n        ),\n        );\n}",
        "section_style.dart": "import 'package:flutter/material.dart';\n\nclass SectionStyle extends BoxDecoration{\n  SectionStyle() : super(\n    color: Colors.white,\n    borderRadius: BorderRadius.circular(8),\n    \n    boxShadow: [\n      BoxShadow(\n        color: Colors.black.withOpacity(0.1),\n        blurRadius: 4,\n        offset: const Offset(0, 2),\n      ),\n    ],\n  );\n}"
    },
    "utils": {
        "nfce_parser.dart": "String? extractAccessKeyFromUrl(String url) {\n  // A expressão regular procura por uma sequência de 44 dígitos numéricos\n  final RegExp regExp = RegExp(r'(\\d{44})');\n  final match = regExp.firstMatch(url);\n  \n  // Retorna a chave encontrada ou null se não encontrar\n  return match?.group(1);\n}"
    },
    "widgets": {
        "category_picker.dart": "import 'package:flutter/material.dart';\n\nimport '../models/expense_category.dart';\nimport '../models/receipt_category.dart';\n\nclass CategoryPicker extends StatelessWidget {\n  final bool isExpense;\n\n  final ExpenseCategory? selectedExpense;\n  final ReceiptCategory? selectedReceipt;\n\n  const CategoryPicker({\n    super.key,\n    required this.isExpense,\n    this.selectedExpense,\n    this.selectedReceipt,\n  });\n\n  @override\n  Widget build(BuildContext context) {\n    final List<dynamic> categories = isExpense\n        ? ExpenseCategory.defaults\n        : ReceiptCategory.defaults;\n\n    return SafeArea(\n      child: Container(\n        height: MediaQuery.of(context).size.height * 0.6,\n        padding: const EdgeInsets.all(18),\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Text(\n              \"Escolher categoria\",\n              style: Theme.of(context).textTheme.headlineSmall,\n            ),\n            const SizedBox(height: 16),\n            Expanded(\n              child: GridView.builder(\n                itemCount: categories.length,\n                gridDelegate:\n                    const SliverGridDelegateWithFixedCrossAxisCount(\n                  crossAxisCount: 4,\n                  childAspectRatio: .8,\n                ),\n                itemBuilder: (_, i) {\n                  final cat = categories[i];\n\n                  final bool isSelected = isExpense\n                      ? selectedExpense?.name == cat.name\n                      : selectedReceipt?.name == cat.name;\n\n                  return GestureDetector(\n                    onTap: () => Navigator.pop(context, cat),\n                    child: Column(\n                      children: [\n                        CircleAvatar(\n                          radius: isSelected ? 28 : 24,\n                          backgroundColor: isSelected\n                              ? Colors.blue.shade200\n                              : Colors.grey.shade200,\n                          child: Icon(\n                            cat.icon,\n                            size: 28,\n                          ),\n                        ),\n                        const SizedBox(height: 6),\n                        Text(\n                          cat.name,\n                          style: const TextStyle(fontSize: 12),\n                          textAlign: TextAlign.center,\n                        ),\n                      ],\n                    ),\n                  );\n                },\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}\n",
        "input_card.dart": "import 'package:flutter/material.dart';\nclass InputCard extends StatelessWidget {\n  final Widget child;\n  const InputCard(\n   {super.key, required this.child,});\n\n  @override\n  Widget build(BuildContext context) {\n    return Card(\n      elevation: 4,\n      margin: const EdgeInsets.symmetric(vertical: 8.0),\n      child: Padding(\n        padding: const EdgeInsets.all(8.0),\n        child: child,\n      ),\n    );\n  }\n}",
        "row_option.dart": "\nimport 'package:flutter/material.dart';\nclass RowOption extends StatelessWidget {\n  final String title;\n  final IconData iconData;\n  final VoidCallback onTap;\n\n  const RowOption({super.key, \n    required this.title,\n    required this.iconData,\n    required this.onTap,\n  }); \n  @override\n  Widget build(BuildContext context) {\n    return Column(\n        children: [\n      IconButton.filled(\n        color: Colors.white,\n        iconSize: 40,\n        highlightColor: Colors.grey[300],\n        onPressed: onTap, \n        icon: Icon(iconData),\n        ),\n        Text(title),\n        ]\n      );\n  }\n}"
    }
}